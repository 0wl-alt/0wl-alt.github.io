{"pages":[],"posts":[{"title":"HGAME-Week1-writeup","text":"1.web1.Hitchhiking_in_the_Galaxy​ 网页f12发现 /HitchhikerGuide.php , 抓包发现 302, 于是在 Linux 中用 curl 命令访问这里,发现 405 那么就改用 post 请求方式 ​ 刚开始看到这句话后没有一点想法,就去看了看发的学习资料,看到 user-agent 后意识到应该是要加这个头 (因为引擎) , 内容是那串英文 ​ 仅能通过本地访问 , 那么就再加一个 x-forwarded-for 头 , 最后说要从茄子学长的网站过来 , 再加一个 referer 头,得到 flag 2.watermelon​ 打开网页发现是合成大西瓜, 玩了一遍发现要达到2000分才能得到flag, 于是毫不犹豫地抓包(可惜接受不到分数,是为什么我也不清楚) 抓包不行那么就只能修改 js 代码,然而在我试图修改的过程中发现 ​ 把网页变成这样就能轻松玩到2000分! (到底怎么改js代码我不太清楚,应该是要找到存储分数的变量,然后在 console 里修改…..) ​ 得到 flag 3.宝藏走私者​ 先拿着学习资料学习了一下,之后点开网页点击 secret data 跳转到另一个界面,提示要是 localhost ,于是加了 host 头 ​ 意外的就得到了 flag (不知道怎么得到的, 好像跟学习资料无关?) 4.智商检测鸡​ 用 firefox 浏览器打开网页发现要做100道定积分才能得到 flag, f12看到网页源代码,里面有个 getflag() 函数 ​ 在 console 输入后,弹出一句话(是啥我忘了) , 得知这样不行,于是我就搭配定积分计算器解完了这100题,得到 flag (之后看r4u学长发的学习资料,觉得应该是 python 爬虫一类的,可惜我 python 还不太会,只能手动解题了) web 总结: web 开始的时候是真的一点都不会, watermelon 和定积分都不是通过 web 知识解的, burp 也是前几天刚装的(安装花了一天…),总之学到了很多 2.reverse1.apacha​ 应该是这周 re里最难的（但其实也不是太难），首先用 ida 打开文件并初步分析 ​ 关键部分在第25和第26行的两个函数 ​ 第一个关键函数，刚开始看觉得挺复杂的后来发现了 tea 型加密算法的特征，查资料猜测这应该是 xxtea 加密算法 ​ 第二个关键函数，判断输入是否为 flag 。加密后的 flag存在unk_501C , 每四个字节一组 ​ 之后就是写脚本解密，于是在网上找了一个现成的脚本（ c语言），改了一下就得到 flag（这里有个地方需要注意，因为是小端序所以 ida 中加密的数据每四个字节要逆序才是真正的加密数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define tea_DELTA 0x9e3779b9#define xxtea_MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void xxtea(uint32_t* origin, int n, uint32_t const key[4]);int main(){ unsigned int data[] = { 0xE74EB323,0xB7A72836,0x59CA6FE2,0x967CC5C1,0xE7802674 ,0x3D2D54E6,0x8A9D0356,0x99DCC39C,0x7026D8ED,0x6A33FDAD, 0xF496550A,0x5C9C6F9E,0x1BE5D04C,0x6723AE17,0x5270A5C2, 0xAC42130A,0x84BE67B2,0x705CC779,0x5C513D98,0xFB36DA2D, 0x22179645,0x5CE3529D,0xD189E1FB,0xE85BD489,0x73C8D11F,0x54B5C196, 0xB67CB490,0x2117E4CA,0x9DE3F994,0x2F5AA1AA,0xA7E801FD,0xC30D6EAB, 0x1BADDC9C,0x3453B04A,0x92A406F9 }; int i, j;uint32_t* encode = (uint32_t*)data; uint32_t const key[4] = {1,2,3,4}; xxtea(encode, -35, key); for (i = 0; i &lt; 35; i++) printf(&quot;%d,&quot;, data[i]);}void xxtea(uint32_t* origin, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = origin[n - 1]; do { sum += tea_DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = origin[p + 1]; z = origin[p] += xxtea_MX; } y = origin[0]; z = origin[n - 1] += xxtea_MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * tea_DELTA; y = origin[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = origin[p - 1]; y = origin[p] -= xxtea_MX; } z = origin[n - 1]; y = origin[0] -= xxtea_MX; sum -= tea_DELTA; } while (--rounds); }} 2.helloRe​ 这题不难，只是有点 c++ 的语法，同样 ida ![](HGAME-Week1-writeup/reverse2 .png) ​ 关键在中间的异或操作，写个脚本就能得到结果 3.pypy​ 这题考的是 python 字节码，刚开始看的时候还不太懂python语法花了点时间去理解，通过 dis 文档来分析每一条语句，大概还原了一下 ​ 理解之后就是用脚本解题，再加上 hgame{} （刚开始交的时候忘加了） 3.pwn1.whitegive​ 下载，在 Linux 中用 gdb 调试，得知输入数字在栈中的的存储位置为 0x7ffffffffde50 ![](HGAME-Week1-writeup/pwn1 (3).png) ​ 继续调试，发现最后 if 语句比较的是 rax 和 rdx 的值，而此时 rax 存储的是 ‘paSsw0rd’ 字符串的地址，那么只要输入这个地址的十进制值就能使条件成立 ![](HGAME-Week1-writeup/pwn1 (2).png) ![](HGAME-Week1-writeup/pwn1 (4).png) ​ nc连接，cat flag（的确挺白给的，毕竟我都能做） pwn 总结：我也太菜了只解出白给题 ,看了最后一题但不太会 rop , 总之这周就稍微学习了一下怎么写 pwn 的脚本和一些基础知识以及安装工具 4.crypto2.对称之美​ 打开链接下载 python 文件 ​ key 是在 ascii 字母和数字里随机选取16个组成，而 cipher 是由明文与循环的 key 异或得到的密文 ​ 根据异或特性知道密文与循环的 key 异或就是明文，那么这道题重点就是求出一组 key 。多次下载附件发现 cipher 各不同，那就利用多个密文写脚本爆破得到前16位明文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;de0 = []c = []for i in range(0,130): c.append(0)flag = []#for i in range(0, 16):for j in range(0, 62): de0.append(xor(cipher0[15], table[j])) de0.append(xor(cipher1[15], table[j])) de0.append(xor(cipher2[15], table[j])) de0.append(xor(cipher3[15], table[j])) de0.append(xor(cipher4[15], table[j])) de0.append(xor(cipher5[15], table[j])) de0.append(xor(cipher6[15], table[j])) de0.append(xor(cipher7[15], table[j])) de0.append(xor(cipher8[15], table[j])) de0.append(xor(cipher9[15], table[j])) de0.append(xor(cipher10[15], table[j])) de0.append(xor(cipher11[15], table[j])) de0.append(xor(cipher12[15], table[j])) de0.append(xor(cipher13[15], table[j])) de0.append(xor(cipher14[15], table[j])) de0.append(xor(cipher15[15], table[j])) de0.append(xor(cipher16[15], table[j])) de0.append(xor(cipher17[15], table[j])) de0.append(xor(cipher18[15], table[j])) de0.append(xor(cipher19[15], table[j])) de0.append(xor(cipher20[15], table[j])) de0.append(xor(cipher21[15], table[j])) de0.append(xor(cipher22[15], table[j])) de0.append(xor(cipher23[15], table[j])) de0.append(xor(cipher24[15], table[j])) de0.append(xor(cipher25[15], table[j])) de0.append(xor(cipher26[15], table[j])) de0.append(xor(cipher27[15], table[j])) de0.append(xor(cipher28[15], table[j])) de0.append(xor(cipher29[15], table[j])) de0.append(xor(cipher30[15], table[j])) de0.append(xor(cipher31[15], table[j])) de0.append(xor(cipher32[15], table[j])) de0.append(xor(cipher33[15], table[j]))for j in de0: c[j] = c[j] + 1for j in range(0, 128): if c[j] == 34: print(j) ​ 知道前16位明文，那就可以求得一组 key ，并得到 flag，过程同样是写脚本 ​ Get flag! 3.Transformer​ 下载，发现其中一个文件中有flag形式的字符串，还有两个文件分别存储明文和密文，虽然顺序是打乱了的 ​ 接下来就采用传统的人工查找明文和密文一一对应的方式得到flag ​ 当然那个 txt 文件最后解密还提示 flag 后面要加上年份2021才正确 （搜了一下题目发现是人工智能模型，我只有人工没有智能……） crypto 总结：没想到最后竟是第一题没解出来，本来以为第二题解不出来反而解出来了。这周稍微学了点怎样写解密脚本，收获挺大 5.misc1.Base全家福​ 题目中提到 base家族，查资料得知有不只有 base64 ，再根据不同 base 加密字符的特征多次解密 ​ 如图所示，得到 flag 2.不起眼压缩包的养成的方法​ 打开得到图片，题目中提到了压缩包，猜测能从图片中得到压缩包，于是在 linux 中用 binwalk 检测发现了压缩包，并用 foremost 命令分离出来 ​ 分离解压后得到 ​ 发现得到里面的文件需要密码，那就用百度识图来获取之前得到的图片的p站id解密。之后点进plain.zip发现又需要密码，并且发现plain.zip里有flag.zip和相同的NO PASSWORD.txt文件，猜测是利用明文攻击解密，用相同的方式压缩已得到的NO PASSWORD.txt。 ​ 根据提示storage，用仅存储的方式压缩（刚开始不知道storage是存储等级所以卡了一会儿，问了学长后才知道） 再用ARCHPR进行破解，得到口令和密钥，最后得到flag.zip的内容。16进制转字符串，得flag 3.Galaxy​ 打开连接下载，得到以**.pcapng**为后缀的文件，之后用 wireshark 打开 ​ 如图所示，导出 http 流 ​ 找到了遗失的 galaxy 图片，在 windows 下能正常打开，但之后把图片放到 linux 中，想用 binwalk 分析的时候发现在 Linux 下无法打开图片。 ​ 上网查资料得知图片的高和宽可能被修改，与原来 crc 值不匹配才报错。于是在网上找了个脚本，得到正确的高宽 ![](HGAME-Week1-writeup/misc3 (2).png) ​ 然后就用 winhex 修改高和宽并保存 ​ 得到 flag！ 4.Word RE:MASTER​ 下载得两个文档，发现其中一个文档加密了，那就先打开另一个文档 ​ 在 first.docx 文档中发现了 brain 和 fuck 两个单词，猜测有brainfuck 加密，但是之后因为不知道密文卡了很久，尝试用 winhex 打开另一个文档得到 ​ 我以为这就是密文了，于是就开心的拿去解密网站解密（当然这是错的） ​ 问了Akira 学长后发现这密文缺少了前半部分，只能转用别的方法。首先尝试把第一个文档的后缀改为 zip ，打开后竟发现 ​ ​ 丢到网站解密后得到 DOYOUKNOWHIDDEN? ，用这个打开第二个文档 ​ 因为这个文档密码是 DOYOUKNOWHIDDEN? ，所以立马显示 word 的隐藏字符，得到 ​ 一堆空白字符，由空格和制表符组成，这里我用箭头和点表示 ​ 这之后就卡了很久（大概一天多……），我甚至尝试用二进制01表示，实在想不出来了于是去问学长，提示我搜一下第二个文档图片中出现最多的字的英文（之前一直盯着图片内容看，以为hint是音游梗，果然是我想太多orz） ​ 接着就搜索snow，知道了空白字符的隐写，上工具解密 misc总结：拿到题目后完全没思路，所以在这一周中查了很多资料，觉得自己就是个菜鸡，好在最后全部解了出来，也学到了很多东西","link":"/2021/03/26/HGAME-Week1-writeup/"}],"tags":[{"name":"hgame","slug":"hgame","link":"/tags/hgame/"}],"categories":[]}