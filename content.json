{"pages":[],"posts":[{"title":"HGAME-Week2-Writeup","text":"Web1.LazyDogR4U​ 首先打开题目地址 ​ 根据题目给的hint，在地址栏后面加上 /www.zip 获得网页源码 ​ 接着打开 lazy.php 和 flag.php 这两个php文件，再根据变量覆盖的提示找到漏洞点 ​ 这里划线处的两个$符号容易导致变量覆盖，那么根据 flag.php 中得到flag的条件就可以进行构造，相当于： $_SESSSION[username]=admin ​ 双写SESSION是因为上面str_replace的过滤 ​ 得到flag 2.Post to zuckonit​ ​ 点开后发现是留言板，题目也很明确的指出是xss，那么就先尝试输入 script，iframe，image ​ 输入后发现不管大小写 script 都会被过滤掉，小写的 iframe 会被过滤，image则不会被过滤 ​ 之后尝试输入 img src=1 onerror = alert(1) ，让错误的图片导致弹窗 ​ 输出了这么个东西，把这个输入再 post 就会弹窗，成功弹窗之后就是找一个 xss 平台来接受 cookie 信息 ​ 根据之前的规律 post 平台给的语句，并用脚本得出 md5 验证码提交，接收到 cookie 信息 脚本： 12345678910import hashlibdef md5(s): return hashlib.md5(s.encode()).hexdigest()def get_code(): code = 'XXXXXX' for i in range(10000000, 99999999): #8位md5 if md5(str(i)).startswith(code): return str(i)print(get_code()) ​ 接着就伪造 admin cookie 得到flag Re1.ezApk​ 安卓逆向，用 jadx 反编译为 java，找到 onClick 事件 ​ 这条判断语句是关键，在资源文件中找到加密后的 flag 和 key ​ s函数用来加密输入的字符串，转到s函数分析 ​ 仔细分析后得知是AES CBC模式加密，密钥是之前的key经过sha-256加密得到的，iv向量则是key经过MD5加密得到的，最后将加密结果再进行一次 base64 加密得到之前的 flag ​ 尝试用在线网站解密，但是网站一般只支持 16 位 iv 值解密，没有别的办法只能东拼西凑写出 java 脚本来解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.company;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Base64;public class Main { //md5,sha-256加密 public static byte[] t(String str, String str2) { MessageDigest instance = null; try { instance = MessageDigest.getInstance(str); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } byte[] bytes = str2.getBytes(); byte[] digest = instance.digest(bytes); return digest; } //解密 public static String desEncrypt(String data, byte[] key) { byte[] ivString = t(&quot;MD5&quot;,&quot;A_HIDDEN_KEY&quot;); //iv向量 byte[] iv = ivString; try { byte[] encryp = Base64.getDecoder().decode(data); Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS7Padding&quot;); SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;); IvParameterSpec ivSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); byte[] original = cipher.doFinal(encryp); return new String(original); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String[] args) { String data = &quot;EEB23sI1Wd9Gvhvk1sgWyQZhjilnYwCi5au1guzOaIg5dMAj9qPA7lnIyVoPSdRY&quot;; //密文 byte[] key =t(&quot;SHA-256&quot;,&quot;A_HIDDEN_KEY&quot;); //密钥 String desencrypt = desEncrypt(data, key); System.out.println(&quot;解密后:&quot;+desencrypt); }} ​ 因为要用到的是AES 256位解密，而 java 本身只支持 128位 AES 解密，所以就要做其他的一些配置才能解密 2.helloRe2​ 拖进 IDA 分析，乍一看结构有点复杂，password1 的判断在后半部分，而password2 的判断在前半部分，先分析 password1 ​ 关键部分是这条判断，判断输入的password长度和 password 经过一系列操作后的结果，用 ollydbg 调试并不断猜测，得知这么一系列操作就是判断输入的字符串是否是给出的密文的逆序 ​ 之后再分析 pwd2 ​ 应该又是AES CBC 模式加密，找到 iv 和 密钥，密钥是pwd1经过异或得到，密文是已经给出密文的逆序 ![](D:\\HGAME2021\\HGAME week2\\re2(4).png) ​ 解密就用上一题的脚本 ​ 这里看着像是两次加密，但其实只有一次 3.fake_debugger beta​ nc题目地址，发现只有在 ebx 经过一次转换后与 eax 相等才能继续调试，之后不断调试发现 ​ 转换前的 ebx 与 eax 异或后就是 flag 中的字符，那就一个个调试下来得到 flag Crypto1.gcd or more?​ ​ 看着像是RSA，但是e = 2。百度后查到低指数爆破，之后又看到Rabin算法，特征是e = 2 ，那么就用这个脚本解题 12345678910111213141516171819202122import gmpy2import libnume = 2p = 85228565021128901853314934583129083441989045225022541298550570449389839609019q = 111614714641364911312915294479850549131835378046002423977989457843071188836271n = p * qc = 7665003682830666456193894491015989641647854826647177873141984107202099081475984827806007287830472899616818080907276606744467453445908923054975393623509539#c= int(open('./flag.enc','rb').read().encode('hex'),16)mp = pow(c, (p + 1) // 4, p)mq = pow(c, (q + 1) // 4, q)yp = gmpy2.invert(p, q)yq = gmpy2.invert(q, p)r = (yp * p * mq + yq * q * mp) % nrr = n - rs = (yp * p * mq - yq * q * mp) % nss = n - sprint(libnum.n2s(int(r)))print(libnum.n2s(int(rr)))print(libnum.n2s(int(s)))print(libnum.n2s(int(ss))) 2.WhitegiveRSA​ ​ 已知N，那就拿到在线网站里分解出大素数 q 和 p，剩下来都已知就用脚本解密 Misc1.Tools​ 下载解压得到一个压缩包和一张图片，根据题目的 tools 和压缩包名 f5 尝试用 f5 工具破解压缩包密码，破解所需的密码在图片的详细信息中 ​ 打开加密压缩包后发现一部分二维码和压缩包，接着就是像之前那样找到压缩包名里的工具解密，最终集齐4张二维码碎片，用win10自带的画图工具拼合，扫码得flag 2.Telegraph：1601 6639 3459 3134 0892​ 题目为音频隐写，又提到听着反胃，于是猜测是摩斯电码。听了之后，中间有一段嘀嗒声，这一段就是需要摩斯解密的部分，接着把音频拖到 Audacity 里面分析 ​ 首先看一下频谱图 ​ 得到850hz的提示，之后尝试翻译摩斯电码，发现中间有一段无法辨认就想到要滤波，用的是上面的提示 ​ 窄的是**.** 宽的是**-** ，翻译后解密就得到flag 3.Hallucigenia​ 只给了一张图，那么就先用 Stegsolve 左右调一下得到二维码 ​ 扫码得到一串 base64 解码发现最后是 GNP ，根据题目中 **“我们不仅弄错了他的上下，还颠倒了它的左右。” **逆序处理后粘贴到winhex保存为图片 ​ 发现又是上下左右颠倒，倒回来就得flag 4.DNS​ 流量包分析，筛选 dns 得到一串域名并访问 ​ 抓包得 ​ 查一下 SPF 知道是一种 dns 记录，那就用在线网站查一下dns记录，得到flag 总结：​ 这周比较摸鱼，web 能做出两道是因为给了具体的考点，参照往年 writeup 一点点做下来。 re 做了很久，因为之前没有接触过 apk 逆向，对 aes 加密也不太了解，最后能全部做出来真是太好了，逆向的时候果然是要抓重点，解完题后才发现其实挺简单的。 密码学是真不太行，这周 pwn 也基本没看，Misc 倒是做的挺顺畅的，下周要试着把之前的知识捡起来了","link":"/2021/03/27/HGAME-Week2-Writeup/"},{"title":"HGAME-Week3-Writeup","text":"Re1.FAKE​ 拖到ida ​ 关键函数里有36个方程，36个变量，那就不可能普通的解出来， ​ 查找字符串得到提示 Try angr or z3，我用的是 z3库，脚本太长了就不放了（用z3库解的时候一直跑不出结果，就去问了 r3n0学长，学长说可能需要点时间，但之后我重新弄了一下add的部分很快就跑出来了，应该是我自己中间操作上的问题….） ​ 假flag，查一下SMC 1SMC(self-Modifying Code)，就是在真正执行某一段代码时，程序会对自身的该段代码进行自修改，只有在修改后的代码才是可汇编，可执行的。在程序未对该段代码进行修改之前，在静态分析状态下，均是不可读的字节码，IDA之类的反汇编器无法识别程序的正常逻辑。是一种反调试代码技术。 ​ 在ida里找一下smc自解密的部分 ​ 这段代码执行后才得到真正的代码，写 idc 脚本来解密 ida 反编译后错误的代码 123456789101112#include &lt;idc.idc&gt;static main(){ auto addr = 0x00401216; //函数地址 auto addr2 = 0x00409080; //byte数组地址 auto i = 0; for(i=0;i&lt;=0x43E;i++) { PatchByte(addr+i,Byte(addr+i)^Byte(addr2+i)); }} ​ 得到运行过程中真正的代码 ​ 这部分继续用z3库写脚本去解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from z3 import *s = Solver()a1 = [0] * 36for i in range(36): a1[i] = Int('a1[' + str(i) + ']')v3 = [0]*36v2 = [0]*36v4 = [0]*36v3[0] = 55030v3[1] = 61095v3[2] = 60151v3[3] = 57247v3[4] = 56780v3[5] = 55726v3[6] = 46642v3[7] = 52931v3[8] = 53580v3[9] = 50437v3[10] = 50062v3[11] = 44186v3[12] = 44909v3[13] = 46490v3[14] = 46024v3[15] = 44347v3[16] = 43850v3[17] = 44368v3[18] = 54990v3[19] = 61884v3[20] = 61202v3[21] = 58139v3[22] = 57730v3[23] = 54964v3[24] = 48849v3[25] = 51026v3[26] = 49629v3[27] = 48219v3[28] = 47904v3[29] = 50823v3[30] = 46596v3[31] = 50517v3[32] = 48421v3[33] = 46143v3[34] = 46102v3[35] = 46744v2[0] = 104v2[1] = 103v2[2] = 97v2[3] = 109v2[4] = 101v2[5] = 123v2[6] = 64v2[7] = 95v2[8] = 70v2[9] = 65v2[10] = 75v2[11] = 69v2[12] = 95v2[13] = 102v2[14] = 108v2[15] = 97v2[16] = 103v2[17] = 33v2[18] = 45v2[19] = 100v2[20] = 111v2[21] = 95v2[22] = 89v2[23] = 48v2[24] = 117v2[25] = 95v2[26] = 107v2[27] = 111v2[28] = 110v2[29] = 119v2[30] = 95v2[31] = 83v2[32] = 77v2[33] = 67v2[34] = 63v2[35] = 125for i in range(0,6): for j in range(0,6): for k in range(0,6): v4[6 * i + j] += v2[6 * k + j] * a1[6 * i + k]for i in range(0,6): for j in range(0,6): s.add(v4[6*i+j] == v3[6 * i + j])s.check()result = s.model()for i in range(0, 36): print(result[a1[i]], end=' ') Crypto1.LikiPrime​ 还是 RSA，不过素数 N 更大了，但是放到网站里分解还是能分解出 q和 p，之后就是用上周的脚本跑出flag 2.HappyNewYear!!​ e = 3，发送内容相同，自然就想到低指数广播攻击，但是广播攻击只需要 e组数据，那么猜测给的数据里解出来的明文不是全部相同。 ​ 低指数广播攻击需要用到中国剩余定理（孙子定理），脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344from libnum import n2simport gmpy2from functools import reducedef modinv(a, m): return int(gmpy2.invert(gmpy2.mpz(a), gmpy2.mpz(m)))def chinese_remainder(n, a): sum = 0 prod = reduce(lambda a, b: a * b, n) for n_i, a_i in zip(n, a): p = prod // n_i sum += a_i * modinv(p, n_i) * p return int(sum % prod)n1 = c1 = n2 = c2 = n3 = c3 = n4 = c4 = n5 = c5 =n6 = c6 = n7 = c7 = nset = [n2,n4,n6]cset = [c2,c4,c6]m = chinese_remainder(nset, cset)m = gmpy2.iroot(m,3)m = int(m[0])print(n2s(m)) c1,c3,c5 解密得到一个片段，c2,c4,c6解密得到剩下的flag片段（本来写的是随机在给出的7组数据里挑三组解密，但是没跑出结果，后来手动试了一下试出来了） Misc1.A R K​ 打开下载的流量包，首先看到dns里的域名 ​ 刚开始以为跟网址有关，但后来题目里说 “本题目所有解题操作均只用流量，与网址无关” ，那就接着看其他包，查资料知道 TLS 加密尝试找到流量包里的证书 ​ 导出原始数据保存为 ssl.log ,再重新导入解密 ​ 找到解密后的 HTTP 流，导出后得到一堆json文件，导出来后卡了一段时间，之后看到题目的补充信息 ​ 补充说明：明日方舟是一款塔防游戏，可以将可部署单位放置在场地中。并且具有自律功能，可以记录部署的操作。 翻译：没用 没用 出题人用可部署单位画了个东西 背景是白色的 ​ 记录部署操作？！那就打开 getBattleReplay 文件，看到像是 base64 编码的字符串，解码看到 zip 文件头标识另存为 zip，解压打开发现配对的 row 和 col ，应该是部署的坐标，再根据题目里的 画了个东西 猜测这些坐标是二维码黑色部分，处理一下再运行脚本 ​ 扫码得flag 2.A R C​ 压缩包加密了，那就先看图片找密码 ​ 刚开始误以为 BV 是某种 CTF 中的加密方式，在网上搜索了一圈没有收获，于是去问 Akira 学长 BV 除了 b站BV号还有什么意思，学长的答复是 ​ 怎么实现的？查 av号怎样转 bv号后发现 https://www.zhihu.com/question/381784377/answer/1099438784 这个回答里的实现方法，根据 hint1：8558 应该理解成85和58，BV号_是所以图片里的是__ 先对图里的密文进行 base85 解密 ​ 根据长度判断应该是 av号转 bv号算法里的table，那就换一下上面链接里代码的table，密文是压缩包名里的数字，跑一下得到压缩包密码 ​ 打开后得到一段 arc 视频和密文，用题目里给的软件播放视频得到 ​ 发现图中第一行文字和文本里文字相似，猜测是同种加密方式，之后又没有思路了，hint2里提到 词频分析是个好东西，别忘了视频里的问题 ，查了下视频里的问题但没什么发现。后来又放出hint 用了某种ROT的范围，但是位移不一样 ，根据两个字符的应该是 is 之类的尝试将每个字符后移10位，得到了一段英文，然后又卡住了。于是又去问 Akira学长，学长说并不是后移10位提示我再想想视频里问题的答案，突然想起之前有查到 42 这个数字，尝试后移42位得到正确的文字 ​ 视频里文字第一行也是后移 42位得到 MSU 密码，解密得到的文字里提到视频里第二行的加密方法 Liki学长提到过，根据 week1 crypto的第一题，第二行文字加密方法应该是维吉尼亚，密钥是 Akira ​ 在 virtualDub2里安装MSUstego插件，用之前得到的密码对视频进行解密，得到网址、光和对立的名字，访问网站输入用户名和密码 ​ 根据hint5: / 不是可输入的意思，是网站路径，想起之前视频解出的第二行还没用上，那就在网站路径后输入解出的明文，得到flag（pm） ​ 这周misc虽然难但很有趣，梗挺多的 总结：​ 这周因为跟父母回老家拜年少了很多做题的时间，之后电脑还出了故障重装了系统，下周要专注于re了，不能再靠着 misc 和 crypto 上分了 接下来是没做出来的部分 re​ Gun这道题用查壳工具查得是梆梆免费版加固，想要脱壳，用了很多网上查到的方法但都失败了，问了 Trotsky学长，推荐使用frida-dexdump脱壳，但是因为这道题需要root过的真机（模拟器不行）来进行脱壳，所以最后只能放弃 ​ hello_re3我没太搞明白，拖进ida发现应该都是调试信息，mezone学长说要用dbgview看调试信息再定位到程序里，可惜这题是最后一天才做的，最后没时间了，打算看官方writeup再学习一下 Crypto​ EncryptedChats这题尝试了各种方法去解，还是解不出 a 和 b ，需要的时间都很长，但是 g 挺大（不是2、5这种很小的） a 跟 b 应该是能解出来的…","link":"/2021/03/27/HGAME-Week3-Writeup/"},{"title":"HGAME-Week1-writeup","text":"1.web1.Hitchhiking_in_the_Galaxy​ 网页f12发现 /HitchhikerGuide.php , 抓包发现 302, 于是在 Linux 中用 curl 命令访问这里,发现 405 那么就改用 post 请求方式 ​ 刚开始看到这句话后没有一点想法,就去看了看发的学习资料,看到 user-agent 后意识到应该是要加这个头 (因为引擎) , 内容是那串英文 ​ 仅能通过本地访问 , 那么就再加一个 x-forwarded-for 头 , 最后说要从茄子学长的网站过来 , 再加一个 referer 头,得到 flag 2.watermelon​ 打开网页发现是合成大西瓜, 玩了一遍发现要达到2000分才能得到flag, 于是毫不犹豫地抓包(可惜接受不到分数,是为什么我也不清楚) 抓包不行那么就只能修改 js 代码,然而在我试图修改的过程中发现 ​ 把网页变成这样就能轻松玩到2000分! (到底怎么改js代码我不太清楚,应该是要找到存储分数的变量,然后在 console 里修改…..) ​ 得到 flag 3.宝藏走私者​ 先拿着学习资料学习了一下,之后点开网页点击 secret data 跳转到另一个界面,提示要是 localhost ,于是加了 host 头 ​ 意外的就得到了 flag (不知道怎么得到的, 好像跟学习资料无关?) 4.智商检测鸡​ 用 firefox 浏览器打开网页发现要做100道定积分才能得到 flag, f12看到网页源代码,里面有个 getflag() 函数 ​ 在 console 输入后,弹出一句话(是啥我忘了) , 得知这样不行,于是我就搭配定积分计算器解完了这100题,得到 flag (之后看r4u学长发的学习资料,觉得应该是 python 爬虫一类的,可惜我 python 还不太会,只能手动解题了) web 总结: web 开始的时候是真的一点都不会, watermelon 和定积分都不是通过 web 知识解的, burp 也是前几天刚装的(安装花了一天…),总之学到了很多 2.reverse1.apacha​ 应该是这周 re里最难的（但其实也不是太难），首先用 ida 打开文件并初步分析 ​ 关键部分在第25和第26行的两个函数 ​ 第一个关键函数，刚开始看觉得挺复杂的后来发现了 tea 型加密算法的特征，查资料猜测这应该是 xxtea 加密算法 ​ 第二个关键函数，判断输入是否为 flag 。加密后的 flag存在unk_501C , 每四个字节一组 ​ 之后就是写脚本解密，于是在网上找了一个现成的脚本（ c语言），改了一下就得到 flag（这里有个地方需要注意，因为是小端序所以 ida 中加密的数据每四个字节要逆序才是真正的加密数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define tea_DELTA 0x9e3779b9#define xxtea_MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void xxtea(uint32_t* origin, int n, uint32_t const key[4]);int main(){ unsigned int data[] = { 0xE74EB323,0xB7A72836,0x59CA6FE2,0x967CC5C1,0xE7802674 ,0x3D2D54E6,0x8A9D0356,0x99DCC39C,0x7026D8ED,0x6A33FDAD, 0xF496550A,0x5C9C6F9E,0x1BE5D04C,0x6723AE17,0x5270A5C2, 0xAC42130A,0x84BE67B2,0x705CC779,0x5C513D98,0xFB36DA2D, 0x22179645,0x5CE3529D,0xD189E1FB,0xE85BD489,0x73C8D11F,0x54B5C196, 0xB67CB490,0x2117E4CA,0x9DE3F994,0x2F5AA1AA,0xA7E801FD,0xC30D6EAB, 0x1BADDC9C,0x3453B04A,0x92A406F9 }; int i, j;uint32_t* encode = (uint32_t*)data; uint32_t const key[4] = {1,2,3,4}; xxtea(encode, -35, key); for (i = 0; i &lt; 35; i++) printf(&quot;%d,&quot;, data[i]);}void xxtea(uint32_t* origin, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = origin[n - 1]; do { sum += tea_DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = origin[p + 1]; z = origin[p] += xxtea_MX; } y = origin[0]; z = origin[n - 1] += xxtea_MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * tea_DELTA; y = origin[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = origin[p - 1]; y = origin[p] -= xxtea_MX; } z = origin[n - 1]; y = origin[0] -= xxtea_MX; sum -= tea_DELTA; } while (--rounds); }} 2.helloRe​ 这题不难，只是有点 c++ 的语法，同样 ida ![](HGAME-Week1-writeup/reverse2 .png) ​ 关键在中间的异或操作，写个脚本就能得到结果 3.pypy​ 这题考的是 python 字节码，刚开始看的时候还不太懂python语法花了点时间去理解，通过 dis 文档来分析每一条语句，大概还原了一下 ​ 理解之后就是用脚本解题，再加上 hgame{} （刚开始交的时候忘加了） 3.pwn1.whitegive​ 下载，在 Linux 中用 gdb 调试，得知输入数字在栈中的的存储位置为 0x7ffffffffde50 ![](HGAME-Week1-writeup/pwn1 (3).png) ​ 继续调试，发现最后 if 语句比较的是 rax 和 rdx 的值，而此时 rax 存储的是 ‘paSsw0rd’ 字符串的地址，那么只要输入这个地址的十进制值就能使条件成立 ![](HGAME-Week1-writeup/pwn1 (2).png) ![](HGAME-Week1-writeup/pwn1 (4).png) ​ nc连接，cat flag（的确挺白给的，毕竟我都能做） pwn 总结：我也太菜了只解出白给题 ,看了最后一题但不太会 rop , 总之这周就稍微学习了一下怎么写 pwn 的脚本和一些基础知识以及安装工具 4.crypto2.对称之美​ 打开链接下载 python 文件 ​ key 是在 ascii 字母和数字里随机选取16个组成，而 cipher 是由明文与循环的 key 异或得到的密文 ​ 根据异或特性知道密文与循环的 key 异或就是明文，那么这道题重点就是求出一组 key 。多次下载附件发现 cipher 各不同，那就利用多个密文写脚本爆破得到前16位明文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849table = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;de0 = []c = []for i in range(0,130): c.append(0)flag = []#for i in range(0, 16):for j in range(0, 62): de0.append(xor(cipher0[15], table[j])) de0.append(xor(cipher1[15], table[j])) de0.append(xor(cipher2[15], table[j])) de0.append(xor(cipher3[15], table[j])) de0.append(xor(cipher4[15], table[j])) de0.append(xor(cipher5[15], table[j])) de0.append(xor(cipher6[15], table[j])) de0.append(xor(cipher7[15], table[j])) de0.append(xor(cipher8[15], table[j])) de0.append(xor(cipher9[15], table[j])) de0.append(xor(cipher10[15], table[j])) de0.append(xor(cipher11[15], table[j])) de0.append(xor(cipher12[15], table[j])) de0.append(xor(cipher13[15], table[j])) de0.append(xor(cipher14[15], table[j])) de0.append(xor(cipher15[15], table[j])) de0.append(xor(cipher16[15], table[j])) de0.append(xor(cipher17[15], table[j])) de0.append(xor(cipher18[15], table[j])) de0.append(xor(cipher19[15], table[j])) de0.append(xor(cipher20[15], table[j])) de0.append(xor(cipher21[15], table[j])) de0.append(xor(cipher22[15], table[j])) de0.append(xor(cipher23[15], table[j])) de0.append(xor(cipher24[15], table[j])) de0.append(xor(cipher25[15], table[j])) de0.append(xor(cipher26[15], table[j])) de0.append(xor(cipher27[15], table[j])) de0.append(xor(cipher28[15], table[j])) de0.append(xor(cipher29[15], table[j])) de0.append(xor(cipher30[15], table[j])) de0.append(xor(cipher31[15], table[j])) de0.append(xor(cipher32[15], table[j])) de0.append(xor(cipher33[15], table[j]))for j in de0: c[j] = c[j] + 1for j in range(0, 128): if c[j] == 34: print(j) ​ 知道前16位明文，那就可以求得一组 key ，并得到 flag，过程同样是写脚本 ​ Get flag! 3.Transformer​ 下载，发现其中一个文件中有flag形式的字符串，还有两个文件分别存储明文和密文，虽然顺序是打乱了的 ​ 接下来就采用传统的人工查找明文和密文一一对应的方式得到flag ​ 当然那个 txt 文件最后解密还提示 flag 后面要加上年份2021才正确 （搜了一下题目发现是人工智能模型，我只有人工没有智能……） crypto 总结：没想到最后竟是第一题没解出来，本来以为第二题解不出来反而解出来了。这周稍微学了点怎样写解密脚本，收获挺大 5.misc1.Base全家福​ 题目中提到 base家族，查资料得知有不只有 base64 ，再根据不同 base 加密字符的特征多次解密 ​ 如图所示，得到 flag 2.不起眼压缩包的养成的方法​ 打开得到图片，题目中提到了压缩包，猜测能从图片中得到压缩包，于是在 linux 中用 binwalk 检测发现了压缩包，并用 foremost 命令分离出来 ​ 分离解压后得到 ​ 发现得到里面的文件需要密码，那就用百度识图来获取之前得到的图片的p站id解密。之后点进plain.zip发现又需要密码，并且发现plain.zip里有flag.zip和相同的NO PASSWORD.txt文件，猜测是利用明文攻击解密，用相同的方式压缩已得到的NO PASSWORD.txt。 ​ 根据提示storage，用仅存储的方式压缩（刚开始不知道storage是存储等级所以卡了一会儿，问了学长后才知道） 再用ARCHPR进行破解，得到口令和密钥，最后得到flag.zip的内容。16进制转字符串，得flag 3.Galaxy​ 打开连接下载，得到以**.pcapng**为后缀的文件，之后用 wireshark 打开 ​ 如图所示，导出 http 流 ​ 找到了遗失的 galaxy 图片，在 windows 下能正常打开，但之后把图片放到 linux 中，想用 binwalk 分析的时候发现在 Linux 下无法打开图片。 ​ 上网查资料得知图片的高和宽可能被修改，与原来 crc 值不匹配才报错。于是在网上找了个脚本，得到正确的高宽 ![](HGAME-Week1-writeup/misc3 (2).png) ​ 然后就用 winhex 修改高和宽并保存 ​ 得到 flag！ 4.Word RE:MASTER​ 下载得两个文档，发现其中一个文档加密了，那就先打开另一个文档 ​ 在 first.docx 文档中发现了 brain 和 fuck 两个单词，猜测有brainfuck 加密，但是之后因为不知道密文卡了很久，尝试用 winhex 打开另一个文档得到 ​ 我以为这就是密文了，于是就开心的拿去解密网站解密（当然这是错的） ​ 问了Akira 学长后发现这密文缺少了前半部分，只能转用别的方法。首先尝试把第一个文档的后缀改为 zip ，打开后竟发现 ​ ​ 丢到网站解密后得到 DOYOUKNOWHIDDEN? ，用这个打开第二个文档 ​ 因为这个文档密码是 DOYOUKNOWHIDDEN? ，所以立马显示 word 的隐藏字符，得到 ​ 一堆空白字符，由空格和制表符组成，这里我用箭头和点表示 ​ 这之后就卡了很久（大概一天多……），我甚至尝试用二进制01表示，实在想不出来了于是去问学长，提示我搜一下第二个文档图片中出现最多的字的英文（之前一直盯着图片内容看，以为hint是音游梗，果然是我想太多orz） ​ 接着就搜索snow，知道了空白字符的隐写，上工具解密 misc总结：拿到题目后完全没思路，所以在这一周中查了很多资料，觉得自己就是个菜鸡，好在最后全部解了出来，也学到了很多东西","link":"/2021/03/26/HGAME-Week1-writeup/"},{"title":"HGAME-Week4-Writeup","text":"Re1.vm​ ​ 这部分逻辑很清晰，重点在中间这个加密的部分，点进去查看这个函数发现 switch-case 应该是vm，每个case都是一个 opcode ​ 题目里说 ovm++ hates debugger ，那就先调试一下，调试后可以猜测出具体的加密部分 ​ 输入的 flag 先是经过异或加密，之后又有减法操作，加密后与密文进行比较，写脚本解一下就能得到 flag 12345678910111213cipher = [0xcf,0xbf,0x80,0x3b,0xf6,0xaf,0x7e,0x02,0x24,0xed,0x70,0x3a,0xf4,0xeb,0x7a,0x4a,0xe7,0xf7,0xa2,0x67,0x17,0xf0,0xc6,0x76,0x36,0xe8,0xad,0x82,0x2e,0xdb,0xb7,0x4f,0xe6,0x09]table1 = [0xFE,0x21,0x44,0x67,0x8A,0xAD,0xD0,0xF3,0x16,0x39,0x5c,0x7f,0xa2,0xc5,0xe8,0x0b,0x2e,0x51,0x74,0x97,0xba,0xdd,0x00,0x23,0x46,0x69,0x8c,0xaf,0xd2,0xf5,0x18,0x3b,0x5e,0x81]table2 = [0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a,0xba,0x5a,0xfa,0x9a,0x3a,0xda,0x7a,0x1a]for i in range(34): if cipher[i] + table2[33-i] &lt; 256: cipher[i] += table2[33-i] else: cipher[i] = cipher[i] + table2[33-i] - 256for i in range(34): cipher[i] ^= table1[33-i] print(chr(cipher[i]),end = &quot;&quot;) ​ 这道题标准解法应该不是这样解的，而是要先要翻译出对应的汇编代码再分析，但这部分我还不太明白之后再补上吧 2.A 5 Second Challenge​ 这题要感谢小圆学长的耐心回答!! ​ 下载得到的是用unity制作的扫雷游戏，刚开始为了获得源码用 il2cppdumper 处理 GameAssembly.dll ，但发现处理后得到的不全，之后问了一下小圆学长发现源码已经给了。 ​ 打开 AFiveSecondChallenge.cpp ，源码里有 getUnixtime 这类获取时间的函数，游戏时间超过 5s 就会显示超时，用锁住系统时间的软件可以避开这一检测。锁定时间后就可以开始玩扫雷，几局下来后会发现雷的位置能构成二维码 ​ 根据题目提示，把 managed 文件夹下的 dll 拖到 ida 里，会发现有一个函数被nop掉了，定位到源码里查看（il2cpp的中间文件有些混乱，删除了影响判断的部分） ​ 这里的 return 判断是否是雷的位置，本来分析到这里已经很清楚了但是因为我完全不懂类和方法什么的看了挺久 ​ GetAt函数的返回值没在源码里看到有初始赋值于是迷惑了好久，又去问了一下小圆学长这部分是在哪里初始化过，得到回复说是在那个 dll 里面。 ​ 但是我在我下载的东西里面没发现 m_Items 初始化的部分，去网站上重新下载并拖到 ilspy ，得到了这个数组里的值 ​ 接下来就是写脚本解题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;math.h&gt;double matrix[45][15][3] = ;double GetAt(i, j, k){ int iBound = 45; //45 int jBound = 15; //15 int kBound = 3; //3 return matrix[i][j][k];}int main(){ int y,x; FILE* fp; fp = fopen(&quot;************&quot; , &quot;w&quot;); int a[45][45]; int i, j; for (y = 0; y &lt; 45; y++) { for (x = 0; x &lt; 45; x++) { double L_8 = GetAt(y, x / 3, 0); double L_14 = GetAt(y, x / 3, 1); double V_0 = L_14; double L_20 = GetAt(y, x / 3, 2); double V_1 = L_20; double V_2 = fmod(x, 3.0f) - 1.0f; a[x][y] = L_8* V_2* V_2 + V_0 * V_2 + V_1 &gt; 0.0 ? 1 : 0; //1是雷 } } for (i = 0; i &lt; 45; i++) { for (j = 0; j &lt; 45; j++) { printf(&quot;%d&quot;, a[j][i]); if (a[j][i] == 1) fprintf(fp, &quot;%d,%d\\n&quot;, j, i); } printf(&quot;\\n&quot;); } fclose(fp); return 0;} 123456import matplotlib.pyplot as pltimport numpy as npx,y = np.loadtxt('./xy.txt',delimiter=',',unpack=True)plt.plot(x,y,'.')plt.show() 3.nllvm​ 拖到 ida 里发现挺乱的，也没看到控制台输出的那些文字，那就先调试看看 ​ 调试后发现这些异或操作得到的就是控制台输出的字符，在输出后又来了一遍异或还原。 ​ 接着调试发现判断输入字符串的地方 ​ 这一部分异或得到 “CryptoFAILUREforRSA2048Key!!!!!!” 这个字符串，接着来到加密的函数 ​ 传入的就是这部分异或得到字符串和输入的 flag，之后看了一下这个函数里面是一些比较复杂的运算猜测是某种算法，我对各种算法不是很熟所以用了 ida 插件 findcrypt ，但是这个插件并没有找到什么算法于是我就去找学长确认了一下 ​ 查了各种算法，最后发现加密函数里面的一个函数像是s盒，根据s盒数字判断又是 AES 加密 ( s盒也是异或得到的，这大概是插件检测不出算法的原因 ) ​ 在调试过程中可以知道 iv值是 123456789abcdef ，判断是否为正确 flag 的部分与密文进行比较，改变了输出字符的外观（表示是否回到现实） ​ 之后用我在week2写的脚本解就行 ​ 查了一下题目里的 llvm ，是一款代码混淆器，具体的是看了这篇文章https://bbs.pediy.com/thread-224484.htm Misc1.Akira之瞳-1​ 查资料知道这种 dump 出来的RAW 文件要在 linux 里用 volatility 看，先查一下系统版本 ​ 接着用 pslist 查看一下系统进程，找到可疑的进程后 dump 出来 ​ 用 foremost 分离出一个加密的压缩包，本来以为密码还在 raw 文件里面的某个文件里来回看了好多遍，之后用 010editor 打开压缩包后发现提示，zip 密码是系统登陆密码 ​ hashdump 一下得到登陆密码的 hash 值 ​ 按提示把密码解出来 ​ 打开压缩包后发现两张图片，名字是src 和 blind，很容易就想到盲水印，用这个工具 (https://github.com/chishaxie/BlindWaterMark) 提取出水印 ​ 图片里小写的 L 是数字1 2.Akira之瞳-2​ 得到一个加密压缩包和 RAW 文件，同样先查看一下进程，发现 notepad进程 dump出来 ​ 在 dump 出来的进程里查一下 password 字符串，得到 zip 密码 ​ 打开压缩包得到 ​ 这几个文件名好像在哪里见过，翻了一下往年的 writeup 知道container 是加密容器，cookies 是chrome浏览器的 cookie 数据库。但是看 cookies 文件内容和打开加密卷都需要密码，回到 linux 里再查一下有无密码，因为是 notepad 进程那就查 txt 文件 ​ 这个 dumpme.txt 很可疑，提取出来发现之前 zip 密码还有后半句。百度一下知道 lastpass 是 chrome 浏览器的插件，用来记录密码的，把 lastpass 和 dump 放在一起搜索找到 volatility 里有 lastpass 这个插件 ​ 得到一个密码，下载 ChromeCookiesView ，加载 cookies 文件并输入密码，得到加密容器密码并提示用 VeraCrypt 打开 ​ 打开虚拟分区得到一张图片，查 ADS 得知 NTFS 隐写 ​ NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。 ​ 然后用 Ntfs Streams Editor 这个软件查看 ADS 流文件，得到 flag ​ 那个网址里的图是 Akira 学长的新头像 总结​ 为时四周的 hgme 要结束了，这个寒假学到了很多东西过得很充实，希望以后能继续学习这方面的知识，不断进步","link":"/2021/03/27/HGAME-Week4-Writeup/"}],"tags":[{"name":"hgame","slug":"hgame","link":"/tags/hgame/"}],"categories":[{"name":"Hgame2021","slug":"Hgame2021","link":"/categories/Hgame2021/"}]}